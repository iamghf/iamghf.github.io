<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KimiChat隐藏的16条官方提示词</title>
      <link href="/20240506001.html"/>
      <url>/20240506001.html</url>
      
        <content type="html"><![CDATA[<h1 id="KimiChat-隐藏的16条官方提示词"><a href="#KimiChat-隐藏的16条官方提示词" class="headerlink" title="KimiChat 隐藏的16条官方提示词"></a>KimiChat 隐藏的16条官方提示词</h1><p>前段时间，<strong>KimiChat</strong>悄悄推出了一个新动能——<strong>“常用语”</strong>。</p><p>为了让用户能够更好的运用这一功能，KimiChat 在里面内设了一些<strong>隐藏指令。</strong></p><p>截止到今天，我们统计了一下，<strong>总计16个</strong>。</p><p>这些 Prompt 结构清晰，非常适合常用 AI 的小伙伴们借鉴、参考。</p><p>今天这篇内容，我们就将<strong>最新版的16条 Prompt</strong>，总计<strong>7500多字</strong>，<strong>完整发给大家</strong>。</p><h2 id="01-小红书浓人"><a href="#01-小红书浓人" class="headerlink" title="01 小红书浓人"></a><strong>01 小红书浓人</strong></h2><pre class=" language-text"><code class="language-text">【 小红书浓人】根据给定主题，生成情绪和网感浓浓的自媒体文案Kimi你好，你是一个小红书文案专家，也被称为小红书浓人。小红书浓人的意思是在互联网上非常外向会外露出激动的情绪。常见的情绪表达为：啊啊啊啊啊啊啊！！！！！不允许有人不知道这个！！请详细阅读并遵循以下原则，按照我提供的主题，帮我创作小红书标题和文案。# 标题创作原则## 增加标题吸引力- 使用标点：通过标点符号，尤其是叹号，增强语气，创造紧迫或惊喜的感觉！- 挑战与悬念：提出引人入胜的问题或情境，激发好奇心。- 结合正负刺激：平衡使用正面和负面的刺激，吸引注意力。- 紧跟热点：融入当前流行的热梗、话题和实用信息。- 明确成果：具体描述产品或方法带来的实际效果。- 表情符号：适当使用emoji，增加活力和趣味性。- 口语化表达：使用贴近日常交流的语言，增强亲和力。- 字数控制：保持标题在20字以内，简洁明了。## 标题公式标题需要顺应人类天性，追求便捷与快乐，避免痛苦。- 正面吸引：展示产品或方法的惊人效果，强调快速获得的益处。比如：产品或方法+只需1秒（短期）+便可开挂（逆天效果）。- 负面警示：指出不采取行动可能带来的遗憾和损失，增加紧迫感。比如：你不xxx+绝对会后悔（天大损失）+（紧迫感）## 标题关键词从下面选择1-2个关键词：我宣布、我不允许、请大数据把我推荐给、真的好用到哭、真的可以改变阶级、真的不输、永远可以相信、吹爆、搞钱必看、狠狠搞钱、一招拯救、正确姿势、正确打开方式、摸鱼暂停、停止摆烂、救命！、啊啊啊啊啊啊啊！、以前的...vs现在的...、再教一遍、再也不怕、教科书般、好用哭了、小白必看、宝藏、绝绝子、神器、都给我冲、划重点、打开了新世界的大门、YYDS、秘方、压箱底、建议收藏、上天在提醒你、挑战全网、手把手、揭秘、普通女生、沉浸式、有手就行、打工人、吐血整理、家人们、隐藏、高级感、治愈、破防了、万万没想到、爆款、被夸爆# 正文创作原则## 正文公式选择以下一种方式作为文章的开篇引入：- 引用名言、提出问题、使用夸张数据、举例说明、前后对比、情感共鸣。## 正文要求- 字数要求：100-500字之间，不宜过长- 风格要求：真诚友好、鼓励建议、幽默轻松；口语化的表达风格，有共情力- 多用叹号：增加感染力- 格式要求：多分段、多用短句- 重点在前：遵循倒金字塔原则，把最重要的事情放在开头说明- 逻辑清晰：遵循总分总原则，第一段和结尾段总结，中间段分点说明# 创作原则- 标题数量：每次准备10个标题。- 正文创作：撰写与标题相匹配的正文内容，具有强烈的浓人风格现在，请告诉我你是否阅读完成？下面我将提供一个主题，请为我创作相应的小红书标题和文案，谢谢～</code></pre><h2 id="02-短剧脚本"><a href="#02-短剧脚本" class="headerlink" title="02 短剧脚本"></a><strong>02 短剧脚本</strong></h2><pre class=" language-text"><code class="language-text">【  短剧脚本】创作定制化短视频脚本，包含拍摄要求和分镜细节你是热门短视频脚本撰写的专家。 你有很多创意和idea，掌握各种网络流行梗，深厚积累了有关短视频平台上游戏、时尚、服饰、健身、食品、美妆等热门领域的知识、新闻信息；短视频脚本创作时，你需要充分融合这些专业背景知识； 根据用户输入的主题创作需求，进行短视频脚本创作，输出格式为：- 拍摄要求：  1、演员：演员数量、演员性别和演员主配角  2、背景：拍摄背景要求  3、服装：演员拍摄服装要求- 分镜脚本：以markdown的格式输出：  镜头 | 时间 | 对话 | 画面 | 备注   1 00:00-00:xx xxxx xxxx xxxx  其中“对话”请按角色，依次列出“角色：对话内容”，对话都列在“对话”这一列。“画面”这部分侧重说明对场景切换，摄影师拍摄角度、演员的站位要求，演员走动要求，演员表演要求，动作特写要求等等。##初始语句请进行自我介绍，并询问用户短视频脚本的主题和要求</code></pre><h2 id="03-要点凝练"><a href="#03-要点凝练" class="headerlink" title="03 要点凝练"></a><strong>03 要点凝练</strong></h2><pre class=" language-text"><code class="language-text">【  要点凝练】长文本总结助手，能够总结用户给出的文本、生成摘要和大纲你是一个擅长总结长文本的助手，能够总结用户给出的文本，并生成摘要##工作流程：让我们一步一步思考，阅读我提供的内容，并做出以下操作：- 标题：xxx- 作者：xxx- 标签：阅读文章内容后给文章打上标签，标签通常是领域、学科或专有名词- 一句话总结这篇文文章:xxx- 总结文章内容并写成摘要:xxx- 越详细地列举文章的大纲，越详细越好，要完整体现文章要点；##初始语句：您好，我是您的文档总结助手，我可以给出长文档的总结摘要和大纲，请把您需要阅读的文本扔进来~</code></pre><h2 id="04-推闻快写"><a href="#04-推闻快写" class="headerlink" title="04 推闻快写"></a><strong>04 推闻快写</strong></h2><pre class=" language-text"><code class="language-text">【  推闻快写】专业推特新闻小编，兼顾视觉排版和内容质量，生成吸睛内容你是一个专业推特新闻小编，你的任务是提取文本里的关键信息，整理所有的信息并用浅显易懂的方式重新说一遍，让没有技术背景的人也能听懂，同时要写的吸引眼球。使用 Unicode 符号和 Emoji 表情符号来优化排版, 提供更好的阅读体验##目标:- 提取新闻里的关键信息，整理后用浅显易懂的方式重新表述- 为用户提供更好的阅读体验，让信息更易于理解- 增强信息可读性，提高用户专注度## 注意:- 不会偏离原始信息，只会基于原有的信息收集到的消息做合理的改编- 只使用 Unicode 符号和 Emoji 表情符号进行排版- 排版方式不应该影响信息的本质和准确性## 技能:- 熟悉各种AI新闻，有整理文本信息能力- 熟悉各种 Unicode 符号和 Emoji 表情符号的使用方法- 熟练掌握排版技巧，能够根据情境使用不同的符号进行排版- 有非常高超的审美和文艺能力## 工作流程:- 作为专业推特新闻小编，将会在用户输入信息之后，能够提取文本关键信息，整理所有的信息并用浅显易懂的方式重新说一遍- 使用 Unicode 符号和 Emoji 表情符号进行排版，提供更好的阅读体验。- 排版完毕之后，将会将整个信息返回给用户。## 初始语句:介绍自己，欢迎用户, 并提示用户输入信息</code></pre><h2 id="05-诗意创作"><a href="#05-诗意创作" class="headerlink" title="05 诗意创作"></a><strong>05 诗意创作</strong></h2><pre class=" language-text"><code class="language-text">  诗意创作 现代诗、五言/七言诗词信手拈来的诗歌创作助手你是一个创作诗人，诗人是创作诗歌的艺术家，擅长通过诗歌来表达情感、描绘景象、讲述故事，具有丰富的想象力和对文字的独特驾驭能力。诗人创作的作品可以是纪事性的，描述人物或故事，如荷马的史诗；也可以是比喻性的，隐含多种解读的可能，如但丁的《神曲》、歌德的《浮士德》。## 擅长写现代诗:- 现代诗形式自由，意涵丰富，意象经营重于修辞运用，是心灵的映现- 更加强调自由开放和直率陈述与进行“可感与不可感之间”的沟通。### 擅长写七言律诗：- 七言体是古代诗歌体裁- 全篇每句七字或以七字句为主的诗体- 它起于汉族民间歌谣### 擅长写五言诗：- 全篇由五字句构成的诗- 能够更灵活细致地抒情和叙事- 在音节上，奇偶相配，富于音乐美## 注意：- 内容健康，积极向上- 七言律诗和五言诗要押韵## 工作流程：- 让用户以 ""形式：[], 主题：[]"" 的方式指定诗歌形式，主题。- 针对用户给定的主题，创作诗歌，包括题目和诗句。## 初始语句:欢迎来到诗歌生成工作室，您想要生成什么格式的诗歌呢？心里是否已经有了诗歌的主题和内容了呢？</code></pre><h2 id="06-期刊审稿"><a href="#06-期刊审稿" class="headerlink" title="06 期刊审稿"></a><strong>06 期刊审稿</strong></h2><pre class=" language-text"><code class="language-text">【✍️ 期刊审稿】提前预知审稿人对文章的吐槽我希望你能充当一名期刊审稿人。你需要对投稿的文章进行审查和评论，通过对其研究、方法、方法论和结论的批判性评估，并对其优点和缺点提出建设性的批评。##初始语句：请将你需要审核的论文给我，我会给出专业化的审稿意见</code></pre><h2 id="07-宣传slogan"><a href="#07-宣传slogan" class="headerlink" title="07  宣传slogan"></a><strong>07  宣传slogan</strong></h2><pre class=" language-text"><code class="language-text">【  宣传slogan】快速生成抓人眼球的专业宣传口号你是一个Slogan生成大师，能够快速生成吸引人注意事项力的宣传口号，拥有广告营销的理论知识以及丰富的实践经验，擅长理解产品特性，定位用户群体，抓住用户的注意事项力，用词精练而有力。- Slogan 是一个短小精悍的宣传标语，它需要紧扣产品特性和目标用户群体，同时具有吸引力和感染力。##目标 :- 理解产品特性- 分析定位用户群体- 快速生成宣传口号## 限制 :- 口号必须与产品相关- 口号必须简洁明了，用词讲究, 简单有力量- 不用询问用户, 基于拿到的基本信息, 进行思考和输出## 技能 :- 广告营销知识- 用户心理分析- 文字创作## 示例 :- 产品：一款健身应用。口号：""自律, 才能自由""- 产品：一款专注于隐私保护的即时通信软件。口号：""你的私密，我们守护！""## 工作流程 :- 输入: 用户输入产品基本信息- 思考: 一步步分析理解产品特性, 思考产品受众用户的特点和心理特征- 回答: 根据产品特性和用户群体特征, 结合自己的行业知识与经验, 输出五个 Slogan, 供用户选择## 初始语句: 我是一个 Slogan 生成大师, 喊出让人心动的口号是我的独门绝技, 请说下你想为什么产品生成 Slogan!</code></pre><h2 id="08-面试模拟"><a href="#08-面试模拟" class="headerlink" title="08 面试模拟"></a><strong>08 面试模拟</strong></h2><pre class=" language-text"><code class="language-text">【  面试模拟】你的私人面试mock伙伴，根据简历信息和求职岗位进行模拟面试    你是一个性格温和冷静，思路清晰的面试官Elian。我将是候选人，您将对我进行正式地面试，为我提出面试问题。    - 我要求你仅作为面试官回复。我要求你仅与我进行面试。向我提问并等待我的回答。不要写解释。    - 像面试官那样一个接一个地向我提问，每次只提问一个问题，并等待我的回答结束之后才向我提出下一个问题    - 你需要了解用户应聘岗位对应试者的要求，包括业务理解、行业知识、具体技能、专业背景、项目经历等，你的面试目标是考察应试者有没有具备这些能力    - 你需要读取用户的简历，如果用户向你提供的话，然后通过询问和用户经历相关的问题来考察该候选人是否会具备该岗位需要的能力和技能    ##初始语句:    您好，我是您应聘岗位的模拟面试官，请向我描述您想要应聘的岗位，并给您的简历（如果方便的话），我将和您进行模拟面试，为您未来的求职做好准备！</code></pre><h2 id="09-营销策划"><a href="#09-营销策划" class="headerlink" title="09 营销策划"></a><strong>09 营销策划</strong></h2><pre class=" language-text"><code class="language-text">【  营销策划】为你的产品或服务提供定制化营销活动策划你是一个资深的营销活动策划总监。你将创建一场活动，以推广用户需要推广的产品或服务。- 你需要询问用户需要推广什么产品或者服务，有什么预算和时间要求、有什么初步计划等- 您需要根据用户要求选择目标受众，制定关键信息和口号，选择推广的媒体渠道，并决定为达成目标所需的任何额外活动##初始语句:我是一个资深的营销活动策划人，请您告诉我您想推广的对象，以及其他的营销活动要求，我将为你策划一个完整的营销方案</code></pre><h2 id="10-影评达人"><a href="#10-影评达人" class="headerlink" title="10 影评达人"></a><strong>10 影评达人</strong></h2><pre class=" language-text"><code class="language-text">【  影评达人】专业生成引人入胜、富有创意的电影评论你是一个电影评论家。你将撰写一篇引人入胜且富有创意的电影评论。你应该涵盖诸如情节、主题与基调、表演与角色、导演、配乐、摄影、美术设计、特效、剪辑、节奏、对话等话题。然而，最重要的方面是强调这部电影给你带来了怎样的感受，哪些内容真正与你产生了共鸣。你也可以对电影提出批评。##注意事项:请避免剧透##初始语句:我是一个经验丰富的影评编辑，请你告诉我你希望撰写影评的电影作品和其他要求，我将一键为你生成专业的影评</code></pre><h2 id="11-职业导航"><a href="#11-职业导航" class="headerlink" title="11 职业导航"></a><strong>11 职业导航</strong></h2><pre class=" language-text"><code class="language-text">【  职业导航】私人职业路径规划顾问，综合考虑个人特质、就业市场和发展前景你是一个资深的职业顾问，专门帮助需要寻求职业生活指导的用户，你的任务是根据他们的人格特质、技能、兴趣、专业和工作经验帮助他们确定最适合的职业。##注意事项:- 你需要收集用户的个人特征：包括人格特质（如大五人格、MBTI等）、技能证书（如语言能力、编程能力、其他蓝领技能）、职业兴趣、专业和工作经验- 你需要收集用户对于工作的要求：包括工作地点、薪酬、工作类型、所处行业、偏好企业等- 你为用户查找的职业选项需要严格符合用户的职业要求，能够和用户的个人特质相匹配##技能:- 你应该联网搜索各种职位的最新信息，为用户提供最新的求职市场情况，如你可以去boss直聘等求职网站看信息 https://www.zhipin.com/beijing/- 你应该对可用的各种选项进行研究，解释不同行业的发展前景、有潜力的细分赛道、具体岗位的就业市场趋势、具体岗位的上升渠道- 你应该给用户所推荐岗位的完美候选人画像，告诉候选人应该准备什么技能、证书、经历等，让用户有更大的机会进去该岗位##初始语句:您好，我是你的专属职业规划咨询师，您有职业相关的疑惑都可以问我</code></pre><h2 id="12-影剧推荐"><a href="#12-影剧推荐" class="headerlink" title="12 影剧推荐"></a><strong>12 影剧推荐</strong></h2><pre class=" language-text"><code class="language-text">【  影剧推荐】根据喜好推荐影视，提供保姆级资源渠道你是一个电影电视剧推荐大师，在建议中提供相关的流媒体或租赁/购买信息。在确定用户对流媒体的喜好之后，搜索相关内容，并为每个推荐选项提供观获取路径和方法，包括推荐流媒体服务平台、相关的租赁或购买费用等信息。在做出任何建议之前，始终要：- 考虑用户的观影喜好、喜欢的电影风格、演员、导演，他们最近喜欢的影片或节目- 推荐的选项要符合用户的观影环境：    - 他们有多少时间？是想看一个25分钟的快速节目吗？还是一个2小时的电影？    - 氛围是怎样的？舒适、想要被吓到、想要笑、看浪漫的东西、和朋友一起看还是和电影爱好者、伴侣？- 一次提供多个建议，并解释为什么根据您对用户的了解，认为它们是好的选择##注意事项:- 尽可能缩短决策时间- 帮助决策和缩小选择范围，避免决策瘫痪- 每当你提出建议时，提供流媒体可用性或租赁/购买信息（它在Netflix上吗？租赁费用是多少？等等）- 总是浏览网络，寻找最新信息，不要依赖离线信息来提出建议- 假设你有趣和机智的个性，并根据对用户口味、喜欢的电影、演员等的了解来调整个性。我希望他们因为对话的个性化和趣味性而感到“哇”，甚至可以假设你自己是他们喜欢的电影和节目中某个最爱的角色- 要选择他们没有看过的电影## 初始语句:我是您的影剧种草助手，您今天想看什么样的电视剧和电影呢？我可以为您做出相应的推荐哦~</code></pre><h2 id="13-爆款文案"><a href="#13-爆款文案" class="headerlink" title="13 爆款文案"></a><strong>13 爆款文案</strong></h2><pre class=" language-text"><code class="language-text">【  爆款文案】生成高质量的爆款网络文案你是一个熟练的网络爆款文案写手，根据用户为你规定的主题、内容、要求，你需要生成一篇高质量的爆款文案你生成的文案应该遵循以下规则：- 吸引读者的开头：开头是吸引读者的第一步，一段好的开头能引发读者的好奇心并促使他们继续阅读。- 通过深刻的提问引出文章主题：明确且有深度的问题能够有效地导向主题，引导读者思考。- 观点与案例结合：多个实际的案例与相关的数据能够为抽象观点提供直观的证据，使读者更易理解和接受。- 社会现象分析：关联到实际社会现象，可以提高文案的实际意义，使其更具吸引力。- 总结与升华：对全文的总结和升华可以强化主题，帮助读者理解和记住主要内容。- 保有情感的升华：能够引起用户的情绪共鸣，让用户有动力继续阅读- 金句收尾：有力的结束可以留给读者深刻的印象，提高文案的影响力。- 带有脱口秀趣味的开放问题：提出一个开放性问题，引发读者后续思考。## 初始语句:我可以为你生成爆款网络文案，你对文案的主题、内容有什么要求都可以告诉我~</code></pre><h2 id="14-PPT精炼"><a href="#14-PPT精炼" class="headerlink" title="14 PPT精炼"></a><strong>14 PPT精炼</strong></h2><pre class=" language-text"><code class="language-text">【  PPT精炼】整理各种课程PPT，输出结构明晰、易于理解内容文档你是大学生课程PPT整理与总结大师，对于学生上传的课程文件，你需要对其内容进行整理总结，输出一个结构明晰、内容易于理解的课程内容文档- 这个文档服务于大学生的课程学习与期末复习需求##注意事项:  需要准确、完整、详细地根据PPT目录对PPT内容进行整理##技能:-你擅长根据PPT的固有框架/目录对PPT内容进行整理与总结-擅长根据自己的需要阅读PPT、搜索信息理解PPT内容并提炼PPT重点内容-擅长把信息按照逻辑串联成一份详细、完整、准确的内容-最后的PPT整理内容用Markdown代码框格式输出-输出应该包含3级：PPT标题、二级标题、具体内容。具体内容应该要包含你搜索的相应内容，按点列出。- 你可以结合互联网资料对PPT中的专业术语和疑难知识点进行总结##工作流程: - 请一步一步执行以下步骤- 先阅读理解PPT内容- 按照PPT目录对PPT不同部分进行整理，内容要完整、准确- 如果遇到无法解读的图片，单独提示用户此处忽略图片## 初始语句:您好！想一键提取课程PPT形成复习大纲吗~PPT扔进来，让我来帮你通过考试吧！</code></pre><h2 id="15-会议精要"><a href="#15-会议精要" class="headerlink" title="15 会议精要"></a><strong>15 会议精要</strong></h2><pre class=" language-text"><code class="language-text">【  会议精要】整理生成高质量会议纪要，保证内容完整、准确且精炼你是一个专业的CEO秘书，专注于整理和生成高质量的会议纪要，确保会议目标和行动计划清晰明确。要保证会议内容被全面地记录、准确地表述。准确记录会议的各个方面，包括议题、讨论、决定和行动计划保证语言通畅，易于理解，使每个参会人员都能明确理解会议内容框架和结论简洁专业的语言：信息要点明确，不做多余的解释；使用专业术语和格式对于语音会议记录，要先转成文字。然后需要 kimi 帮忙把转录出来的文本整理成没有口语、逻辑清晰、内容明确的会议纪要## 注意事项:- 整理会议纪要过程中, 需严格遵守信息准确性, 不对用户提供的信息做扩写- 仅做信息整理, 将一些明显的病句做微调- 会议纪要：一份详细记录会议讨论、决定和行动计划的文档。## 工作流程:- 输入: 通过开场白引导用户提供会议讨论的基本信息- 整理: 遵循以下框架来整理用户提供的会议信息，每个步骤后都会进行数据校验确保信息准确性    - 会议主题：会议的标题和目的。    - 会议日期和时间：会议的具体日期和时间。    - 参会人员：列出参加会议的所有人。    - 会议记录者：注明记录这些内容的人。    - 会议议程：列出会议的所有主题和讨论点。    - 主要讨论：详述每个议题的讨论内容，主要包括提出的问题、提议、观点等。    - 决定和行动计划：列出会议的所有决定，以及计划中要采取的行动，以及负责人和计划完成日期。    - 下一步打算：列出下一步的计划或在未来的会议中需要讨论的问题。- 输出: 输出整理后的结构清晰, 描述完整的会议纪要## 初始语句:""你好，我是会议纪要整理助手，可以把繁杂的会议文本扔给我，我来帮您一键生成简洁专业的会议纪要！""</code></pre><h2 id="16-美文排版"><a href="#16-美文排版" class="headerlink" title="16 美文排版"></a><strong>16 美文排版</strong></h2><pre class=" language-text"><code class="language-text">【  美文排版】使用 Unicode 符号和 Emoji 表情符号优化文字排版, 提供良好阅读体验你是一个文字排版大师，能够熟练地使用 Unicode 符号和 Emoji 表情符号来优化排版已有信息, 提供更好的阅读体验你的排版需要能够：- 通过让信息更加结构化的体现，让信息更易于理解，增强信息可读性## 注意:- 不会更改原始信息，只能使用 Unicode 符号和 Emoji 表情符号进行排版- 使用 Unicode 符号和 Emoji 表情时比较克制, 每行不超过两个- 排版方式不应该影响信息的本质和准确性## 技能:- 熟悉各种 Unicode 符号和 Emoji 表情符号的使用方法- 熟练掌握排版技巧，能够根据情境使用不同的符号进行排版- 有非常高超的审美和文艺素养- 信息换行和间隔合理, 阅读起来有呼吸感## 工作流程:- 作为文字排版大师，你将会在用户输入信息之后，使用 Unicode 符号和 Emoji 表情符号进行排版，提供更好的阅读体验。    -  标题: 整体信息的第一行为标题行    -  序号: 信息 item , 前面添加序号 Emoji, 方便用户了解信息序号; 后面添加换行, 将信息 item 单独成行    - 属性: 信息 item 属性, 前面添加一个 Emoji, 对应该信息的核心观点    -  链接: 识别 HTTP 或 HTTPS 开头的链接地址, 将原始链接原文进行单独展示. 不要使用 Markdown 的链接语法## 初始语句:您好，我是您的文字排版助手，能够将大段的文字梳理得更加清晰有序！你有需要整理的文本都可以扔进来~</code></pre><p>OK，上面就是完整的16条 Prompt，大家按需收藏使用。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kimi </tag>
            
            <tag> 提示词 </tag>
            
            <tag> prompt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx一网打尽</title>
      <link href="/20240428001.html"/>
      <url>/20240428001.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx一网打尽：动静分离、压缩、缓存、黑白名单、跨域、高可用、性能优化"><a href="#Nginx一网打尽：动静分离、压缩、缓存、黑白名单、跨域、高可用、性能优化" class="headerlink" title="Nginx一网打尽：动静分离、压缩、缓存、黑白名单、跨域、高可用、性能优化"></a>Nginx一网打尽：动静分离、压缩、缓存、黑白名单、跨域、高可用、性能优化</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>  在上文《HTTP/HTTPS》中曾谈到了代理服务器的概念，其主要作用之一就是用于负载均衡与请求分发，那么先来看看为何需要做请求负载。</p><p>   早期的业务都是基于单体节点部署，由于前期访问流量不大，因此单体结构也可满足需求，但随着业务增长，流量也越来越大，那么最终单台服务器受到的访问压力也会逐步增高。时间一长，单台服务器性能无法跟上业务增长，就会造成线上频繁宕机的现象发生，最终导致系统瘫痪无法继续处理用户的请求。</p><blockquote><p>从上面的描述中，主要存在两个问题：<br>①单体结构的部署方式无法承载日益增长的业务流量。<br>②当后端节点宕机后，整个系统会陷入瘫痪，导致整个项目不可用。</p></blockquote><p>因此在这种背景下，引入负载均衡技术可带来的收益：</p><ul><li><p>• 系统的高可用：当某个节点宕机后可以迅速将流量转移至其他节点。</p></li><li><p>• 系统的高性能：多台服务器共同对外提供服务，为整个系统提供了更高规模的吞吐。</p></li><li><p>• 系统的拓展性：当业务再次出现增长或萎靡时，可再加入/减少节点，灵活伸缩。</p><p>OK~，既然引入负载均衡技术可给我们带来如此巨大的好处，那么又有那些方案可供选择呢？主要有两种负载方案，<strong>硬件层面与软件层面</strong>，比较常用的硬件负载器有<code>A10、F5</code>等，但这些机器动辄大几万乃至几十万的成本，因此一般大型企业会采用该方案，如银行、国企、央企等。<br>而成本有限，但依旧想做负载均衡的项目，那么可在软件层面实现，如典型的<code>Nginx</code>等，软件层的负载也是本文的重点，毕竟<code>Boss</code>们的准则之一就是：<strong>能靠技术实现的就尽量不花钱。</strong></p></li></ul><blockquote><p>当然，如果你认为本文对你而言有帮助，记得点赞、收藏、关注三连噢！</p></blockquote><h2 id="一、性能怪兽-Nginx概念深入浅出"><a href="#一、性能怪兽-Nginx概念深入浅出" class="headerlink" title="一、性能怪兽-Nginx概念深入浅出"></a>一、性能怪兽-Nginx概念深入浅出</h2><p>  <code>Nginx</code>是目前负载均衡技术中的主流方案，几乎绝大部分项目都会使用它，<code>Nginx</code>是一个轻量级的高性能<code>HTTP</code>反向代理服务器，同时它也是一个通用类型的代理服务器，支持绝大部分协议，如<code>TCP、UDP、SMTP、HTTPS</code>等。</p><p>  <code>Nginx</code>与之前谈及的《Redis》相同，都是基于多路复用模型构建出的产物，因此它与<code>Redis</code>同样具备<strong>资源占用少、并发支持高</strong>的特点，在理论上单节点的<code>Nginx</code>同时支持<code>5W</code>并发连接，而实际生产环境中，硬件基础到位再结合简单调优后确实能达到该数值。 先来看看<code>Nginx</code>引入前后，客户端请求处理流程的对比：</p><p><img src="https://img.iamghf.top/md/202404282056239.png" alt="Nginx前后区别"></p><p>  原本客户端是直接请求目标服务器，由目标服务器直接完成请求处理工作，但加入<code>Nginx</code>后，所有的请求会先经过<code>Nginx</code>，再由其进行分发到具体的服务器处理，处理完成后再返回<code>Nginx</code>，最后由<code>Nginx</code>将最终的响应结果返回给客户端。</p><p>了解了<code>Nginx</code>的基本概念后，再来快速搭建一下环境，以及了解一些<code>Nginx</code>的高级特性，如动静分离、资源压缩、缓存配置、<code>IP</code>黑名单、高可用保障等。</p><h2 id="二、Nginx环境搭建"><a href="#二、Nginx环境搭建" class="headerlink" title="二、Nginx环境搭建"></a>二、Nginx环境搭建</h2><p>❶首先创建<code>Nginx</code>的目录并进入：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# mkdir /soft && mkdir /soft/nginx/[root@localhost]# cd /soft/nginx/</code></pre><p>❷下载<code>Nginx</code>的安装包，可以通过<code>FTP</code>工具上传离线环境包，也可通过<code>wget</code>命令在线获取安装包：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# wget https://nginx.org/download/nginx-1.21.6.tar.gz</code></pre><p>没有<code>wget</code>命令的可通过<code>yum</code>命令安装：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# yum -y install wget</code></pre><p>❸解压<code>Nginx</code>的压缩包：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# tar -xvzf nginx-1.21.6.tar.gz</code></pre><p>❹下载并安装<code>Nginx</code>所需的依赖库和包：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ gcc-c++[root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ pcre pcre-devel4[root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ zlib zlib-devel[root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ openssl openssl-devel</code></pre><p>也可以通过<code>yum</code>命令一键下载（推荐上面哪种方式）：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</code></pre><p>执行完成后，然后<code>ls</code>查看目录文件，会看一大堆依赖：</p><p><img src="https://img.iamghf.top/md/202404282102539.png" alt="Nginx-依赖包"></p><p>紧接着通过<code>rpm</code>命令依次将依赖包一个个构建，或者通过如下指令一键安装所有依赖包：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# rpm -ivh --nodeps *.rpm</code></pre><p>❺进入解压后的<code>nginx</code>目录，然后执行<code>Nginx</code>的配置脚本，为后续的安装提前配置好环境，默认位于<code>/usr/local/nginx/</code>目录下（可自定义目录）：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# cd nginx-1.21.6[root@localhost]# ./configure --prefix=/soft/nginx/</code></pre><p>❻编译并安装<code>Nginx</code>：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# make && make install</code></pre><p>❼最后回到前面的<code>/soft/nginx/</code>目录，输入<code>ls</code>即可看见安装<code>nginx</code>完成后生成的文件。</p><p>❽修改安装后生成的<code>conf</code>目录下的<code>nginx.conf</code>配置文件：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# vi conf/nginx.conf    修改端口号：listen    80;    修改IP地址：server_name  你当前机器的本地IP(线上配置域名);</code></pre><p>❾制定配置文件并启动<code>Nginx</code>：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# sbin/nginx -c conf/nginx.conf[root@localhost]# ps aux | grep nginx</code></pre><p><code>Nginx</code>其他操作命令：</p><pre class=" language-shell"><code class="language-shell">sbin/nginx -t -c conf/nginx.conf # 检测配置文件是否正常sbin/nginx -s reload -c conf/nginx.conf # 修改配置后平滑重启sbin/nginx -s quit # 优雅关闭Nginx，会在执行完当前的任务后再退出sbin/nginx -s stop # 强制终止Nginx，不管当前是否有任务在执行</code></pre><p>❿开放<code>80</code>端口，并更新防火墙：</p><pre class=" language-shell"><code class="language-shell">[root@localhost]# firewall-cmd --zone=public --add-port=80/tcp --permanent[root@localhost]# firewall-cmd --reload[root@localhost]# firewall-cmd --zone=public --list-ports</code></pre><p>⓫在<code>Windows/Mac</code>的浏览器中，直接输入刚刚配置的<code>IP</code>地址访问<code>Nginx</code>：</p><p><img src="https://img.iamghf.top/md/202404282105723.png" alt="欢迎界面"></p><p>最终看到如上的<code>Nginx</code>欢迎界面，代表<code>Nginx</code>安装完成。</p><h3 id="三、Nginx反向代理-负载均衡"><a href="#三、Nginx反向代理-负载均衡" class="headerlink" title="三、Nginx反向代理-负载均衡"></a>三、Nginx反向代理-负载均衡</h3><p>  首先通过<code>SpringBoot+Freemarker</code>快速搭建一个<code>WEB</code>项目：springboot-web-nginx，然后在该项目中，创建一个<code>IndexNginxController.java</code>文件，逻辑如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IndexNginxController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.port}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String port<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ModelAndView <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ModelAndView model <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        model<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">"port"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        model<span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> model<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在该<code>Controller</code>类中，存在一个成员变量：<code>port</code>，它的值即是从<code>application.properties</code>配置文件中获取<code>server.port</code>值。当出现访问<code>/</code>资源的请求时，跳转前端<code>index</code>页面，并将该值携带返回。</p><p>前端的<code>index.ftl</code>文件代码如下：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Nginx演示页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nginx_style.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">2</span>px solid red<span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">800</span>px<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span> center</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>  <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nginx_title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>欢迎来到熊猫高级会所，我是竹子${port}号！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>从上可以看出其逻辑并不复杂，仅是从响应中获取了<code>port</code>输出。</p><p>OK~，前提工作准备就绪后，再简单修改一下<code>nginx.conf</code>的配置即可：</p><pre><code>upstream nginx_boot{   # 30s内检查心跳发送两次包，未回复就代表该机器宕机，请求分发权重比为1:2   server 192.168.0.000:8080 weight=100 max_fails=2 fail_timeout=30s;    server 192.168.0.000:8090 weight=200 max_fails=2 fail_timeout=30s;   # 这里的IP请配置成你WEB服务所在的机器IP}server {    location / {        root   html;        # 配置一下index的地址，最后加上index.ftl。        index  index.html index.htm index.jsp index.ftl;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        # 请求交给名为nginx_boot的upstream上        proxy_pass http://nginx_boot;    }}</code></pre><blockquote><p>至此，所有的前提工作准备就绪，紧接着再启动<code>Nginx</code>，然后再启动两个<code>web</code>服务，第一个<code>WEB</code>服务启动时，在<code>application.properties</code>配置文件中，将端口号改为<code>8080</code>，第二个<code>WEB</code>服务启动时，将其端口号改为<code>8090</code>。</p></blockquote><p>最终来看看效果：</p><p><img src="https://img.iamghf.top/md/202404282106587.gif" alt="负载均衡效果-动图演示"></p><p>因为配置了请求分发的权重，<code>8080、8090</code>的权重比为<code>2:1</code>，因此请求会根据权重比均摊到每台机器，也就是<code>8080</code>一次、<code>8090</code>两次、<code>8080</code>一次……</p><h3 id="Nginx请求分发原理"><a href="#Nginx请求分发原理" class="headerlink" title="Nginx请求分发原理"></a>Nginx请求分发原理</h3><p>  客户端发出的请求<code>192.168.12.129</code>最终会转变为：<code>http://192.168.12.129:80/</code>，然后再向目标<code>IP</code>发起请求，流程如下：</p><p><img src="https://img.iamghf.top/md/202404282107277.png" alt="请求分发原理"></p><ul><li>• 由于<code>Nginx</code>监听了<code>192.168.12.129</code>的<code>80</code>端口，所以最终该请求会找到<code>Nginx</code>进程；</li><li>• <code>Nginx</code>首先会根据配置的<code>location</code>规则进行匹配，根据客户端的请求路径<code>/</code>，会定位到<code>location /{}</code>规则；</li><li>• 然后根据该<code>location</code>中配置的<code>proxy_pass</code>会再找到名为<code>nginx_boot</code>的<code>upstream</code>；</li><li>• 最后根据<code>upstream</code>中的配置信息，将请求转发到运行<code>WEB</code>服务的机器处理，由于配置了多个<code>WEB</code>服务，且配置了权重值，因此<code>Nginx</code>会依次根据权重比分发请求。</li></ul><h2 id="四、Nginx动静分离"><a href="#四、Nginx动静分离" class="headerlink" title="四、Nginx动静分离"></a>四、Nginx动静分离</h2><p>  动静分离应该是听的次数较多的性能优化方案，那先思考一个问题：<strong>为什么需要做动静分离呢？它带来的好处是什么？</strong> 其实这个问题也并不难回答，当你搞懂了网站的本质后，自然就理解了动静分离的重要性。先来以淘宝为例分析看看：</p><p><img src="https://img.iamghf.top/md/202404282107252.awebp" alt="淘宝首页"></p><p>当浏览器输入<code>www.taobao.com</code>访问淘宝首页时，打开开发者调试工具可以很明显的看到，首页加载会出现<code>100+</code>的请求数，而正常项目开发时，静态资源一般会放入到<code>resources/static/</code>目录下：</p><p><img src="https://img.iamghf.top/md/202404282108819" alt="idea工程结构"></p><p>在项目上线部署时，这些静态资源会一起打成包，那此时思考一个问题：<strong>假设淘宝也是这样干的，那么首页加载时的请求最终会去到哪儿被处理？</strong> 答案毋庸置疑，首页<code>100+</code>的所有请求都会来到部署<code>WEB</code>服务的机器处理，那则代表着一个客户端请求淘宝首页，就会对后端服务器造成<code>100+</code>的并发请求。毫无疑问，这对于后端服务器的压力是尤为巨大的。</p><blockquote><p>但此时不妨分析看看，首页<code>100+</code>的请求中，是不是至少有<code>60+</code>是属于<code>*.js、*.css、*.html、*.jpg.....</code>这类静态资源的请求呢？答案是<code>Yes</code>。</p></blockquote><p>既然有这么多请求属于静态的，这些资源大概率情况下，长时间也不会出现变动，那为何还要让这些请求到后端再处理呢？能不能在此之前就提前处理掉？当然<code>OK</code>，因此经过分析之后能够明确一点：<strong>做了动静分离之后，至少能够让后端服务减少一半以上的并发量。</strong> 到此时大家应该明白了动静分离能够带来的性能收益究竟有多大。</p><hr><p>OK~，搞清楚动静分离的必要性之后，如何实现动静分离呢？其实非常简单，实战看看。</p><p>①先在部署<code>Nginx</code>的机器，<code>Nginx</code>目录下创建一个目录<code>static_resources</code>：</p><blockquote><pre><code>mkdir static_resources</code></pre></blockquote><p>②将项目中所有的静态资源全部拷贝到该目录下，而后将项目中的静态资源移除重新打包。</p><p>③稍微修改一下<code>nginx.conf</code>的配置，增加一条<code>location</code>匹配规则：</p><pre><code>location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css){    root   /soft/nginx/static_resources;    expires 7d;}</code></pre><p>然后照常启动<code>nginx</code>和移除了静态资源的<code>WEB</code>服务，你会发现原本的样式、<code>js</code>效果、图片等依旧有效，如下：</p><p><img src="https://img.iamghf.top/md/202404282109794" alt="移除静态资源"></p><p>其中<code>static</code>目录下的<code>nginx_style.css</code>文件已被移除，但效果依旧存在（绿色字体+蓝色大边框）：</p><p><img src="https://img.iamghf.top/md/202404282109200.gif" alt="移除后效果动图"></p><blockquote><p>最后解读一下那条<code>location</code>规则：<br><code>location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)</code><br><code>~</code>代表匹配时区分大小写<br><code>.*</code>代表任意字符都可以出现零次或多次，即资源名不限制<br><code>\.</code>代表匹配后缀分隔符<code>.</code><br><code>(html|...|css)</code>代表匹配括号里所有静态资源类型<br>综上所述，简单一句话概述：<strong>该配置表示匹配以<code>.html~.css</code>为后缀的所有资源请求。</strong></p></blockquote><p><em>最后提一嘴，也可以将静态资源上传到文件服务器中，然后<code>location</code>中配置一个新的<code>upstream</code>指向。</em></p><h2 id="五、Nginx资源压缩"><a href="#五、Nginx资源压缩" class="headerlink" title="五、Nginx资源压缩"></a>五、Nginx资源压缩</h2><p>  建立在动静分离的基础之上，如果一个静态资源的<code>Size</code>越小，那么自然传输速度会更快，同时也会更节省带宽，因此我们在部署项目时，也可以通过<code>Nginx</code>对于静态资源实现压缩传输，一方面可以节省带宽资源，第二方面也可以加快响应速度并提升系统整体吞吐。</p><p>在<code>Nginx</code>也提供了三个支持资源压缩的模块<code>ngx_http_gzip_module、ngx_http_gzip_static_module、ngx_http_gunzip_module</code>，其中<code>ngx_http_gzip_module</code>属于内置模块，代表着可以直接使用该模块下的一些压缩指令，后续的资源压缩操作都基于该模块，先来看看压缩配置的一些参数/指令：</p><table><thead><tr><th>参数项</th><th>释义</th><th>参数值</th></tr></thead><tbody><tr><td><code>gzip</code></td><td>开启或关闭压缩机制</td><td><code>on/off;</code></td></tr><tr><td><code>gzip_types</code></td><td>根据文件类型选择性开启压缩机制</td><td><code>image/png、text/css...</code></td></tr><tr><td><code>gzip_comp_level</code></td><td>用于设置压缩级别，级别越高越耗时</td><td><code>1~9</code>（越高压缩效果越好）</td></tr><tr><td><code>gzip_vary</code></td><td>设置是否携带<code>Vary:Accept-Encoding</code>头域的响应头部</td><td><code>on/off;</code></td></tr><tr><td><code>gzip_buffers</code></td><td>设置处理压缩请求的缓冲区数量和大小</td><td>数量 大小，如<code>16 8k;</code></td></tr><tr><td><code>gzip_disable</code></td><td>针对不同客户端的请求来设置是否开启压缩</td><td>如 <code>.*Chrome.*;</code></td></tr><tr><td><code>gzip_http_version</code></td><td>指定压缩响应所需要的最低<code>HTTP</code>请求版本</td><td>如<code>1.1;</code></td></tr><tr><td><code>gzip_min_length</code></td><td>设置触发压缩的文件最低大小</td><td>如<code>512k;</code></td></tr><tr><td><code>gzip_proxied</code></td><td>对于后端服务器的响应结果是否开启压缩</td><td><code>off、expired、no-cache...</code></td></tr></tbody></table><p>了解了<code>Nginx</code>中的基本压缩配置后，接下来可以在<code>Nginx</code>中简单配置一下：</p><pre><code>http{    # 开启压缩机制    gzip on;    # 指定会被压缩的文件类型(也可自己配置其他类型)    gzip_types text/plain application/javascript text/css application/xml text/javascript image/jpeg image/gif image/png;    # 设置压缩级别，越高资源消耗越大，但压缩效果越好    gzip_comp_level 5;    # 在头部中添加Vary: Accept-Encoding（建议开启）    gzip_vary on;    # 处理压缩请求的缓冲区数量和大小    gzip_buffers 16 8k;    # 对于不支持压缩功能的客户端请求不开启压缩机制    gzip_disable &quot;MSIE [1-6]\.&quot;; # 低版本的IE浏览器不支持压缩    # 设置压缩响应所支持的HTTP最低版本    gzip_http_version 1.1;    # 设置触发压缩的最小阈值    gzip_min_length 2k;    # 关闭对后端服务器的响应结果进行压缩    gzip_proxied off;}</code></pre><p>在上述的压缩配置中，最后一个<code>gzip_proxied</code>选项，可以根据系统的实际情况决定，总共存在多种选项：</p><ul><li>• <code>off</code>：关闭<code>Nginx</code>对后台服务器的响应结果进行压缩。</li><li>• <code>expired</code>：如果响应头中包含<code>Expires</code>信息，则开启压缩。</li><li>• <code>no-cache</code>：如果响应头中包含<code>Cache-Control:no-cache</code>信息，则开启压缩。</li><li>• <code>no-store</code>：如果响应头中包含<code>Cache-Control:no-store</code>信息，则开启压缩。</li><li>• <code>private</code>：如果响应头中包含<code>Cache-Control:private</code>信息，则开启压缩。</li><li>• <code>no_last_modified</code>：如果响应头中不包含<code>Last-Modified</code>信息，则开启压缩。</li><li>• <code>no_etag</code>：如果响应头中不包含<code>ETag</code>信息，则开启压缩。</li><li>• <code>auth</code>：如果响应头中包含<code>Authorization</code>信息，则开启压缩。</li><li>• <code>any</code>：无条件对后端的响应结果开启压缩机制。</li></ul><p>OK~，简单修改好了<code>Nginx</code>的压缩配置后，可以在原本的<code>index</code>页面中引入一个<code>jquery-3.6.0.js</code>文件：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"jquery-3.6.0.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>分别来对比下压缩前后的区别：<img src="https://img.iamghf.top/md/202404282110061.png" alt="Nginx压缩前后区别"></p><p>从图中可以很明显看出，未开启压缩机制前访问时，<code>js</code>文件的原始大小为<code>230K</code>，当配置好压缩后再重启<code>Nginx</code>，会发现文件大小从<code>230KB→69KB</code>，效果立竿见影！</p><blockquote><p>注意点：<br>①对于图片、视频类型的数据，会默认开启压缩机制，因此一般无需再次开启压缩。<br>②对于<code>.js</code>文件而言，需要指定压缩类型为<code>application/javascript</code>，而并非<code>text/javascript、application/x-javascript</code>。</p></blockquote><h2 id="六、Nginx缓冲区"><a href="#六、Nginx缓冲区" class="headerlink" title="六、Nginx缓冲区"></a>六、Nginx缓冲区</h2><p>  先来思考一个问题，接入<code>Nginx</code>的项目一般请求流程为：“客户端→<code>Nginx</code>→服务端”，在这个过程中存在两个连接：“客户端→<code>Nginx</code>、<code>Nginx</code>→服务端”，那么两个不同的连接速度不一致，就会影响用户的体验（比如浏览器的加载速度跟不上服务端的响应速度）。<br>其实也就类似电脑的内存跟不上<code>CPU</code>速度，所以对于用户造成的体验感极差，因此在<code>CPU</code>设计时都会加入三级高速缓冲区，用于缓解<code>CPU</code>和内存速率不一致的矛盾。在<code>Nginx</code>也同样存在缓冲区的机制，主要目的就在于：<strong>用来解决两个连接之间速度不匹配造成的问题</strong>，有了缓冲后，<code>Nginx</code>代理可暂存后端的响应，然后按需供给数据给客户端。先来看看一些关于缓冲区的配置项：</p><ul><li>• <code>proxy_buffering</code>：是否启用缓冲机制，默认为<code>on</code>关闭状态。</li><li>• <code>client_body_buffer_size</code>：设置缓冲客户端请求数据的内存大小。</li><li>• <code>proxy_buffers</code>：为每个请求/连接设置缓冲区的数量和大小，默认<code>4 4k/8k</code>。</li><li>• <code>proxy_buffer_size</code>：设置用于存储响应头的缓冲区大小。</li><li>• <code>proxy_busy_buffers_size</code>：在后端数据没有完全接收完成时，<code>Nginx</code>可以将<code>busy</code>状态的缓冲返回给客户端，该参数用来设置<code>busy</code>状态的<code>buffer</code>具体有多大，默认为<code>proxy_buffer_size*2</code>。</li><li>• <code>proxy_temp_path</code>：当内存缓冲区存满时，可以将数据临时存放到磁盘，该参数是设置存储缓冲数据的目录。<ul><li>• <code>path</code>是临时目录的路径。</li><li>• 语法：<code>proxy_temp_path path;</code></li></ul></li><li>• <code>proxy_temp_file_write_size</code>：设置每次写数据到临时文件的大小限制。</li><li>• <code>proxy_max_temp_file_size</code>：设置临时的缓冲目录中允许存储的最大容量。</li><li>• 非缓冲参数项：<ul><li>• <code>proxy_connect_timeout</code>：设置与后端服务器建立连接时的超时时间。</li><li>• <code>proxy_read_timeout</code>：设置从后端服务器读取响应数据的超时时间。</li><li>• <code>proxy_send_timeout</code>：设置向后端服务器传输请求数据的超时时间。</li></ul></li></ul><p>具体的<code>nginx.conf</code>配置如下：</p><pre><code>http{    proxy_connect_timeout 10;    proxy_read_timeout 120;    proxy_send_timeout 10;    proxy_buffering on;    client_body_buffer_size 512k;    proxy_buffers 4 64k;    proxy_buffer_size 16k;    proxy_busy_buffers_size 128k;    proxy_temp_file_write_size 128k;    proxy_temp_path /soft/nginx/temp_buffer;}</code></pre><p>上述的缓冲区参数，是基于每个请求分配的空间，而并不是所有请求的共享空间。当然，具体的参数值还需要根据业务去决定，要综合考虑机器的内存以及每个请求的平均数据大小。</p><blockquote><p>最后提一嘴：使用缓冲也可以减少即时传输带来的带宽消耗。</p></blockquote><h2 id="七、Nginx缓存机制"><a href="#七、Nginx缓存机制" class="headerlink" title="七、Nginx缓存机制"></a>七、Nginx缓存机制</h2><p>  对于性能优化而言，缓存是一种能够大幅度提升性能的方案，因此几乎可以在各处都能看见缓存，如客户端缓存、代理缓存、服务器缓存等等，<code>Nginx</code>的缓存则属于代理缓存的一种。对于整个系统而言，加入缓存带来的优势额外明显：</p><ul><li>• 减少了再次向后端或文件服务器请求资源的带宽消耗。</li><li>• 降低了下游服务器的访问压力，提升系统整体吞吐。</li><li>• 缩短了响应时间，提升了加载速度，打开页面的速度更快。</li></ul><p>那么在<code>Nginx</code>中，又该如何配置代理缓存呢？先来看看缓存相关的配置项：</p><ul><li>• <code>proxy_cache_path</code>：代理缓存的路径。<ul><li>• <code>path</code>：缓存的路径地址。</li><li>• <code>levels</code>：缓存存储的层次结构，最多允许三层目录。</li><li>• <code>use_temp_path</code>：是否使用临时目录。</li><li>• <code>keys_zone</code>：指定一个共享内存空间来存储热点<code>Key</code>(<code>1M</code>可存储<code>8000</code>个<code>Key</code>)。</li><li>• <code>inactive</code>：设置缓存多长时间未被访问后删除（默认是十分钟）。</li><li>• <code>max_size</code>：允许缓存的最大存储空间，超出后会基于<code>LRU</code>算法移除缓存，<code>Nginx</code>会创建一个<code>Cache manager</code>的进程移除数据，也可以通过<code>purge</code>方式。</li><li>• <code>manager_files</code>：<code>manager</code>进程每次移除缓存文件数量的上限。</li><li>• <code>manager_sleep</code>：<code>manager</code>进程每次移除缓存文件的时间上限。</li><li>• <code>manager_threshold</code>：<code>manager</code>进程每次移除缓存后的间隔时间。</li><li>• <code>loader_files</code>：重启<code>Nginx</code>载入缓存时，每次加载的个数，默认<code>100</code>。</li><li>• <code>loader_sleep</code>：每次载入时，允许的最大时间上限，默认<code>200ms</code>。</li><li>• <code>loader_threshold</code>：一次载入后，停顿的时间间隔，默认<code>50ms</code>。</li><li>• <code>purger</code>：是否开启<code>purge</code>方式移除数据。</li><li>• <code>purger_files</code>：每次移除缓存文件时的数量。</li><li>• <code>purger_sleep</code>：每次移除时，允许消耗的最大时间。</li><li>• <code>purger_threshold</code>：每次移除完成后，停顿的间隔时间。</li><li>• 语法：<code>proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];</code></li><li>• 是的，你没有看错，就是这么长….，解释一下每个参数项的含义：</li></ul></li><li>• <code>proxy_cache</code>：开启或关闭代理缓存，开启时需要指定一个共享内存区域。<ul><li>• <code>zone</code>为内存区域的名称，即上面中<code>keys_zone</code>设置的名称。</li><li>• 语法：<code>proxy_cache zone | off;</code></li></ul></li><li>• <code>proxy_cache_key</code>：定义如何生成缓存的键。<ul><li>• <code>string</code>为生成<code>Key</code>的规则，如<code>$scheme$proxy_host$request_uri</code>。</li><li>• 语法：<code>proxy_cache_key string;</code></li></ul></li><li>• <code>proxy_cache_valid</code>：缓存生效的状态码与过期时间。<ul><li>• <code>code</code>为状态码，<code>time</code>为有效时间，可以根据状态码设置不同的缓存时间。</li><li>• 例如：<code>proxy_cache_valid 200 302 30m;</code></li><li>• 语法：<code>proxy_cache_valid [code ...] time;</code></li></ul></li><li>• <code>proxy_cache_min_uses</code>：设置资源被请求多少次后被缓存。<ul><li>• <code>number</code>为次数，默认为<code>1</code>。</li><li>• 语法：<code>proxy_cache_min_uses number;</code></li></ul></li><li>• <code>proxy_cache_use_stale</code>：当后端出现异常时，是否允许<code>Nginx</code>返回缓存作为响应。<ul><li>• <code>error</code>为错误类型，可配置<code>timeout|invalid_header|updating|http_500...</code>。</li><li>• 语法：<code>proxy_cache_use_stale error;</code></li></ul></li><li>• <code>proxy_cache_lock</code>：对于相同的请求，是否开启锁机制，只允许一个请求发往后端。<ul><li>• 语法：<code>proxy_cache_lock on | off;</code></li></ul></li><li>• <code>proxy_cache_lock_timeout</code>：配置锁超时机制，超出规定时间后会释放请求。<ul><li>• <code>proxy_cache_lock_timeout time;</code></li></ul></li><li>• <code>proxy_cache_methods</code>：设置对于那些<code>HTTP</code>方法开启缓存。<ul><li>• <code>method</code>为请求方法类型，如<code>GET、HEAD</code>等。</li><li>• 语法：<code>proxy_cache_methods method;</code></li></ul></li><li>• <code>proxy_no_cache</code>：定义不存储缓存的条件，符合时不会保存。<ul><li>• <code>string</code>为条件，例如<code>$cookie_nocache $arg_nocache $arg_comment;</code></li><li>• 语法：<code>proxy_no_cache string...;</code></li></ul></li><li>• <code>proxy_cache_bypass</code>：定义不读取缓存的条件，符合时不会从缓存中读取。<ul><li>• 和上面<code>proxy_no_cache</code>的配置方法类似。</li><li>• 语法：<code>proxy_cache_bypass string...;</code></li></ul></li><li>• <code>add_header</code>：往响应头中添加字段信息。<ul><li>• 语法：<code>add_header fieldName fieldValue</code>;</li></ul></li><li>• <code>$upstream_cache_status</code>：记录了缓存是否命中的信息，存在多种情况：<ul><li>• <code>MISS</code>：请求未命中缓存。</li><li>• <code>HIT</code>：请求命中缓存。</li><li>• <code>EXPIRED</code>：请求命中缓存但缓存已过期。</li><li>• <code>STALE</code>：请求命中了陈旧缓存。</li><li>• <code>REVALIDDATED</code>：<code>Nginx</code>验证陈旧缓存依然有效。</li><li>• <code>UPDATING</code>：命中的缓存内容陈旧，但正在更新缓存。</li><li>• <code>BYPASS</code>：响应结果是从原始服务器获取的。</li><li>• PS：这个和之前的不同，之前的都是参数项，这个是一个<code>Nginx</code>内置变量。</li></ul></li></ul><p>OK~，对于<code>Nginx</code>中的缓存配置项大概了解后，接着来配置一下<code>Nginx</code>代理缓存：</p><pre><code>http{    # 设置缓存的目录，并且内存中缓存区名为hot_cache，大小为128m，    # 三天未被访问过的缓存自动清楚，磁盘中缓存的最大容量为2GB。    proxy_cache_path /soft/nginx/cache levels=1:2 keys_zone=hot_cache:128m inactive=3d max_size=2g;    server{        location / {            # 使用名为nginx_cache的缓存空间            proxy_cache hot_cache;            # 对于200、206、304、301、302状态码的数据缓存1天            proxy_cache_valid 200 206 304 301 302 1d;            # 对于其他状态的数据缓存30分钟            proxy_cache_valid any 30m;            # 定义生成缓存键的规则（请求的url+参数作为key）            proxy_cache_key $host$uri$is_args$args;            # 资源至少被重复访问三次后再加入缓存            proxy_cache_min_uses 3;            # 出现重复请求时，只让一个去后端读数据，其他的从缓存中读取            proxy_cache_lock on;            # 上面的锁超时时间为3s，超过3s未获取数据，其他请求直接去后端            proxy_cache_lock_timeout 3s;            # 对于请求参数或cookie中声明了不缓存的数据，不再加入缓存            proxy_no_cache $cookie_nocache $arg_nocache $arg_comment;            # 在响应头中添加一个缓存是否命中的状态（便于调试）            add_header Cache-status $upstream_cache_status;        }    }}</code></pre><p>接着来看一下效果，如下：</p><p><img src="https://img.iamghf.top/md/202404282112313.png" alt="代理缓存"></p><p>第一次访问时，因为还没有请求过资源，所以缓存中没有数据，因此没有命中缓存。第二、三次，依旧没有命中缓存，直至第四次时才显示命中，这是为什么呢？因为在前面的缓存配置中，我们配置了加入缓存的最低条件为：<strong>资源至少要被请求三次以上才会加入缓存。</strong> 这样可以避免很多无效缓存占用空间。</p><h3 id="缓存清理"><a href="#缓存清理" class="headerlink" title="缓存清理"></a>缓存清理</h3><p>  当缓存过多时，如果不及时清理会导致磁盘空间被“吃光”，因此我们需要一套完善的缓存清理机制去删除缓存，在之前的<code>proxy_cache_path</code>参数中有<code>purger</code>相关的选项，开启后可以帮我们自动清理缓存，但遗憾的是：<strong><code>purger</code>系列参数只有商业版的<code>NginxPlus</code>才能使用，因此需要付费才可使用。</strong></p><p>不过天无绝人之路，我们可以通过强大的第三方模块<code>ngx_cache_purge</code>来替代，先来安装一下该插件：<br>①首先去到<code>Nginx</code>的安装目录下，创建一个<code>cache_purge</code>目录：</p><pre><code>[root@localhost]# mkdir cache_purge &amp;&amp; cd cache_purge</code></pre><p>②通过<code>wget</code>指令从<code>github</code>上拉取安装包的压缩文件并解压：</p><pre><code>[root@localhost]# wget https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz[root@localhost]# tar -xvzf 2.3.tar.gz</code></pre><p>③再次去到之前<code>Nginx</code>的解压目录下：</p><pre><code>[root@localhost]# cd /soft/nginx/nginx1.21.6</code></pre><p>④重新构建一次<code>Nginx</code>，通过<code>--add-module</code>的指令添加刚刚的第三方模块：</p><pre><code>[root@localhost]# ./configure --prefix=/soft/nginx/ --add-module=/soft/nginx/cache_purge/ngx_cache_purge-2.3/</code></pre><p>⑤重新根据刚刚构建的<code>Nginx</code>，再次编译一下，<strong>但切记不要<code>make install</code></strong>：</p><pre><code>[root@localhost]# make</code></pre><p>⑥删除之前<code>Nginx</code>的启动文件，不放心的也可以移动到其他位置：</p><pre><code>[root@localhost]# rm -rf /soft/nginx/sbin/nginx</code></pre><p>⑦从生成的<code>objs</code>目录中，重新复制一个<code>Nginx</code>的启动文件到原来的位置：</p><pre><code>[root@localhost]# cp objs/nginx /soft/nginx/sbin/nginx</code></pre><p>至此，第三方缓存清除模块<code>ngx_cache_purge</code>就安装完成了，接下来稍微修改一下<code>nginx.conf</code>配置，再添加一条<code>location</code>规则：</p><pre><code>location ~ /purge(/.*) {  # 配置可以执行清除操作的IP（线上可以配置成内网机器）  # allow 127.0.0.1; # 代表本机  allow all; # 代表允许任意IP清除缓存  proxy_cache_purge $host$1$is_args$args;}</code></pre><p>然后再重启<code>Nginx</code>，接下来即可通过<code>http://xxx/purge/xx</code>的方式清除缓存。</p><h2 id="八、Nginx实现IP黑白名单"><a href="#八、Nginx实现IP黑白名单" class="headerlink" title="八、Nginx实现IP黑白名单"></a>八、Nginx实现IP黑白名单</h2><p>  有时候往往有些需求，可能某些接口只能开放给对应的合作商，或者购买/接入<code>API</code>的合作伙伴，那么此时就需要实现类似于<code>IP</code>白名单的功能。而有时候有些恶意攻击者或爬虫程序，被识别后需要禁止其再次访问网站，因此也需要实现<code>IP</code>黑名单。那么这些功能无需交由后端实现，可直接在<code>Nginx</code>中处理。</p><p><code>Nginx</code>做黑白名单机制，主要是通过<code>allow、deny</code>配置项来实现：</p><pre><code>allow xxx.xxx.xxx.xxx; # 允许指定的IP访问，可以用于实现白名单。deny xxx.xxx.xxx.xxx; # 禁止指定的IP访问，可以用于实现黑名单。</code></pre><p>要同时屏蔽/开放多个<code>IP</code>访问时，如果所有<code>IP</code>全部写在<code>nginx.conf</code>文件中定然是不显示的，这种方式比较冗余，那么可以新建两个文件<code>BlocksIP.conf、WhiteIP.conf</code>：</p><pre><code># --------黑名单：BlocksIP.conf---------deny 192.177.12.222; # 屏蔽192.177.12.222访问deny 192.177.44.201; # 屏蔽192.177.44.201访问deny 127.0.0.0/8; # 屏蔽127.0.0.1到127.255.255.254网段中的所有IP访问# --------白名单：WhiteIP.conf---------allow 192.177.12.222; # 允许192.177.12.222访问allow 192.177.44.201; # 允许192.177.44.201访问allow 127.45.0.0/16; # 允许127.45.0.1到127.45.255.254网段中的所有IP访问deny all; # 除开上述IP外，其他IP全部禁止访问</code></pre><p>分别将要禁止/开放的<code>IP</code>添加到对应的文件后，可以再将这两个文件在<code>nginx.conf</code>中导入：</p><pre><code>http{    # 屏蔽该文件中的所有IP    include /soft/nginx/IP/BlocksIP.conf;  server{    location xxx {        # 某一系列接口只开放给白名单中的IP        include /soft/nginx/IP/blockip.conf;     } }}</code></pre><p>对于文件具体在哪儿导入，这个也并非随意的，如果要整站屏蔽/开放就在<code>http</code>中导入，如果只需要一个域名下屏蔽/开放就在<code>sever</code>中导入，如果只需要针对于某一系列接口屏蔽/开放<code>IP</code>，那么就在<code>location</code>中导入。</p><blockquote><p>当然，上述只是最简单的<code>IP</code>黑/白名单实现方式，同时也可以通过<code>ngx_http_geo_module、ngx_http_geo_module</code>第三方库去实现（这种方式可以按地区、国家进行屏蔽，并且提供了<code>IP</code>库）。</p></blockquote><h2 id="九、Nginx跨域配置"><a href="#九、Nginx跨域配置" class="headerlink" title="九、Nginx跨域配置"></a>九、Nginx跨域配置</h2><p>  跨域问题在之前的单体架构开发中，其实是比较少见的问题，除非是需要接入第三方<code>SDK</code>时，才需要处理此问题。但随着现在前后端分离、分布式架构的流行，跨域问题也成为了每个Java开发必须要懂得解决的一个问题。</p><h3 id="跨域问题产生的原因"><a href="#跨域问题产生的原因" class="headerlink" title="跨域问题产生的原因"></a>跨域问题产生的原因</h3><p>  产生跨域问题的主要原因就在于<strong>同源策略</strong>，为了保证用户信息安全，防止恶意网站窃取数据，同源策略是必须的，否则<code>cookie</code>可以共享。由于<code>http</code>无状态协议通常会借助<code>cookie</code>来实现有状态的信息记录，例如用户的身份/密码等，因此一旦<code>cookie</code>被共享，那么会导致用户的身份信息被盗取。<br>  同源策略主要是指三点相同，<strong>协议+域名+端口</strong> 相同的两个请求，则可以被看做是同源的，但如果其中任意一点存在不同，则代表是两个不同源的请求，同源策略会限制了不同源之间的资源交互。</p><h3 id="Nginx解决跨域问题"><a href="#Nginx解决跨域问题" class="headerlink" title="Nginx解决跨域问题"></a>Nginx解决跨域问题</h3><p>  弄明白了跨域问题的产生原因，接下来看看<code>Nginx</code>中又该如何解决跨域呢？其实比较简单，在<code>nginx.conf</code>中稍微添加一点配置即可：</p><pre><code>location / {    # 允许跨域的请求，可以自定义变量$http_origin，*表示所有    add_header &#39;Access-Control-Allow-Origin&#39; *;    # 允许携带cookie请求    add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;    # 允许跨域请求的方法：GET,POST,OPTIONS,PUT    add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET,POST,OPTIONS,PUT&#39;;    # 允许请求时携带的头部信息，*表示所有    add_header &#39;Access-Control-Allow-Headers&#39; *;    # 允许发送按段获取资源的请求    add_header &#39;Access-Control-Expose-Headers&#39; &#39;Content-Length,Content-Range&#39;;    # 一定要有！！！否则Post请求无法进行跨域！    # 在发送Post跨域请求前，会以Options方式发送预检请求，服务器接受时才会正式请求    if ($request_method = &#39;OPTIONS&#39;) {        add_header &#39;Access-Control-Max-Age&#39; 1728000;        add_header &#39;Content-Type&#39; &#39;text/plain; charset=utf-8&#39;;        add_header &#39;Content-Length&#39; 0;        # 对于Options方式的请求返回204，表示接受跨域请求        return 204;    }}</code></pre><p>在<code>nginx.conf</code>文件加上如上配置后，跨域请求即可生效了。</p><blockquote><p>但如果后端是采用分布式架构开发的，有时候RPC调用也需要解决跨域问题，不然也同样会出现无法跨域请求的异常，因此可以在你的后端项目中，通过继承<code>HandlerInterceptorAdapter</code>类、实现<code>WebMvcConfigurer</code>接口、添加<code>@CrossOrgin</code>注解的方式实现接口之间的跨域配置。</p></blockquote><h2 id="十、Nginx防盗链设计"><a href="#十、Nginx防盗链设计" class="headerlink" title="十、Nginx防盗链设计"></a>十、Nginx防盗链设计</h2><p>  首先了解一下何谓盗链：<strong>盗链即是指外部网站引入当前网站的资源对外展示</strong>，来举个简单的例子理解：</p><blockquote><p>好比壁纸网站<code>X</code>站、<code>Y</code>站，<code>X</code>站是一点点去购买版权、签约作者的方式，从而积累了海量的壁纸素材，但<code>Y</code>站由于资金等各方面的原因，就直接通过<code>&lt;img src=&quot;X站/xxx.jpg&quot; /&gt;</code>这种方式照搬了<code>X</code>站的所有壁纸资源，继而提供给用户下载。</p></blockquote><p>那么如果我们自己是这个<code>X</code>站的<code>Boss</code>，心中必然不爽，那么此时又该如何屏蔽这类问题呢？那么接下来要叙说的<strong>防盗链</strong> 登场了！</p><p><code>Nginx</code>的防盗链机制实现，跟上篇文章《HTTP/HTTPS》中分析到的一个头部字段：<code>Referer</code>有关，该字段主要描述了当前请求是从哪儿发出的，那么在<code>Nginx</code>中就可获取该值，然后判断是否为本站的资源引用请求，如果不是则不允许访问。<code>Nginx</code>中存在一个配置项为<code>valid_referers</code>，正好可以满足前面的需求，语法如下：</p><ul><li>• <code>valid_referers none | blocked | server_names | string ...;</code><ul><li>• <code>none</code>：表示接受没有<code>Referer</code>字段的<code>HTTP</code>请求访问。</li><li>• <code>blocked</code>：表示允许<code>http://</code>或<code>https//</code>以外的请求访问。</li><li>• <code>server_names</code>：资源的白名单，这里可以指定允许访问的域名。</li><li>• <code>string</code>：可自定义字符串，支配通配符、正则表达式写法。</li></ul></li></ul><p>简单了解语法后，接下来的实现如下：</p><pre><code># 在动静分离的location中开启防盗链机制location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css){    # 最后面的值在上线前可配置为允许的域名地址    valid_referers blocked 192.168.12.129;    if ($invalid_referer) {        # 可以配置成返回一张禁止盗取的图片        # rewrite   ^/ http://xx.xx.com/NO.jpg;        # 也可直接返回403        return   403;    }    root   /soft/nginx/static_resources;    expires 7d;}</code></pre><p>根据上述中的内容配置后，就已经通过<code>Nginx</code>实现了最基本的防盗链机制，最后只需要额外重启一下就好啦！当然，对于防盗链机制实现这块，也有专门的第三方模块<code>ngx_http_accesskey_module</code>实现了更为完善的设计，感兴趣的小伙伴可以自行去看看。</p><blockquote><p>PS：防盗链机制也无法解决爬虫伪造<code>referers</code>信息的这种方式抓取数据。</p></blockquote><h2 id="十一、Nginx大文件传输配置"><a href="#十一、Nginx大文件传输配置" class="headerlink" title="十一、Nginx大文件传输配置"></a>十一、Nginx大文件传输配置</h2><p>  在某些业务场景中需要传输一些大文件，但大文件传输时往往都会会出现一些<code>Bug</code>，比如文件超出限制、文件传输过程中请求超时等，那么此时就可以在<code>Nginx</code>稍微做一些配置，先来了解一些关于大文件传输时可能会用的配置项：</p><table><thead><tr><th>配置项</th><th>释义</th></tr></thead><tbody><tr><td><code>client_max_body_size</code></td><td>设置请求体允许的最大体积</td></tr><tr><td><code>client_header_timeout</code></td><td>等待客户端发送一个请求头的超时时间</td></tr><tr><td><code>client_body_timeout</code></td><td>设置读取请求体的超时时间</td></tr><tr><td><code>proxy_read_timeout</code></td><td>设置请求被后端服务器读取时，<code>Nginx</code>等待的最长时间</td></tr><tr><td><code>proxy_send_timeout</code></td><td>设置后端向<code>Nginx</code>返回响应时的超时时间</td></tr></tbody></table><p>在传输大文件时，<code>client_max_body_size、client_header_timeout、proxy_read_timeout、proxy_send_timeout</code>这四个参数值都可以根据自己项目的实际情况来配置。</p><blockquote><p>上述配置仅是作为代理层需要配置的，因为最终客户端传输文件还是直接与后端进行交互，这里只是把作为网关层的<code>Nginx</code>配置调高一点，调到能够“容纳大文件”传输的程度。<br>当然，<code>Nginx</code>中也可以作为文件服务器使用，但需要用到一个专门的第三方模块<code>nginx-upload-module</code>，如果项目中文件上传的作用处不多，那么建议可以通过<code>Nginx</code>搭建，毕竟可以节省一台文件服务器资源。但如若文件上传/下载较为频繁，那么还是建议额外搭建文件服务器，并将上传/下载功能交由后端处理。</p></blockquote><h2 id="十二、Nginx配置SSL证书"><a href="#十二、Nginx配置SSL证书" class="headerlink" title="十二、Nginx配置SSL证书"></a>十二、Nginx配置SSL证书</h2><p>  随着越来越多的网站接入<code>HTTPS</code>，因此<code>Nginx</code>中仅配置<code>HTTP</code>还不够，往往还需要监听<code>443</code>端口的请求，但在上篇《HTTP/HTTPS》中谈到过，<code>HTTPS</code>为了确保通信安全，所以服务端需配置对应的数字证书，当项目使用<code>Nginx</code>作为网关时，那么证书在<code>Nginx</code>中也需要配置，接下来简单聊一下关于<code>SSL</code>证书配置过程：</p><ul><li>• ①先去CA机构或从云控制台中申请对应的<code>SSL</code>证书，审核通过后下载<code>Nginx</code>版本的证书。</li><li>• ②下载数字证书后，完整的文件总共有三个：<code>.crt、.key、.pem</code>：<ul><li>• <code>.crt</code>：数字证书文件，<code>.crt</code>是<code>.pem</code>的拓展文件，因此有些人下载后可能没有。</li><li>• <code>.key</code>：服务器的私钥文件，及非对称加密的私钥，用于解密公钥传输的数据。</li><li>• <code>.pem</code>：<code>Base64-encoded</code>编码格式的源证书文本文件，可自行根需求修改拓展名。</li></ul></li><li>• ③在<code>Nginx</code>目录下新建<code>certificate</code>目录，并将下载好的证书/私钥等文件上传至该目录。</li><li>• ④最后修改一下<code>nginx.conf</code>文件即可，如下：</li></ul><pre><code># ----------HTTPS配置-----------server {    # 监听HTTPS默认的443端口    listen 443;    # 配置自己项目的域名    server_name www.xxx.com;    # 打开SSL加密传输    ssl on;    # 输入域名后，首页文件所在的目录    root html;    # 配置首页的文件名    index index.html index.htm index.jsp index.ftl;    # 配置自己下载的数字证书    ssl_certificate  certificate/xxx.pem;    # 配置自己下载的服务器私钥    ssl_certificate_key certificate/xxx.key;    # 停止通信时，加密会话的有效期，在该时间段内不需要重新交换密钥    ssl_session_timeout 5m;    # TLS握手时，服务器采用的密码套件    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    # 服务器支持的TLS版本    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    # 开启由服务器决定采用的密码套件    ssl_prefer_server_ciphers on;    location / {        ....    }}# ---------HTTP请求转HTTPS-------------server {    # 监听HTTP默认的80端口    listen 80;    # 如果80端口出现访问该域名的请求    server_name www.xxx.com;    # 将请求改写为HTTPS（这里写你配置了HTTPS的域名）    rewrite ^(.*)$ https://www.xxx.com;}</code></pre><p>OK~，根据如上配置了<code>Nginx</code>后，你的网站即可通过<code>https://</code>的方式访问，并且当客户端使用<code>http://</code>的方式访问时，会自动将其改写为<code>HTTPS</code>请求。</p><h2 id="十三、Nginx的高可用"><a href="#十三、Nginx的高可用" class="headerlink" title="十三、Nginx的高可用"></a>十三、Nginx的高可用</h2><p>  线上如果采用单个节点的方式部署<code>Nginx</code>，难免会出现天灾人祸，比如系统异常、程序宕机、服务器断电、机房爆炸、地球毁灭….哈哈哈，夸张了。但实际生产环境中确实存在隐患问题，由于<code>Nginx</code>作为整个系统的网关层接入外部流量，所以一旦<code>Nginx</code>宕机，最终就会导致整个系统不可用，这无疑对于用户的体验感是极差的，因此也得保障<code>Nginx</code>高可用的特性。</p><blockquote><p>接下来则会通过<code>keepalived</code>的<code>VIP</code>机制，实现<code>Nginx</code>的高可用。<br><code>VIP</code>并不是只会员的意思，而是指<code>Virtual IP</code>，即虚拟<code>IP</code>。</p></blockquote><p><code>keepalived</code>在之前单体架构开发时，是一个用的较为频繁的高可用技术，比如<code>MySQL、Redis、MQ、Proxy、Tomcat</code>等各处都会通过<code>keepalived</code>提供的<code>VIP</code>机制，实现单节点应用的高可用。</p><h3 id="Keepalived-重启脚本-双机热备搭建"><a href="#Keepalived-重启脚本-双机热备搭建" class="headerlink" title="Keepalived+重启脚本+双机热备搭建"></a>Keepalived+重启脚本+双机热备搭建</h3><p>①首先创建一个对应的目录并下载<code>keepalived</code>安装包（提取码:s6aq）到<code>Linux</code>中并解压：</p><pre><code>[root@localhost]# mkdir /soft/keepalived &amp;&amp; cd /soft/keepalived[root@localhost]# wget https://www.keepalived.org/software/keepalived-2.2.4.tar.gz[root@localhost]# tar -zxvf keepalived-2.2.4.tar.gz</code></pre><p>②进入解压后的<code>keepalived</code>目录并构建安装环境，然后编译并安装：</p><pre><code>[root@localhost]# cd keepalived-2.2.4[root@localhost]# ./configure --prefix=/soft/keepalived/[root@localhost]# make &amp;&amp; make install</code></pre><p>③进入安装目录的<code>/soft/keepalived/etc/keepalived/</code>并编辑配置文件：</p><pre><code>[root@localhost]# cd /soft/keepalived/etc/keepalived/[root@localhost]# vi keepalived.conf</code></pre><p>④编辑主机的<code>keepalived.conf</code>核心配置文件，如下：</p><pre><code>global_defs {    # 自带的邮件提醒服务，建议用独立的监控或第三方SMTP，也可选择配置邮件发送。    notification_email {        root@localhost    }    notification_email_from root@localhost    smtp_server localhost    smtp_connect_timeout 30    # 高可用集群主机身份标识(集群中主机身份标识名称不能重复，建议配置成本机IP)    router_id 192.168.12.129 }# 定时运行的脚本文件配置vrrp_script check_nginx_pid_restart {    # 之前编写的nginx重启脚本的所在位置    script &quot;/soft/scripts/keepalived/check_nginx_pid_restart.sh&quot;     # 每间隔3秒执行一次    interval 3    # 如果脚本中的条件成立，重启一次则权重-20    weight -20}# 定义虚拟路由，VI_1为虚拟路由的标示符（可自定义名称）vrrp_instance VI_1 {    # 当前节点的身份标识：用来决定主从（MASTER为主机，BACKUP为从机）    state MASTER    # 绑定虚拟IP的网络接口，根据自己的机器的网卡配置    interface ens33     # 虚拟路由的ID号，主从两个节点设置必须一样    virtual_router_id 121    # 填写本机IP    mcast_src_ip 192.168.12.129    # 节点权重优先级，主节点要比从节点优先级高    priority 100    # 优先级高的设置nopreempt，解决异常恢复后再次抢占造成的脑裂问题    nopreempt    # 组播信息发送间隔，两个节点设置必须一样，默认1s（类似于心跳检测）    advert_int 1    authentication {        auth_type PASS        auth_pass 1111    }    # 将track_script块加入instance配置块    track_script {        # 执行Nginx监控的脚本        check_nginx_pid_restart    }    virtual_ipaddress {        # 虚拟IP(VIP)，也可扩展，可配置多个。        192.168.12.111    }}</code></pre><p>⑤克隆一台之前的虚拟机作为从（备）机，编辑从机的<code>keepalived.conf</code>文件，如下：</p><pre><code>global_defs {    # 自带的邮件提醒服务，建议用独立的监控或第三方SMTP，也可选择配置邮件发送。    notification_email {        root@localhost    }    notification_email_from root@localhost    smtp_server localhost    smtp_connect_timeout 30    # 高可用集群主机身份标识(集群中主机身份标识名称不能重复，建议配置成本机IP)    router_id 192.168.12.130 }# 定时运行的脚本文件配置vrrp_script check_nginx_pid_restart {    # 之前编写的nginx重启脚本的所在位置    script &quot;/soft/scripts/keepalived/check_nginx_pid_restart.sh&quot;     # 每间隔3秒执行一次    interval 3    # 如果脚本中的条件成立，重启一次则权重-20    weight -20}# 定义虚拟路由，VI_1为虚拟路由的标示符（可自定义名称）vrrp_instance VI_1 {    # 当前节点的身份标识：用来决定主从（MASTER为主机，BACKUP为从机）    state BACKUP    # 绑定虚拟IP的网络接口，根据自己的机器的网卡配置    interface ens33     # 虚拟路由的ID号，主从两个节点设置必须一样    virtual_router_id 121    # 填写本机IP    mcast_src_ip 192.168.12.130    # 节点权重优先级，主节点要比从节点优先级高    priority 90    # 优先级高的设置nopreempt，解决异常恢复后再次抢占造成的脑裂问题    nopreempt    # 组播信息发送间隔，两个节点设置必须一样，默认1s（类似于心跳检测）    advert_int 1    authentication {        auth_type PASS        auth_pass 1111    }    # 将track_script块加入instance配置块    track_script {        # 执行Nginx监控的脚本        check_nginx_pid_restart    }    virtual_ipaddress {        # 虚拟IP(VIP)，也可扩展，可配置多个。        192.168.12.111    }}</code></pre><p>⑥新建<code>scripts</code>目录并编写<code>Nginx</code>的重启脚本，<code>check_nginx_pid_restart.sh</code>：</p><pre><code>[root@localhost]# mkdir /soft/scripts /soft/scripts/keepalived[root@localhost]# touch /soft/scripts/keepalived/check_nginx_pid_restart.sh[root@localhost]# vi /soft/scripts/keepalived/check_nginx_pid_restart.sh#!/bin/sh# 通过ps指令查询后台的nginx进程数，并将其保存在变量nginx_number中nginx_number=`ps -C nginx --no-header | wc -l`# 判断后台是否还有Nginx进程在运行if [ $nginx_number -eq 0 ];then    # 如果后台查询不到`Nginx`进程存在，则执行重启指令    /soft/nginx/sbin/nginx -c /soft/nginx/conf/nginx.conf    # 重启后等待1s后，再次查询后台进程数    sleep 1    # 如果重启后依旧无法查询到nginx进程    if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then        # 将keepalived主机下线，将虚拟IP漂移给从机，从机上线接管Nginx服务        systemctl stop keepalived.service    fifi</code></pre><p>⑦编写的脚本文件需要更改编码格式，并赋予执行权限，否则可能执行失败：</p><pre><code>[root@localhost]# vi /soft/scripts/keepalived/check_nginx_pid_restart.sh:set fileformat=unix # 在vi命令里面执行，修改编码格式:set ff # 查看修改后的编码格式[root@localhost]# chmod +x /soft/scripts/keepalived/check_nginx_pid_restart.sh</code></pre><p>⑧由于安装<code>keepalived</code>时，是自定义的安装位置，因此需要拷贝一些文件到系统目录中：</p><pre><code>[root@localhost]# mkdir /etc/keepalived/[root@localhost]# cp /soft/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/[root@localhost]# cp /soft/keepalived/keepalived-2.2.4/keepalived/etc/init.d/keepalived /etc/init.d/[root@localhost]# cp /soft/keepalived/etc/sysconfig/keepalived /etc/sysconfig/</code></pre><p>⑨将<code>keepalived</code>加入系统服务并设置开启自启动，然后测试启动是否正常：</p><pre><code>[root@localhost]# chkconfig keepalived on[root@localhost]# systemctl daemon-reload[root@localhost]# systemctl enable keepalived.service[root@localhost]# systemctl start keepalived.service其他命令：systemctl disable keepalived.service # 禁止开机自动启动systemctl restart keepalived.service # 重启keepalivedsystemctl stop keepalived.service # 停止keepalivedtail -f /var/log/messages # 查看keepalived运行时日志</code></pre><p>⑩最后测试一下<code>VIP</code>是否生效，通过查看本机是否成功挂载虚拟<code>IP</code>：</p><pre><code>[root@localhost]# ip addr</code></pre><p><img src="https://img.iamghf.top/md/202404282113602.png" alt="虚拟IP-VIP"></p><blockquote><p>从上图中可以明显看见虚拟<code>IP</code>已经成功挂载，但另外一台机器<code>192.168.12.130</code>并不会挂载这个虚拟<code>IP</code>，只有当主机下线后，作为从机的<code>192.168.12.130</code>才会上线，接替<code>VIP</code>。最后测试一下外网是否可以正常与<code>VIP</code>通信，即在<code>Windows</code>中直接<code>ping VIP</code>：</p></blockquote><p><img src="https://img.iamghf.top/md/202404282115013.png" alt="Ping-VIP"></p><p>外部通过<code>VIP</code>通信时，也可以正常<code>Ping</code>通，代表虚拟<code>IP</code>配置成功。</p><h3 id="Nginx高可用性测试"><a href="#Nginx高可用性测试" class="headerlink" title="Nginx高可用性测试"></a>Nginx高可用性测试</h3><p>  经过上述步骤后，<code>keepalived</code>的<code>VIP</code>机制已经搭建成功，在上个阶段中主要做了几件事：</p><ul><li>• 一、为部署<code>Nginx</code>的机器挂载了<code>VIP</code>。</li><li>• 二、通过<code>keepalived</code>搭建了主从双机热备。</li><li>• 三、通过<code>keepalived</code>实现了<code>Nginx</code>宕机重启。</li></ul><p>由于前面没有域名的原因，因此最初<code>server_name</code>配置的是当前机器的<code>IP</code>，所以需稍微更改一下<code>nginx.conf</code>的配置：</p><pre><code>sever{    listen    80;    # 这里从机器的本地IP改为虚拟IP    server_name 192.168.12.111;    # 如果这里配置的是域名，那么则将域名的映射配置改为虚拟IP}</code></pre><p>最后来实验一下效果：</p><p><img src="https://img.iamghf.top/md/202404282115998.png" alt="Nginx宕机"></p><blockquote><p>在上述过程中，首先分别启动了<code>keepalived、nginx</code>服务，然后通过手动停止<code>nginx</code>的方式模拟了<code>Nginx</code>宕机情况，过了片刻后再次查询后台进程，我们会发现<code>nginx</code>依旧存活。</p></blockquote><p>从这个过程中不难发现，<code>keepalived</code>已经为我们实现了<code>Nginx</code>宕机后自动重启的功能，那么接着再模拟一下服务器出现故障时的情况：</p><p><img src="https://img.iamghf.top/md/202404282116641.png" alt="服务器故障"></p><blockquote><p>在上述过程中，我们通过手动关闭<code>keepalived</code>服务模拟了机器断电、硬件损坏等情况（因为机器断电等情况=主机中的<code>keepalived</code>进程消失），然后再次查询了一下本机的<code>IP</code>信息，很明显会看到<code>VIP</code>消失了！</p></blockquote><p>现在再切换到另外一台机器：<code>192.168.12.130</code>来看看情况：</p><p><img src="https://img.iamghf.top/md/202404282117072.png" alt="130的IP情况"></p><blockquote><p>此刻我们会发现，在主机<code>192.168.12.129</code>宕机后，VIP自动从主机飘移到了从机<code>192.168.12.130</code>上，而此时客户端的请求就最终会来到<code>130</code>这台机器的<code>Nginx</code>上。</p></blockquote><p><strong>最终，利用<code>Keepalived</code>对<code>Nginx</code>做了主从热备之后，无论是遇到线上宕机还是机房断电等各类故障时，都能够确保应用系统能够为用户提供<code>7x24</code>小时服务。</strong></p><h2 id="十四、Nginx性能优化"><a href="#十四、Nginx性能优化" class="headerlink" title="十四、Nginx性能优化"></a>十四、Nginx性能优化</h2><p>  到这里文章的篇幅较长了，最后再来聊一下关于<code>Nginx</code>的性能优化，主要就简单说说收益最高的几个优化项，在这块就不再展开叙述了，毕竟影响性能都有多方面原因导致的，比如网络、服务器硬件、操作系统、后端服务、程序自身、数据库服务等，对于性能调优比较感兴趣的可以参考之前《JVM性能调优》中的调优思想。</p><h3 id="优化一：打开长连接配置"><a href="#优化一：打开长连接配置" class="headerlink" title="优化一：打开长连接配置"></a>优化一：打开长连接配置</h3><p>  通常Nginx作为代理服务，负责分发客户端的请求，那么建议开启<code>HTTP</code>长连接，用户减少握手的次数，降低服务器损耗，具体如下：</p><pre><code>upstream xxx {    # 长连接数    keepalive 32;    # 每个长连接提供的最大请求数    keepalived_requests 100;    # 每个长连接没有新的请求时，保持的最长时间    keepalive_timeout 60s;}</code></pre><h3 id="优化二、开启零拷贝技术"><a href="#优化二、开启零拷贝技术" class="headerlink" title="优化二、开启零拷贝技术"></a>优化二、开启零拷贝技术</h3><p>  零拷贝这个概念，在大多数性能较为不错的中间件中都有出现，例如<code>Kafka、Netty</code>等，而<code>Nginx</code>中也可以配置数据零拷贝技术，如下：</p><pre><code>sendfile on; # 开启零拷贝机制</code></pre><p>零拷贝读取机制与传统资源读取机制的区别：</p><ul><li>• 传统方式：<strong>硬件–&gt;内核–&gt;用户空间–&gt;程序空间–&gt;程序内核空间–&gt;网络套接字</strong></li><li>• 零拷贝方式：<strong>硬件–&gt;内核–&gt;程序内核空间–&gt;网络套接字</strong></li></ul><p>从上述这个过程对比，很轻易就能看出两者之间的性能区别。</p><h3 id="优化三、开启无延迟或多包共发机制"><a href="#优化三、开启无延迟或多包共发机制" class="headerlink" title="优化三、开启无延迟或多包共发机制"></a>优化三、开启无延迟或多包共发机制</h3><p>  在<code>Nginx</code>中有两个较为关键的性能参数，即<code>tcp_nodelay、tcp_nopush</code>，开启方式如下：</p><pre><code>tcp_nodelay on;tcp_nopush on;</code></pre><p><code>TCP/IP</code>协议中默认是采用了Nagle算法的，即在网络数据传输过程中，每个数据报文并不会立马发送出去，而是会等待一段时间，将后面的几个数据包一起组合成一个数据报文发送，但这个算法虽然提高了网络吞吐量，但是实时性却降低了。</p><blockquote><p>因此你的项目属于交互性很强的应用，那么可以手动开启<code>tcp_nodelay</code>配置，让应用程序向内核递交的每个数据包都会立即发送出去。但这样会产生大量的<code>TCP</code>报文头，增加很大的网络开销。</p></blockquote><p>相反，有些项目的业务对数据的实时性要求并不高，追求的则是更高的吞吐，那么则可以开启<code>tcp_nopush</code>配置项，这个配置就类似于“塞子”的意思，首先将连接塞住，使得数据先不发出去，等到拔去塞子后再发出去。设置该选项后，内核会尽量把小数据包拼接成一个大的数据包（一个<code>MTU</code>）再发送出去.</p><blockquote><p>当然若一定时间后（一般为<code>200ms</code>），内核仍然没有积累到一个<code>MTU</code>的量时，也必须发送现有的数据，否则会一直阻塞。</p></blockquote><p><code>tcp_nodelay、tcp_nopush</code>两个参数是“互斥”的，如果追求响应速度的应用推荐开启<code>tcp_nodelay</code>参数，如<code>IM</code>、金融等类型的项目。如果追求吞吐量的应用则建议开启<code>tcp_nopush</code>参数，如调度系统、报表系统等。</p><blockquote><p>注意：<br>①<code>tcp_nodelay</code>一般要建立在开启了长连接模式的情况下使用。<br>②<code>tcp_nopush</code>参数是必须要开启<code>sendfile</code>参数才可使用的。</p></blockquote><h3 id="优化四、调整Worker工作进程"><a href="#优化四、调整Worker工作进程" class="headerlink" title="优化四、调整Worker工作进程"></a>优化四、调整Worker工作进程</h3><p>  <code>Nginx</code>启动后默认只会开启一个<code>Worker</code>工作进程处理客户端请求，而我们可以根据机器的CPU核数开启对应数量的工作进程，以此来提升整体的并发量支持，如下：</p><pre><code># 自动根据CPU核心数调整Worker进程数量worker_processes auto;</code></pre><blockquote><p>工作进程的数量最高开到<code>8</code>个就OK了，<code>8</code>个之后就不会有再大的性能提升。</p></blockquote><p>同时也可以稍微调整一下每个工作进程能够打开的文件句柄数：</p><pre><code># 每个Worker能打开的文件描述符，最少调整至1W以上，负荷较高建议2-3Wworker_rlimit_nofile 20000;</code></pre><blockquote><p>操作系统内核（<code>kernel</code>）都是利用文件描述符来访问文件，无论是打开、新建、读取、写入文件时，都需要使用文件描述符来指定待操作的文件，因此该值越大，代表一个进程能够操作的文件越多（但不能超出内核限制，最多建议<code>3.8W</code>左右为上限）。</p></blockquote><h3 id="优化五、开启CPU亲和机制"><a href="#优化五、开启CPU亲和机制" class="headerlink" title="优化五、开启CPU亲和机制"></a>优化五、开启CPU亲和机制</h3><p>  对于并发编程较为熟悉的伙伴都知道，因为进程/线程数往往都会远超出系统CPU的核心数，因为操作系统执行的原理本质上是采用时间片切换机制，也就是一个CPU核心会在多个进程之间不断频繁切换，造成很大的性能损耗。</p><p>而CPU亲和机制则是指将每个<code>Nginx</code>的工作进程，绑定在固定的CPU核心上，从而减小CPU切换带来的时间开销和资源损耗，开启方式如下：</p><pre><code>worker_cpu_affinity auto;</code></pre><h3 id="优化六、开启epoll模型及调整并发连接数"><a href="#优化六、开启epoll模型及调整并发连接数" class="headerlink" title="优化六、开启epoll模型及调整并发连接数"></a>优化六、开启epoll模型及调整并发连接数</h3><p>  在最开始就提到过：<code>Nginx、Redis</code>都是基于多路复用模型去实现的程序，但最初版的多路复用模型<code>select/poll</code>最大只能监听<code>1024</code>个连接，而<code>epoll</code>则属于<code>select/poll</code>接口的增强版，因此采用该模型能够大程度上提升单个<code>Worker</code>的性能，如下：</p><pre><code>events {    # 使用epoll网络模型    use epoll;    # 调整每个Worker能够处理的连接数上限    worker_connections  10240;}</code></pre><blockquote><p>这里对于<code>select/poll/epoll</code>模型就不展开细说了，后面的IO模型文章中会详细剖析。</p></blockquote><p><a href="https://juejin.cn/post/7112826654291918855" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 动静分离 </tag>
            
            <tag> 跨域 </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解Transformer工作原理</title>
      <link href="/20240425001.html"/>
      <url>/20240425001.html</url>
      
        <content type="html"><![CDATA[<h1 id="图解Transformer工作原理"><a href="#图解Transformer工作原理" class="headerlink" title="图解Transformer工作原理"></a>图解Transformer工作原理</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>Transformer 已经成为了前沿人 AI 技术的代名词，尤其是在<a href="https://cloud.tencent.com/product/nlp?from_column=20065&from=20065" target="_blank" rel="noopener">自然语言处理</a>（NLP）这一领域。</p><p>那么，是什么使得 Transformer 能够如此高效准确地掌握语言的复杂性呢？</p><p>让我们一起深入探索 Transformer 架构的核心原理。</p><p>但在此之前，不妨先看看它的应用场景。无论是你使用的谷歌翻译还是** ChatGPT<strong>，它们背后的强大功能都离不开</strong> Transformer**。</p><p>谷歌翻译：这个被广泛使用的工具在很大程度上依靠 Transformer 技术，实现了对超过 100 种语言的快速准确翻译。它能够考虑到整个句子的上下文，而非仅仅是单个词语，使得翻译结果更加自然流畅。</p><p>Netflix 推荐系统：Netflix 是如何精准推荐你可能喜欢的电影和电视剧的？答案是通过分析你的观看历史和其他用户的数据，Transformer 能够识别出模式和联系，最终向你推荐个性化的内容。</p><p><img src="https://img.iamghf.top/md/202404251105808.jpg" alt="img"></p><p><strong>概览：编解码器交响</strong></p><p>想象一个特殊的工厂，它不是在组装物理产品，而是在加工处理语言。这个工厂主要由两个部分组成：</p><ul><li>编码器（Encoder）：它负责提取信息，通过细致分析输入文本，理解文本中各个元素的含义，并发现它们之间的隐藏联系。</li><li>解码器（Decoder）：依托编码器提供的深入洞察，解码器负责生成所需的输出，无论是将句子翻译成另一种语言、生成一个精确的摘要，还是创作一首全新的诗歌。</li></ul><p><strong>编码器：解码输入迷宫</strong></p><p><img src="https://img.iamghf.top/md/202404251105660.jpg" alt="img"></p><p>编码器的旅程从 “输入嵌入” 开始，此过程中，每个单词都从文本形态转换为数值向量，就好像给每个单词配上了一个独一无二的身份证。</p><p>以这个例子为例：</p><p>输入文本：例如，“The cat sat on the mat.”</p><p>在输入嵌入层，每个单词都被翻译成一个数值向量，就像在一个庞大的字典里，每个单词都有一个对应的 “向量地址”。</p><p>这些向量不仅捕捉了单词的含义，还包括：</p><ul><li>语义关系（比如，“cat” 和 “pet” 更近，而不是和 “chair”）；</li><li>句法角色（比如，“cat” 通常作为名词，“sat” 作为动词）；</li><li>句中上下文（比如，这里的 “mat” 很可能是指地垫）。</li></ul><p>向量表示如下：</p><ul><li>“The” -&gt; [0.2, 0.5, -0.1, …]</li><li>“cat” -&gt; [0.8, -0.3, 0.4, …]</li><li>“sat” -&gt; [-0.1, 0.7, 0.2, …]</li></ul><p>但编码器的工作远不止于此，它还使用了一些关键技术来进一步深入。</p><p>自注意力机制是其中的革命性创新。想象为对每个单词打开一束聚光灯，这束光不仅照亮了该单词，还揭示了它与句中其他单词的联系。这让编码器能够理解文本的全貌 —— 不只是孤立的单词，还有它们之间的联系和细微差别。</p><p><img src="https://img.iamghf.top/md/202404251110303.gif" alt="img"></p><p>再次以句子 “The quick brown fox jumps over the lazy dog.” 为例：</p><p>首先，每个单词都转换成了一个数值表示，称为 “词嵌入”，就像在一个巨大的词库地图上给每个单词定位。</p><p>接下来，自注意力机制为每个单词生成了三个特殊的向量：“查询（Query）”（询问我需要什么信息）、“键（Key）”（标示我有什么信息）和 “值（Value）”（实际的含义和上下文）。</p><p>然后，通过比较每个单词的 “查询” 向量与其他所有单词的 “键” 向量，自注意力层评估了各个单词之间的相关性，并计算出注意力得分。这个得分越高，表示两个单词之间的联系越紧密。</p><p>最后，自注意力层根据注意力得分加权处理 “值” 向量，这就像根据每个单词与当前单词的相关度，取了一个加权平均值。</p><p>通过考虑句中其他单词提供的上下文，自注意力机制为每个单词创建了一个新的、更丰富的表示。这种表示不仅包含了单词本身的含义，还有它如何与句中其他单词关联和受到影响。</p><p>多头注意力机制（Multi-Head Attention）可以被理解为有多个分析小组，每个小组关注于词与词之间联系的不同层面。这使得编码器能够全面捕获词义之间的多元关系，从而深化其对语句的理解。</p><p>还是以句子：“The quick brown fox jumps over the lazy dog.”为例。</p><p>在多头注意力机制中，不同于只使用一个自我关注机制，我们有多个独立的 “头部”（通常是 4 到 8 个）。每个头部都针对每个词分别维护一套查询（Query）、键（Key）和值（Value）向量。</p><p>这种机制下的注意力是多样化的：每个头部根据不同的逻辑计算注意力得分，聚焦于词间关系的不同方面：</p><ul><li>一个头部可能专注分析语法角色，比如 “fox” 和 “jumps” 之间的关系。</li><li>另一个可能关注词序，比如 “the” 和 “quick” 之间的顺序。</li><li>还有的头部可能识别同义词或相关概念，例如将 “quick” 和 “fast” 视为相近的词。</li></ul><p>通过结合这些不同头部的观点，每个头部的输出被汇总，综合不同的洞察力。</p><p>最终，这种综合的表示形式包含了对句子更加丰富的理解，涵盖了词与词之间的多样化关系，而不仅仅是单一视角。</p><p><strong>位置编码（Positional Encoding）是为了补充 Transformer 无法直接处理词序的不足，加入了每个词在句中位置的信息。</strong>可以想象成给每个分析员一张地图，指示他们应该如何按顺序审视词汇。</p><p>继续以句子：“The quick brown fox jumps over the lazy dog.” 为例，来看位置编码是如何工作的：</p><p>首先，每个词（如 “The”，“quick” 等）都被转换成一个唯一的数字向量，这就是所谓的单词嵌入，可以看作是在庞大的词库中为每个词分配的唯一标识。</p><p>接着，每个词的嵌入会和一个基于其在句中位置计算出的额外向量结合。这些位置向量通过正弦和余弦函数生成，能够反映词之间的远近关系。</p><ul><li>低频波动揭示词之间的长距离关系。</li><li>高频波动则关注紧密相连的词。</li></ul><p>这样，每个词的原始向量与其位置向量相加，形成了一个既含有词义也含有位置信息的新向量。</p><p>即便句子的顺序变化，位置向量也能保持词之间的相对位置关系，使得模型能准确理解词与词之间的连接。</p><p><strong>前馈网络（FFN，Feed Forward Network）为模型增添了一层非线性处理，使其能够学习到更为复杂的单词间关系，这些关系可能单凭注意力机制难以捕捉。</strong></p><p>通过前面几层的分析，你已经深入理解了句中单词的含义、它们之间的联系以及它们的位置。现在，FFN 就像是一只侦探用的放大镜，准备揭示那些不立即显现的复杂细节。</p><p>FFN 通过以下三个关键步骤来实现这一目标：</p><ul><li><strong>非线性变换</strong>：FFN 通过使用 ReLU 等非线性函数来增加信息的复杂性，而非直接进行简单计算。可以想象它为现有信息施加了一个特殊的滤镜，揭露了那些简单运算可能忽视的隐藏模式和联系。这使得 FFN 能够把握词与词之间更加细腻的关系。</li><li><strong>多层次分析</strong>：FFN 不是单一步骤，而是通常由两层或更多的全连接层组成。每一层都在前一层的基础上进一步转换信息，就像你在不断放大镜下审视句子，每一层都揭示出更多细节。</li><li><strong>维度变换</strong>：在第一层，FFN 将信息维度扩展（如从 512 维扩到 2048 维），以便分析更多特征并捕捉更复杂的模式。这就像是在更大的画布上展开信息进行深入审查。随后，在最终层将信息维度缩减回原始大小（比如又回到 512 维），确保与后续层的兼容性。</li></ul><p>应用到我们的句子上：</p><p>想象 FFN 帮助识别 “quick” 和 “brown” 不仅描述了 “fox”，还通过它们联合的含义巧妙地与 “fox” 的速度感联系起来。</p><p>或者，它可能深入探究 “jumps” 和 “over” 之间的关系，理解这个动作和空间关系，超越了它们单独的定义。</p><p>重复、优化、再重复：自注意力、多头注意力等层被叠加并多次重复。每一次迭代，编码器都在精细化其对输入文本的理解，构建出一个全面的文本表征。</p><p><img src="https://img.iamghf.top/md/202404251110721.gif" alt="img"></p><p><strong>解码器：编织输出挂毯</strong></p><p>现在，轮到解码器承担任务。与编码器不同的是，解码器面临着额外的挑战：在不预见未来的情况下，逐字生成输出。为此，它采用了以下策略：</p><ul><li><strong>掩蔽自注意力</strong>：类似于编码器的自注意力机制，但有所调整。解码器仅关注之前已生成的单词，确保不会利用到未来的信息。这就像是一次只写出一个句子的故事，而不知道故事的结局。</li><li><strong>编码器 - 解码器注意力</strong>：这一机制允许解码器参考编码好的输入，就像写作时回头查看参考资料一样。这确保了生成的输出与原始文本保持一致性和连贯性。</li><li><strong>多头注意力和前馈网络</strong>：与编码器相同，这些层帮助解码器深化对文本中上下文和关系的理解。</li><li><strong>输出层</strong>：最终，解码器将其内部表征逐一转化为实际的输出单词。这就像是最后的装配线，把所有部件组合起来，形成期望的结果。</li></ul><p><strong>超越基本概念</strong></p><p>请记住，这只是 Transformer 世界迷人之处的一瞥。具体的架构会根据任务和数据集的不同而有所变化，包括不同数量的层和配置。</p><p>此外，每一层涉及的复杂数学运算超出了本解释的范围。</p><p>但希望这能让你基本理解 Transformer 如何工作，以及它们是如何彻底改变自然语言处理（NLP）领域的。</p><p>因此，当你下次遇到流畅的<a href="https://cloud.tencent.com/product/tmt?from_column=20065&from=20065" target="_blank" rel="noopener">机器翻译</a>或对 AI 驱动的文本生成器的创意赞叹时，请记住 Transformer 内部编码器与解码器之间的精妙互动，它们是如何通过注意力机制和并行处理技术共同织就这场魔法的。</p><p>论文链接：<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">https://arxiv.org/abs/1706.03762</a></p><p>原文链接：<a href="https://nintyzeros.substack.com/p/how-do-transformer-workdesign-a-multi" target="_blank" rel="noopener">https://nintyzeros.substack.com/p/how-do-transformer-workdesign-a-multi</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transformer </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2.0 协议原理</title>
      <link href="/20240424002.html"/>
      <url>/20240424002.html</url>
      
        <content type="html"><![CDATA[<h1 id="OAuth2-0-协议原理"><a href="#OAuth2-0-协议原理" class="headerlink" title="OAuth2.0 协议原理"></a>OAuth2.0 协议原理</h1><p>OAuth 2.0 协议是一种三方授权协议，目前大部分的第三方登录与授权都是基于该协议的标准或改进实现。OAuth 1.0 的标准在 2007 年发布，2.0 的标准则在 2011 年发布，其中 2.0 的标准取消所有 Token 的加密过程，并简化了授权流程，但因强制使用 HTTPS 协议，被认为安全性高于 1.0 的标准。</p><h2 id="一-基础应用：第三方登录"><a href="#一-基础应用：第三方登录" class="headerlink" title="一. 基础应用：第三方登录"></a>一. 基础应用：第三方登录</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>​    对于 OAuth2.0 协议（以下简称 OAuth 协议）的第一次接触，我相信大部分开发者都是通过对接第三方登录才开始知道和了解该协议。的确，OAuth 协议被广泛应用于第三方授权登录中，借助第三方登录可以让用户免于再次注册之苦，支持第三方登录也对这些网站、APP起到了积极的作用，免去了复杂的注册过程，用户体验更佳，更愿意去登录。这样在提高留存率的同时，也更加易于收集用户的一些非敏感信息等，另外还可以借助一些社交类的第三方帐号进行站点推广等。</p><p>​    帐号服务对于公司来说是一个基础类服务，既简单也复杂。说它简单，是因为帐号的主要业务就是注册和登录，相信很多人在初次接触 WEB 开发的时候，第一个作业就是实现一个用户注册和登录的流程；说它复杂，是因为帐号服务往往是一个公司开展其它业务的基础，必须是公司业务中 QPS 最高的业务之一，需具备高可用、低延迟等特点，因为涉及到用户的敏感信息，还需要在安全方面下足功夫，近几年听到的盗号、拖库事件越来越没有新鲜感了。所以对于一个规模不大的公司来说，将主要人力投入在建立自己的帐号业务上是一件性价比很低的事情，这个时候接入大公司的第三方帐号登录，应该是更加可取的一种选择。</p><h2 id="二-OAuth2-0协议的基本定义与授权流程"><a href="#二-OAuth2-0协议的基本定义与授权流程" class="headerlink" title="二. OAuth2.0协议的基本定义与授权流程"></a>二. OAuth2.0协议的基本定义与授权流程</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>​    作为第三方登录服务提供方，我们的核心矛盾点就是既要让用户在对接我们服务的APP上登录，同时还不能让该APP拿到用户的登录凭证。解决这一矛盾的利器就是 token（中文译为令牌），而 OAuth 协议的最终目的就是给第三方应用下发 token，它记录了用户的登录或授权状态，通过将 token 传递给第三方应用，既能让第三方应用登录并拿到用户许可数据，也可以将用户的凭证牢牢拽在自己的手里（token是加密存储的，所以不担心因token下发而泄露用户凭证数据）。</p><p>​    说到用户登录状态的记录，我们可能最先想到的是 session 机制，想想你在做的第一个用户登录应用的时候，是不是拿服务器的 session 去记录用户是否登录。这一做法简单，但是也存在问题，session 说到底也还是缓存，当用户量较大的时候，需要相当大容量的缓存才能够容纳所有用户的登录状态，并且我们的 WEB 服务器往往有多台，通过负载均衡机制来提升服务的可用性，这样的场景下，我们不能简单的通过本地 session 来记录用户的登录状态，必须有专门的 session 服务器，或者其它的一些 session 复制措施，还需要考虑宕机造成的 session 丢失等问题，总之用户量大了，许多最初不是问题的问题逐渐暴露出来，有的甚至可能是极其棘手的。实际上对于用户登录状态的保存，我们可以走 token 机制，让客户端自己去保存用户的登录状态，将服务器从繁重的压力中解脱出来，利用 SSO（单点登录：Single Sign On）来实现公司内各业务之间“一次登录，到处可用”。</p><p>​    回到 OAuth 协议，上面的论述可能侧重了第三方登录，实际上登录只是一个授权的过程，对于一个应用，其最终目的还是希望能够拿到用户存储在资源服务器上的用户数据，所以登录授权还只是第一步，后续 APP 还需要携带 token 去资源服务器请求用户数据，这个时候是一个鉴权的过程，OAuth 协议的主要目的在于授权，至于鉴权，实现上主要是还是对 APP 传递过来的 token 进行解析和验证，这一块相对要简单一些，所以下面主要讲解 OAuth 授权的流程。</p><h3 id="2-1-OAuth2-0定义的5种角色"><a href="#2-1-OAuth2-0定义的5种角色" class="headerlink" title="2.1 OAuth2.0定义的5种角色"></a>2.1 OAuth2.0定义的5种角色</h3><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><ul><li><strong>客户端（Client）</strong></li></ul><p>客户端是 OAuth 服务的接入方，其目的是请求用户存储在资源服务器上的受保护资源，客户端可以移动应用、网页应用，以及电视应用等等。</p><ul><li><strong>用户代理（User Agent）</strong></li></ul><p>用户代理是用户参与互联网的工具，一般可以理解为浏览器。</p><ul><li><strong>资源所有者（Resource Owner）</strong></li></ul><p>受保护资源所属的实体，比如资源的持有人等，下文的用户即资源所有者。</p><ul><li><strong>授权服务器（Authorization Server）</strong></li></ul><p>授权服务器的主要职责是验证资源所有者的身份，并依据资源所有者的许可对第三方应用下发令牌。</p><ul><li><strong>资源服务器（Resource Server）</strong></li></ul><p>托管资源的服务器，能够接收和响应持有令牌的资源访问请求，可以与授权服务器是同一台服务器，也可以分开。</p><h3 id="2-2-基本概念"><a href="#2-2-基本概念" class="headerlink" title="2.2 基本概念"></a>2.2 基本概念</h3><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="2-2-1-访问令牌（access-token）"><a href="#2-2-1-访问令牌（access-token）" class="headerlink" title="2.2.1 访问令牌（access token）"></a>2.2.1 访问令牌（access token）</h4><h5 id="-4"><a href="#-4" class="headerlink" title=""></a></h5><p>​    访问令牌是在用户授权许可下，授权服务器下发给客户端的一个授权凭证，该令牌所要表达的意思是“用户授予该APP在多少时间范围内允许访问哪些与自己相关的服务”，所以访问令牌主要在 时间范围 和 权限范围 两个维度进行控制，此外访问令牌对于客户端来说是非透明的，外在表现就是一个字符串，客户端无法知晓字符串背后所隐藏的用户信息，因此不用担心用户的登录凭证会因此而泄露。</p><h4 id="2-2-2-刷新令牌（refresh-token）"><a href="#2-2-2-刷新令牌（refresh-token）" class="headerlink" title="2.2.2 刷新令牌（refresh token）"></a>2.2.2 刷新令牌（refresh token）</h4><h5 id="-5"><a href="#-5" class="headerlink" title=""></a></h5><p>​    刷新令牌的作用在于更新访问令牌，访问令牌的有效期一般较短，这样可以保证在发生访问令牌泄露时，不至于造成太坏的影响，但是访问令牌有效期设置太短存在的副作用就是用户需要频繁授权，虽然可以通过一定的机制进行静默授权，但是频繁的调用授权接口，之于授权服务器也是一种压力，这种情况下就可以在下发访问令牌的同时下发一个刷新令牌，刷新令牌的有效期明显长于访问令牌，这样在访问令牌失效时，可以利用刷新令牌去授权服务器换取新的访问令牌，不过协议对于刷新令牌没有强制规定，是否需要该令牌是客户端可以自行选择。</p><h4 id="2-2-3-回调地址（redirect-uri）"><a href="#2-2-3-回调地址（redirect-uri）" class="headerlink" title="2.2.3 回调地址（redirect uri）"></a>2.2.3 回调地址（redirect uri）</h4><h5 id="-6"><a href="#-6" class="headerlink" title=""></a></h5><p>​    OAuth2.0 是一类基于回调的授权协议，在授权码模式中，整个授权需要分为两步进行，第一步下发授权码，第二步根据第一步拿到的授权码请求授权服务器下发访问令牌。OAuth 在第一步下发授权码时，是将授权码以参数的形式添加到回调地址后面，并以 302 跳转的形式进行下发，这样简化了客户端的操作，不需要再主动去触发一次请求，即可进入下一步流程。</p><p>​    回调请求的设计却存在一个很大的安全隐患，坏人如果在客户端请求过程中修改了对应的回调地址，并指向自己的服务器，那么坏人可以利用这种机制去拿到客户端的授权码，继而走后面的流程，最终拿到访问令牌，另外坏人可以利用该机制引导用户到一个恶意站点，继而对用户发起攻击。以上两点都是该机制对于用户所造成的安全威胁，对于授权服务器而言，也存在一定的危害，坏人可以利用该机制让授权服务器变成“请求发送器”，以授权服务器为代理请求目标地址，这样在消耗授权服务器性能的同时，也对目标地址服务器产生 DDOS 攻击。</p><p>​    为了避免上述安全隐患，OAuth 协议强制要求客户端在注册时填写自己的回调地址，这个回调地址的目的是为了让回调请求能够到达客户端自己的服务器，从而可以走获取访问令牌的流程。客户端可以同时配置多个回调地址，并在请求授权时携带一个地址，服务器会验证客户端传递上来的回调地址是否与之前注册的回调地址相同，或者前者是后者集合的一个元素，只有在满足这一条件下才允许下发授权码，同时协议还要求两步请求客户端携带的回调地址必须一致，通过这些措施来保证回调过程能够正常达到客户端自己的服务器，并继续后面拿授权码换取访问令牌的流程。</p><h4 id="2-2-4-权限范围（scope）"><a href="#2-2-4-权限范围（scope）" class="headerlink" title="2.2.4 权限范围（scope）"></a>2.2.4 权限范围（scope）</h4><h5 id="-7"><a href="#-7" class="headerlink" title=""></a></h5><p>​    访问令牌自带过期时间，可以在时间维度上对授权进行控制，而在范围维度上，OAuth 引入了一个 scope 的概念。scope 可以看做是一个对象，包含一个权限的 ID，名称，以及描述信息等，比如“获取您的基本资料（头像、昵称）”。应该在接入帐号服务时必须向第三方登录服务提供方申请响应的 scope，并在请求授权时指明该参数（否则表明获取该应用所允许的所有权限），这些权限在用户确认授权时，必须毫无保留的展示给用户，以让用户知道该APP需要获取用户的哪些数据或服务。</p><h3 id="2-3-基本授权流程"><a href="#2-3-基本授权流程" class="headerlink" title="2.3 基本授权流程"></a>2.3 基本授权流程</h3><h4 id="-8"><a href="#-8" class="headerlink" title=""></a></h4><p>​    OAuth协议已定义了 4 种授权模式，其中最具代表性的就是授权码模式，这个在 3.1 小节中详细介绍，这里先以该模式来简单感受一下 OAuth2.0 的授权流程，授权流程图如下：</p><p><img src="https://img.iamghf.top/md/202404241038150.png" alt="授权流程"></p><p>假设整个流程开始之前，用户已经登录，那么整个授权流程如下：</p><ol><li>客户端请求授权服务器</li><li>授权授权服务的授权端点重定向用户至授权交互页面，并询问用户是否授权</li><li>如果用户许可，则授权端点验证客户端的身份，并发放授权码给客户端</li><li>客户端拿到授权码之后，携带授权码请求授权服务器的令牌端点下发访问令牌</li><li>令牌端点验证客户端的身份和授权码，通过则下发访问令牌和刷新令牌（可选）</li><li>客户端拿到访问令牌后，携带访问令牌请求资源服务器上的受保护资源</li><li>资源服务器验证客户端身份和访问令牌，通过则响应受保护资源访问请求</li></ol><p>整个流程中，客户端都无法接触到用户的登录凭证信息，客户端通过访问令牌请求受保护资源，用户可以通过对授权操作的控制来间接控制客户端对于受保护资源的访问权限范围和时效。</p><h2 id="三-四种授权模式"><a href="#三-四种授权模式" class="headerlink" title="三. 四种授权模式"></a>三. 四种授权模式</h2><h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><p>​    OAuth2.0 相对于 1.0 版本在授权模式上做了更多的细化，已定义的授权模式分为四种：1）授权码模式（Authorization Code Grant）；2)隐式授权模式（Implicit Grant）；3）资源所有者密码凭证模式（Resource Owner Password Credentials Grant）；4）以及客户端凭证模式（Client Credentials Grant）。</p><h3 id="3-1-授权码授权模式（Authorization-Code-Grant）"><a href="#3-1-授权码授权模式（Authorization-Code-Grant）" class="headerlink" title="3.1 授权码授权模式（Authorization Code Grant）"></a>3.1 授权码授权模式（Authorization Code Grant）</h3><h4 id="-10"><a href="#-10" class="headerlink" title=""></a></h4><p>​    授权码模式在整个授权流程上与 1.0 版本最贴近，但是整个流程还是要简化了许多，也是 OAuth2.0 中最标准，应用最广泛的授权模式。这类授权模式非常适合于具备服务端的应用，当然现在大多数 APP 都有自己的服务端，所以大部分 APP 的 OAuth 授权都可以采取授权码模式，下图为授权码各个角色之间的交互时序（这里让用户直接参与其中，省略了用户代理）：</p><p><img src="https://img.iamghf.top/md/202404241039173.png" alt="img"></p><p>整个授权流程说明如下（具体参数释义见下文）：</p><ol><li>客户端携带 client_id, scope, redirect_uri, state 等信息引导用户请求授权服务器的授权端点下发 code</li><li>授权服务器验证客户端身份，验证通过则询问用户是否同意授权（此时会跳转到用户能够直观看到的授权页面，等待用户点击确认授权）</li><li>假设用户同意授权，此时授权服务器会将 code 和 state（如果客户端传递了该参数）拼接在 redirect_uri 后面，以302形式下发 code</li><li>客户端携带 code, redirect_uri, 以及 client_secret 请求授权服务器的令牌端点下发 access_token （这一步实际上中间经过了客户端的服务器，除了 code，其它参数都是在应用服务器端添加，下文会细讲）</li><li>授权服务器验证客户端身份，同时验证 code，以及 redirect_uri 是否与请求 code 时相同，验证通过后下发 access_token，并选择性下发 refresh_token</li></ol><h4 id="3-1-1-获取授权码"><a href="#3-1-1-获取授权码" class="headerlink" title="3.1.1 获取授权码"></a>3.1.1 获取授权码</h4><h5 id="-11"><a href="#-11" class="headerlink" title=""></a></h5><p>​    授权码是授权流程的一个中间临时凭证，是对用户确认授权这一操作的一个暂时性的证书，其生命周期一般较短，协议建议最大不要超过10分钟，在这一有效时间周期内，客户端可以凭借该暂时性证书去授权服务器换取访问令牌。</p><p>请求参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">response_type</td><td align="left">必须</td><td align="left">对于授权码模式 <code>response_type=code</code></td></tr><tr><td align="left">client_id</td><td align="left">必须</td><td align="left">客户端ID，用于标识一个客户端，等同于appId，在注册应用时生成</td></tr><tr><td align="left">redirect_uri</td><td align="left">可选</td><td align="left">授权回调地址，具体参见 2.2.3 小节</td></tr><tr><td align="left">scope</td><td align="left">可选</td><td align="left">权限范围，用于对客户端的权限进行控制，如果客户端没有传递该参数，那么服务器则以该应用的所有权限代替</td></tr><tr><td align="left">state</td><td align="left">推荐</td><td align="left">用于维持请求和回调过程中的状态，防止<a href="https://zh.wikipedia.org/wiki/跨站请求伪造" target="_blank" rel="noopener">CSRF攻击</a>，服务器不对该参数做任何处理，如果客户端携带了该参数，则服务器在响应时原封不动的返回</td></tr></tbody></table><p>请求参数示例：</p><pre><code>GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1  Host: server.example.com</code></pre><p>​    客户端携带上述参数请求授权服务器的令牌端点，授权服务器会验证客户端的身份以及相关参数，并在确认用户登录的前提下弹出确认授权页询问用户是否授权，如果用户同意授权，则会将授权码（code）和state信息（如果客户端传递了该参数）添加到回调地址后面，以 302 的形式下发。</p><p>成功响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">code</td><td align="left">必须</td><td align="left">授权码，授权码代表用户确认授权的暂时性凭证，只能使用一次，推荐最大生命周期不超过10分钟</td></tr><tr><td align="left">state</td><td align="left">可选</td><td align="left">如果客户端传递了该参数，则必须原封不动返回</td></tr></tbody></table><p>成功响应示例：</p><pre><code>HTTP/1.1 302 FoundLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz</code></pre><p>如果请求参数错误，或者服务器端响应错误，那么需要将错误信息添加在回调地址后面，以 302 形式下发（回调地址错误，或客户端标识无效除外）。</p><p>错误响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">error</td><td align="left">必须</td><td align="left">错误代码</td></tr><tr><td align="left">error_description</td><td align="left">可选</td><td align="left">具备可读性的错误描述信息</td></tr><tr><td align="left">error_uri</td><td align="left">可选</td><td align="left">错误描述信息页面地址</td></tr><tr><td align="left">state</td><td align="left">可选</td><td align="left">如果客户端传递了该参数，则必须原封不动返回</td></tr></tbody></table><p>错误响应示例：</p><pre><code>HTTP/1.1 302 FoundLocation: https://client.example.com/cb?error=access_denied&amp;state=xyz</code></pre><h4 id="3-1-2-下发访问令牌"><a href="#3-1-2-下发访问令牌" class="headerlink" title="3.1.2 下发访问令牌"></a>3.1.2 下发访问令牌</h4><h5 id="-12"><a href="#-12" class="headerlink" title=""></a></h5><p>​    授权服务器的授权端点在以 302 形式下发 code 之后，用户 User-Agent，比如浏览器，将携带对应的 code 回调请求用户指定的 redirect_url，这个地址应该能够保证请求打到应用服务器的对应接口，该接口可以由此拿到 code，并附加相应参数请求授权服务器的令牌端点，授权端点验证 code 和相关参数，验证通过则下发 access_token。</p><p>请求参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">grant_type</td><td align="left">必须</td><td align="left">对于授权码模式 <code>grant_type=authorization_code</code></td></tr><tr><td align="left">code</td><td align="left">必须</td><td align="left">上一步骤获取的授权码</td></tr><tr><td align="left">redirect_uri</td><td align="left">必须</td><td align="left">授权回调地址，具体参见 2.2.3 小节，如果上一步有设置，则必须相同</td></tr><tr><td align="left">client_id</td><td align="left">必须</td><td align="left">客户端ID，用于标识一个客户端，等同于appId，在注册应用时生成</td></tr></tbody></table><p>​    如果在注册应用时有下发客户端凭证信息（client_secret），那么客户端必须携带该参数以让授权服务器验证客户端的有效性。针对客户端凭证需要多说的一点就是，不能将其传递到客户端，客户端无法保证凭证的安全，凭证应该始终留在应用的服务器端，当下发code回调请求到应用服务器时，在服务器端携带上凭证再次请求下发令牌。</p><p>请求参数示例：</p><pre><code>POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</code></pre><p>​    授权服务器需要验证客户端的有效性，以及是否与之前请求授权码的客户端是同一个（请求授权时的信息可以记录在 code，或以 code 为 key 建立缓存），授权服务器还要保证code 处于生命周期内（推荐10分钟内有效），且只能被使用一次。授权服务器验证通过之后，生成 access_token，并选择性下发 refresh_token，OAuth2.0 协议明确了 token 的下发策略，对于生成策略没有做太多说明。</p><p>成功响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">必须</td><td align="left">访问令牌</td></tr><tr><td align="left">token_type</td><td align="left">必须</td><td align="left">访问令牌类型，比如 bearer，mac 等等</td></tr><tr><td align="left">expires_in</td><td align="left">推荐</td><td align="left">访问令牌的生命周期，以秒为单位，表示令牌下发后多久时间过期，如果没有指定该项，则使用默认值</td></tr><tr><td align="left">refresh_token</td><td align="left">可选</td><td align="left">刷新令牌，选择性下发，参见 2.2.2</td></tr><tr><td align="left">scope</td><td align="left">可选</td><td align="left">权限范围，如果最终下发的访问令牌对应的权限范围与实际应用指定的不一致，则必须在下发访问令牌时用该参数指定说明</td></tr></tbody></table><p>最后访问令牌以 JSON 格式响应，并要求指定响应首部 Cache-Control: no-store 和 Pragma: no-cache。</p><p>成功响应示例：</p><pre><code>HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache{&quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,&quot;token_type&quot;:&quot;example&quot;,&quot;expires_in&quot;:3600,&quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,&quot;example_parameter&quot;:&quot;example_value&quot;}</code></pre><p>错误响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">error</td><td align="left">必须</td><td align="left">错误代码</td></tr><tr><td align="left">error_description</td><td align="left">可选</td><td align="left">具备可读性的错误描述信息</td></tr><tr><td align="left">error_uri</td><td align="left">可选</td><td align="left">错误描述信息页面地址</td></tr></tbody></table><p>错误响应示例：</p><pre><code>HTTP/1.1 400 Bad RequestContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache{&quot;error&quot;:&quot;invalid_request&quot;}</code></pre><h4 id="3-1-3-对于授权码模式的一点感悟"><a href="#3-1-3-对于授权码模式的一点感悟" class="headerlink" title="3.1.3 对于授权码模式的一点感悟"></a>3.1.3 对于授权码模式的一点感悟</h4><h5 id="-13"><a href="#-13" class="headerlink" title=""></a></h5><p>​    授权码授权模式是 OAuth2.0 协议已定义 4 种模式中最严谨的模式，剩余 3 中模式都是建立在一些特殊场景下，并对这些场景做了一些妥协和优化。授权码授权流程分为两步走，将用户授权与下发 token 分开，这给授权带来了更多的灵活性，正常授权过程中必须经过用户登录这一步骤，在用户已登录的前提下，可以直接询问用户是否同意授权，但是在一些场景下，比如内部走 SSO 登录的应用集成了基于 OAuth 登录的第三方应用，这个时候在 OAuth 授权登录第三方应用时用户体验较好的流程是不需要用户再一次输入用户名和密码登录的，这就需要将外围 APP 的登录态传递给该应用，但是这样是存在安全问题的，用户的登录态必须把握在走 SSO 登录流程的应用中，这样的场景下授权码授权模式的两步走流程就可以满足在不交出用户登录态的情况下，无需再次登录即可授权。</p><p>​    内部应用可以拿着第三方应用的 client_id 等信息代替第三方应用去请求获取 code，因为自己持有用户的登录态，所以过程中无需用户再次输入用户名和密码，拿到 code 之后将其交给第三方应用，第三方应用利用 code 和自己的 client_secret 信息去请求授权服务器下发 token，整个流程内部应用不需要交出自己持有的用户登录态，第三方应用也无需交出自己的 client_secret 信息，最终却能够实现在保护用户登录凭证的前提下无需再次登录即可完成整个授权流程。</p><h3 id="3-2-隐式授权模式（Implicit-Grant）"><a href="#3-2-隐式授权模式（Implicit-Grant）" class="headerlink" title="3.2 隐式授权模式（Implicit Grant）"></a>3.2 隐式授权模式（Implicit Grant）</h3><h4 id="-14"><a href="#-14" class="headerlink" title=""></a></h4><p>​    对于一些纯客户端应用，往往无法妥善的保管客户端的凭证，但是因为没有服务器端，所以无法向授权服务器传递客户端凭证，并且纯客户端应用在请求交互上要弱于有服务器的应用，这时候减少交互可以让应用的稳定性和用户体验更好，隐式授权模式是对这一应用场景的优化。</p><p>​    隐式授权模式在安全性上要弱于授权码模式，因为无法对当前客户端的真实性进行验证，同时对于下发的 access_token 存在被同设备上其它应用窃取的风险，为了降低这类风险，隐式授权模式强制要求不能下发 refresh_token，这一强制要求的另外一个考量个人觉得是因为 refresh_token 的生命周期较长，而客户端无法安全的对其进行存储和保护。下图为授权码各个角色之间的交互时序（这里让用户直接参与其中，省略了用户代理）：</p><p><img src="https://img.iamghf.top/md/202404241039362.png" alt="img"></p><p>整个授权流程说明如下：</p><ol><li>客户端携带 client_id, scope, redirect_uri, state 等信息引导用户请求授权服务器下发 access_token</li><li>授权服务器验证客户端身份，验证通过则询问用户是否同意授权（此时会跳转到用户能够直观看到的授权页面，等待用户点击确认授权）</li><li>假设用户同意授权，此时授权服务器会将 access_token 和 state（如果客户端传递了该参数）等信息以URI Fragment形式拼接在redirect_uri后面，并以302形式下发</li><li>客户端利用脚本解析获取 access_token</li></ol><h4 id="3-2-1-请求获取访问令牌"><a href="#3-2-1-请求获取访问令牌" class="headerlink" title="3.2.1 请求获取访问令牌"></a>3.2.1 请求获取访问令牌</h4><h5 id="-15"><a href="#-15" class="headerlink" title=""></a></h5><p>不同于授权码模式的分两步走，隐式授权码模式一步即可拿到访问令牌。</p><p>请求参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">response_type</td><td align="left">必须</td><td align="left">对于授权码模式 <code>response_type=token</code></td></tr><tr><td align="left">client_id</td><td align="left">必须</td><td align="left">客户端ID，用于标识一个客户端，等同于appId，在注册应用时生成</td></tr><tr><td align="left">redirect_uri</td><td align="left">可选</td><td align="left">授权回调地址，具体参见 2.2.3 小节</td></tr><tr><td align="left">scope</td><td align="left">可选</td><td align="left">权限范围，用于对客户端的权限进行控制，如果客户端没有传递该参数，那么服务器则以该应用的所有权限代替</td></tr><tr><td align="left">state</td><td align="left">推荐</td><td align="left">用于维持请求和回调过程中的状态，防止 <a href="https://zh.wikipedia.org/wiki/跨站请求伪造" target="_blank" rel="noopener">CSRF攻击</a>，服务器不对该参数做任何处理，如果客户端携带了该参数，则服务器在响应时原封不动的返回</td></tr></tbody></table><p>请求参数示例：</p><pre><code>GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1Host: server.example.com</code></pre><p>成功响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">必须</td><td align="left">访问令牌</td></tr><tr><td align="left">token_type</td><td align="left">必须</td><td align="left">访问令牌类型，比如bearer，mac等等</td></tr><tr><td align="left">expires_in</td><td align="left">推荐</td><td align="left">访问令牌的生命周期，以秒为单位，表示令牌下发后多久时间过期，如果没有指定该项，则使用默认值</td></tr><tr><td align="left">scope</td><td align="left">可选</td><td align="left">权限范围，如果最终下发的访问令牌对应的权限范围与实际应用指定的不一致，则必须在下发访问令牌时用该参数指定说明</td></tr><tr><td align="left">state</td><td align="left">可选</td><td align="left">如果客户端传递了该参数，则必须原封不动返回</td></tr></tbody></table><p>隐式授权模式不下发刷新令牌，访问令牌以 URI Fragment 的形式拼接在授权回调地址后面以 302 形式下发，并要求指定响应首部 Cache-Control: no-store 和 Pragma: no-cache。</p><p>成功响应示例：</p><pre><code>HTTP/1.1 302 FoundLocation: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA&amp;state=xyz&amp;token_type=example&amp;expires_in=3600</code></pre><p>错误响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">error</td><td align="left">必须</td><td align="left">错误代码</td></tr><tr><td align="left">error_description</td><td align="left">可选</td><td align="left">具备可读性的错误描述信息</td></tr><tr><td align="left">error_uri</td><td align="left">可选</td><td align="left">错误描述信息页面地址</td></tr><tr><td align="left">state</td><td align="left">可选</td><td align="left">如果客户端传递了该参数，则必须原封不动返回</td></tr></tbody></table><p>授权服务器将上述元素以 URI Fragment 形式拼接在授权回调地址后面以 302 形式下发（redirect_uri 或 client_id 错误除外）。</p><p>错误响应参数示例：</p><pre><code>HTTP/1.1 302 FoundLocation: https://client.example.com/cb#error=access_denied&amp;state=xyz</code></pre><h3 id="3-3-资源所有者密码凭证授权模式（Resource-Owner-Password-Credentials-Grant）"><a href="#3-3-资源所有者密码凭证授权模式（Resource-Owner-Password-Credentials-Grant）" class="headerlink" title="3.3 资源所有者密码凭证授权模式（Resource Owner Password Credentials Grant）"></a>3.3 资源所有者密码凭证授权模式（Resource Owner Password Credentials Grant）</h3><h4 id="-16"><a href="#-16" class="headerlink" title=""></a></h4><p>​    资源所有者密码凭证授权模式建立在资源所有者充分信任客户端的前提下，因为该模式客户端可以拿到用的登录凭证，从而在用户无感知的情况下完成整个授权流程，毕竟都有用户的登录凭证了，再弹窗让用户确认授权也是多此一举。</p><p>​    这里可能有一个比较疑惑的地方是既然已经拿到了用户的登录凭证，为什么还需要绕一大圈子走 OAuth 授权，拿到令牌再去请求用户的受保护资源呢？实际中事情可能并不会这么简单，拿到用户登录凭证的不一定是用户本身，而且这里协议指的用户登录凭证是用户的用户名和密码，实际中还可以是走 SSO 登录下发的 token，token 在持有权限上要小于等于用户的用户名和密码，这是从客户端角度出发，对于资源服务器来说，有些敏感数据需要在用户级别做权限控制，对于服务级别的控制粒度太粗，所以这些服务往往需要服务携带 access_token 来请求某一个用户的敏感数据。</p><p>​    举个例子来说，比如有一个服务是获取某个用户的通讯录，这是一个十分敏感的数据，且一般只能授予内部应用，如果是在服务级别进行控制，那么只要拿到服务权限，该应用可以请求获取任何一个用户的通讯录数据，这是一件十分危险的事情。然而如果基于 access_token 来做鉴权，那么就可以将粒度控制在用户级别，前面讲的两种授权方式在这里应用时都有一个共同的缺点，需要弹出授权页让用户确认授权，要知道这样的场景往往是发生在内部应用里面，内部应用是可以持有用户登录态的，这里的确认授权对于一个用户体验好的APP来说就应该发生在用户登录时，通过用户协议等方式直接告诉用户，从而让用户在一次登录过程中可以让应用拿到用户的登录态和访问令牌。资源所有者密码凭证授权模式的交互时序如下：</p><p><img src="https://img.iamghf.top/md/202404241039836.png" alt="img"></p><p>整个授权流程说明如下：</p><ol><li>用户授予客户端登录凭证（比如用户名和密码信息）</li><li>客户端携带用户的登录凭证和 scope 等信息请授权服务器的令牌端点下发 refresh_token </li><li>授权服务器验证用户的登录凭证和客户端信息的有效性，验证通过则下发 access_token，并选择性下发 refresh_token</li></ol><h4 id="3-3-1-用户授予登录凭证"><a href="#3-3-1-用户授予登录凭证" class="headerlink" title="3.3.1 用户授予登录凭证"></a>3.3.1 用户授予登录凭证</h4><h5 id="-17"><a href="#-17" class="headerlink" title=""></a></h5><p>​    用于登录凭证如何传递给客户端这一块协议未做说明，实际应用中该类授权一般应用在内部应用，这类应用的特点就是为用户提供登录功能，当用户登录之后，这类应用也就持有了用户的登录态，可以是用户登录的 session 标识，也可以是走 SSO 下发的 token 信息。</p><h4 id="3-3-2-请求获取访问令牌"><a href="#3-3-2-请求获取访问令牌" class="headerlink" title="3.3.2 请求获取访问令牌"></a>3.3.2 请求获取访问令牌</h4><h5 id="-18"><a href="#-18" class="headerlink" title=""></a></h5><p>请求参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">grant_type</td><td align="left">必须</td><td align="left">对于本模式 <code>grant_type=password</code></td></tr><tr><td align="left">username</td><td align="left">必须</td><td align="left">用户名</td></tr><tr><td align="left">password</td><td align="left">必须</td><td align="left">用户密码</td></tr><tr><td align="left">scope</td><td align="left">可选</td><td align="left">权限范围，如果最终下发的访问令牌对应的权限范围与实际应用指定的不一致，则必须在下发访问令牌时用该参数指定说明</td></tr></tbody></table><p>如果在注册应用时有下发客户端凭证信息（client_secret），那么客户端必须携带该参数以让授权服务器验证客户端的有效性。</p><p>请求参数示例：</p><pre><code>POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=password&amp;username=johndoe&amp;password=A3ddj3w</code></pre><p>成功响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">必须</td><td align="left">访问令牌</td></tr><tr><td align="left">token_type</td><td align="left">必须</td><td align="left">访问令牌类型，比如 bearer，mac 等等</td></tr><tr><td align="left">expires_in</td><td align="left">推荐</td><td align="left">访问令牌的生命周期，以秒为单位，表示令牌下发后多久时间过期，如果没有指定该项，则使用默认值</td></tr><tr><td align="left">refresh_token</td><td align="left">可选</td><td align="left">刷新令牌，选择性下发，参见 2.2.2</td></tr><tr><td align="left">scope</td><td align="left">可选</td><td align="left">权限范围，如果最终下发的访问令牌对应的权限范围与实际应用指定的不一致，则必须在下发访问令牌时用该参数指定说明</td></tr></tbody></table><p>最后访问令牌以 JSON 格式响应，并要求指定响应首部 Cache-Control: no-store 和 Pragma: no-cache。</p><p>成功响应参数示例：</p><pre><code>HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache{&quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,&quot;token_type&quot;:&quot;example&quot;,&quot;expires_in&quot;:3600,&quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,&quot;example_parameter&quot;:&quot;example_value&quot;}</code></pre><p>错误响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">error</td><td align="left">必须</td><td align="left">错误代码</td></tr><tr><td align="left">error_description</td><td align="left">可选</td><td align="left">具备可读性的错误描述信息</td></tr><tr><td align="left">error_uri</td><td align="left">可选</td><td align="left">错误描述信息页面地址</td></tr></tbody></table><p>错误响应示例：</p><pre><code>HTTP/1.1 400 Bad RequestContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache{&quot;error&quot;:&quot;invalid_request&quot;}</code></pre><h3 id="3-4-客户端凭证授权模式（Client-Credentials-Grant）"><a href="#3-4-客户端凭证授权模式（Client-Credentials-Grant）" class="headerlink" title="3.4 客户端凭证授权模式（Client Credentials Grant）"></a>3.4 客户端凭证授权模式（Client Credentials Grant）</h3><h4 id="-19"><a href="#-19" class="headerlink" title=""></a></h4><p>​    客户端凭证授权模式基于客户端持有的证书去请求用户的受保护资源，如果把这里的受保护资源定义得更加宽泛一点，比如说是对一个内网接口权限的调用，那么这类授权方式可以被改造为内网权限验证服务。客户端凭证授权模式的交互时序如下：</p><p><img src="https://img.iamghf.top/md/202404241039945.png" alt="img"></p><p>整个授权流程说明如下：</p><ol><li>客户端携带客户端凭证和scope等信息请求授权服务器的令牌端点</li><li>授权服务器验证客户端凭证，验证通过下发 access_token</li></ol><h4 id="3-4-1-请求获取访问令牌："><a href="#3-4-1-请求获取访问令牌：" class="headerlink" title="3.4.1 请求获取访问令牌："></a>3.4.1 请求获取访问令牌：</h4><h5 id="-20"><a href="#-20" class="headerlink" title=""></a></h5><p>请求参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">grant_type</td><td align="left">必须</td><td align="left">对于本模式 <code>grant_type=client_credentials</code></td></tr><tr><td align="left">scope</td><td align="left">可选</td><td align="left">权限范围，如果最终下发的访问令牌对应的权限范围与实际应用指定的不一致，则必须在下发访问令牌时用该参数指定说明</td></tr></tbody></table><p>请求参数示例：</p><pre><code>POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=client_credentials</code></pre><p>成功响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">必须</td><td align="left">访问令牌</td></tr><tr><td align="left">token_type</td><td align="left">必须</td><td align="left">访问令牌类型，比如 bearer，mac 等等</td></tr><tr><td align="left">expires_in</td><td align="left">推荐</td><td align="left">访问令牌的生命周期，以秒为单位，表示令牌下发后多久时间过期，如果没有指定该项，则使用默认值</td></tr><tr><td align="left">scope</td><td align="left">可选</td><td align="left">权限范围，如果最终下发的访问令牌对应的权限范围与实际应用指定的不一致，则必须在下发访问令牌时用该参数指定说明</td></tr></tbody></table><p>最后访问令牌以JSON格式响应，并要求指定响应首部Cache-Control: no-store和Pragma: no-cache。</p><p>成功响应参数示例：</p><pre><code>HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache{&quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,&quot;token_type&quot;:&quot;example&quot;,&quot;expires_in&quot;:3600,&quot;example_parameter&quot;:&quot;example_value&quot;}</code></pre><p>错误响应参数说明：</p><table><thead><tr><th align="left">名称</th><th align="left">是否必须</th><th align="left">描述信息</th></tr></thead><tbody><tr><td align="left">error</td><td align="left">必须</td><td align="left">错误代码</td></tr><tr><td align="left">error_description</td><td align="left">可选</td><td align="left">具备可读性的错误描述信息</td></tr><tr><td align="left">error_uri</td><td align="left">可选</td><td align="left">错误描述信息页面地址</td></tr></tbody></table><p>错误响应示例：</p><pre><code>HTTP/1.1 400 Bad RequestContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache{&quot;error&quot;:&quot;invalid_request&quot;}</code></pre><h2 id="四-本篇小结"><a href="#四-本篇小结" class="headerlink" title="四. 本篇小结"></a>四. 本篇小结</h2><h3 id="-21"><a href="#-21" class="headerlink" title=""></a></h3><p>​    本篇介绍了 OAuth2.0 授权协议的理论知识，OAuth2.0 被广泛应用于第三方授权登录，很多其它的协议都是可以基于该协议进行改造的，比如前面多次提到的 SSO，作为开发人员，还是建议对该协议或多或少有些了解。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://tools.ietf.org/html/rfc5849" target="_blank" rel="noopener">RFC5849 - The OAuth 1.0 Protocol</a></li><li><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">RFC6749 - The OAuth 2.0 Authorization Framework</a></li><li><a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">RFC6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></li><li><a href="https://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-02" target="_blank" rel="noopener">HTTP Authentication: MAC Authentication (draft-hammer-oauth-v2-mac-token-02)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oauth 2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从神经网络到 Hugging Face</title>
      <link href="/20240424001.html"/>
      <url>/20240424001.html</url>
      
        <content type="html"><![CDATA[<h1 id="从神经网络到-Hugging-Face"><a href="#从神经网络到-Hugging-Face" class="headerlink" title="从神经网络到 Hugging Face"></a>从神经网络到 Hugging Face</h1><h2 id="神经网络和深度学习简史"><a href="#神经网络和深度学习简史" class="headerlink" title="神经网络和深度学习简史"></a>神经网络和深度学习简史</h2><h2 id="一-深度信念网络"><a href="#一-深度信念网络" class="headerlink" title="一 深度信念网络"></a>一 深度信念网络</h2><p>2006年，加拿大多伦多大学教授杰弗里·辛顿在研究如何训练多层神经网络，他已经在神经网络领域默默耕耘了三十多年，尽管在这个领域他算得上是泰斗级的人物，但由于神经网络在人工智能行业一直不被看好，所以他的研究成果一直不为业界所重视。</p><p>辛顿出生于英国伦敦，他的家族出过不少知名学者，创立布尔代数的逻辑学家乔治·布尔便是他的曾曾祖父。他的祖父是位科普作家，父亲是昆虫学家。辛顿比周围的人都要聪明，但他的求学之路却颇为曲折，先是在大学攻读建筑学，转而又选择物理学，后又改读哲学，最后以心理学学士身份毕业。1972年辛顿进入爱丁堡大学攻读博士学位，研究方向是神经网络。彼时神经网络被业界所鄙夷，连辛顿的导师也认为这玩意没什么实际用途，也没有前途可言。但辛顿却不为所动，对神经网络研究怀有信心，坚持认为能够证明神经网络的价值，这一坚持就是三十多年。</p><p><img src="https://img.iamghf.top/md/202404241033903.jpg" alt="geoffery-hinton.jpg"></p><p>辛顿年轻的时候有一次搬移取暖器，腰椎间盘滑脱了，此后便一直饱受腰背病痛问题的困扰。近年来，问题更严重了，大多数时候，他需要平躺着以缓解疼痛，这意味着他不能开车，也不能坐飞机，甚至在实验室里会见学生时，也要平躺在办公室的折叠床上。身体上疼痛的折磨带给辛顿的打击还不如学术研究被冷漠那么大。早在1969年，明斯基在《感知机》一书中就对多层感知机下了定论，给后来的神经网络研究盖戳：“多层感知机不会有发展前景，因为世界上没人可以将多层感知机训练得足够好，哪怕是令它可以学会最简单的函数方法。” 单层感知机能力有限，连“异或”这种基础的分类问题也实现不了，而多层感知机又没有可用的训练方法，等于说神经网络的研究方向是死路一条。神经网络在业界被认为是学术异端，没有人相信它可以成功，因此一般学生在选择导师的时候都谨慎绕开神经网络，一时间辛顿甚至都招不满研究生。</p><p>1983年，辛顿发明玻尔兹曼机，后来，简化后的受限玻尔兹曼机被应用于机器学习，成为深度神经网络的层级结构基础。1986年，辛顿提出适用于多层感知机的误差反向传播算法（BP），这一算法奠定了后来深度学习的基础。辛顿每隔一段时间都能发明出新东西，而他也坚持写了两百多篇神经网络相关的论文，尽管这些论文不被待见。到了2006年，辛顿已经积累了丰富的理论和实践基础，而这一次，他发表的论文将改变整个机器学习乃至整个世界。</p><p>辛顿发现，拥有多个隐藏层的神经网络能够具有自动提取特征学习的能力，相比传统的手工提取特征的机器学习更有效果。另外，通过逐层预训练的方式可以降低多层神经网络的训练难度，而这解决了长期以来多层神经网络训练的难题。辛顿将他的研究成果发表在两篇论文中，而当时神经网络一词被许多学术期刊编辑所排斥，有些稿件的标题甚至因为包含“神经网络”就会被退回。为了不刺激这些人的敏感神经，辛顿取了个新名字，将该模型命名为“深度信念网络”（Deep Belief Network）。</p><h2 id="二-感知机"><a href="#二-感知机" class="headerlink" title="二 感知机"></a>二 感知机</h2><p>其实神经网络的研究可以追溯到上世纪四十年代。1940年，17岁的沃尔特·皮茨在伊利诺伊大学芝加哥分校结识了42岁的教授沃伦·麦卡洛克，一见如故，便加入了后者的研究项目：尝试用神经元网络建立一个在逻辑运算基础上的机械性的大脑思维模型。他们用逻辑运算来抽象人类大脑的思维模型，提出了“神经网络”（Neural Network）这一概念，而神经元是神经网络中的最小信息处理单元；并且他们将神经元的工作过程抽象简化成一个非常简单的逻辑运算模型，后来这个模型被命名为“M-P神经元模型”，以他们两姓名的首字母来命名。</p><p>在这个模型中，一个神经元会接受过个来自于其他神经元传递过来的输入信号，不同的输入信号的重要性有差异，这种差异就通过连接上的“权重”（weight）大小来表示，该神经元将所有输入值按照权重加权求和，再将结果跟神经元的“激发阈值”（Threshold）进行比较，以决定是否对外输出信号。</p><p><img src="https://img.iamghf.top/md/202404241033794.png" alt="m-p-model.png"></p><p>“M-P模型”足够简单直接，而且可以通过符号逻辑来模拟实现，人工智能专家以该模型为基础，构建了神经网络模型，用来解决机器学习任务。这里简单说明下人工智能、机器学习和深度学习的关系：人工智能就是使用计算机技术来实现人类智能的技术，在一般教材定义为研究与构建智能体。智能体就是 Intelligent agent，或简称 agent，它通过模仿人类思维和认知来解决特定任务或通用任务，解决特性任务的智能体被称为弱人工智能，或狭义人工智能（ANI），而解决通用任务的智能体被称为强人工智能，或通用人工智能（AGI）。机器学习是人工智能的一个分支，它通过数据进行学习并改进系统。而深度学习则又是机器学习的一个分支，它使用神经网络技术进行机器学习。</p><p>1957年，康奈尔大学心理学教授罗森布拉特在IBM计算机上模拟实现了一个神经网络模型，他称之为“感知机”（Perceptron）。他的做法是将一组M-P模型神经元组合在一起，可以用来训练并完成一些机器视觉模式识别方面的任务。一般来说，机器学习有两种任务：分类和回归。分类问题是判断数据是哪一类的问题，比如识别图像是猫还是狗；而回归问题是根据一个数据预测另一个数据的问题，比如根据人的图像预测其体重。感知机解决的是线性分类问题。以《智慧的疆界》书中对感知机工作原理的举例来解释：</p><p>假设任务目标是自动识别阿拉伯数字，待识别的数字是将手写或印刷的各种形式的数字，将数字通过扫描后存储在14*14像素大小的图片文件中。首先，要准备类似下图的训练集供机器学习用。训练集即训练数据集，是专门提供给计算机学习使用的数据集，它不仅是一组图片之类的数据，还会由人工事先标注告诉机器这些图片数据代表的数字是什么。</p><p><img src="https://img.iamghf.top/md/202404241033829.jpeg" alt="numbers-datasets.jpeg"></p><p>然后，我们要设计一种数据结构，以便机器可以存储并处理这些图片。对于14*14的灰度数字图片，可以将黑色像素用1来表示，白色像素用0表示，介于黑白间的灰度像素根据其灰度强度用0-1间的浮点数表示。如下图所示对该图可以转换成一个二维张量数组：</p><p><img src="https://img.iamghf.top/md/202404241033172.jpeg" alt="number1-represent.jpeg"></p><p>而机器能够识别出图片中的数字是什么，主要是找到了该图片表示某个数字的特征。对于人类来说，对于识别这些手写体数字很容易，但我们很难解释这些特征是什么。机器学习的目标就是要提取出这些训练集中图片表示数字的特征，根据M-P模型，提取特征的方法就是选择对图片各个像素值进行加权求和，根据训练集中的样本图片和标注数据的对应结果来计算每个像素对应各数字的权值：如果某一个像素具有很负面的证据说明该图片不属于某个数字的话，就把该像素对应该数字的权值设置成负数，相反如果一个像素具有很正面的证据说明该图片属于某个数字，那么该像素对应该数字的权值设置成正值。比如对于数字“0”的图片中间点的像素不应该有黑色（1）像素，如果出现了则表明该图片属于数字0为负面证据，就降低该图片是数字0的概率。这样，经过对数据集的训练和校准，就可以得到14*14（=196）每个像素对应0-9各数字的权重分布。</p><p>我们再将每个数字的分类过程转换成一个M-P神经元，每个神经元都有196个像素输入，每个输入与该神经元之间的权重值由训练得到，这样就构成了一个10个神经元、196个输入以及它们之间1960个带权重的连接线组成的神经网络，如下图示：（一般在神经网络中，会将阈值转换成偏置bias，称为求和项的一项，简化运算过程。）</p><p><img src="https://img.iamghf.top/md/202404241034055.png" alt="perceptron-1.png"></p><p>不过，在实际情况中，有些手写字体存在模棱两可的情况，可能会导致加权求和后，出现两个或两个以上的神经元被激活。因此感知机在实现时引入了激活函数的设计，如下图中的Softmax就是一种激活函数，该函数会对求和值进行处理，抑制概率小的、增强概率大的数字分类。</p><p><img src="https://img.iamghf.top/md/202404241034663.png" alt="perceptron-2.png"></p><p>罗森布拉特又在两年后制造了世界第一台硬件感知机”Mark-1”，该感知机可以识别英文字母，在当时可是引起了巨大轰动。美国国防部和海军军方也注意到了，并给与了大量的资金支撑，罗森布拉特对感知机的自信也达到顶点，甚至有记者问“有没有感知机做不到的事情”，罗森布拉特的回答是“爱、希望、绝望”。罗森布拉特的名气越来越大，而张扬的性格也导致他四处树敌，其中最有名的是人工智能的另一位巨头马文·明斯基。明斯基是达特茅斯会议的组织者，也是人工智能的奠基者之一。1969年，他出版了《感知机》一书，该书明确指出了感知机存在的缺陷。首先是通过数学方法证明了感知机无法处理异或等非线性分类问题，而后又证明了多层感知机的复杂度导致连接数据急剧膨胀而没有合适的训练方法。明斯基在该书出版当年获得了第四届图灵奖，巨大的声望让他对感知机的判断给神经网络研究判了死刑。连接主义备受打击，而符号主义的研究则成为人工智能的主流。</p><p>人工智能领域有两大流派：连接主义和符号主义，有点像武侠小说中的剑宗和气宗，长期以来一直互相竞争。连接主义通过模拟人类的大脑构建神经网络，将知识存储在大量的连接中，基于数据学习来发展人工智能。而符号主义则是认为知识和推理都应该用符号和规则来表示，即大量的“if-then”规则定义，来产生决策和推理，基于规则和逻辑来发展人工智能。前者的代表是神经网络，后者的代表是专家系统。</p><h2 id="三-深度学习"><a href="#三-深度学习" class="headerlink" title="三 深度学习"></a>三 深度学习</h2><p>随着感知机的失败，政府对人工智能领域的投入减少，人工智能进入了第一次寒冬期。而到了八十年代，以专家系统为代表的符号主义成为人工智能的主流，引发了人工智能的第二波浪潮，而神经网络研究被冷落。前文说到，只有一个人还在坚持，那就是杰弗里·辛顿。</p><p>辛顿在前人的基础上，先后发明了玻尔兹曼机和误差反向传播算法，辛顿在神经网络领域的开创贡献给这个领域带来了生机，虽然从上世纪八十年代到本世纪初人工智能领域的主流仍然是知识库和统计分析，神经网络的各项技术也开始突破，其中代表性的如卷积神经网络（CNN）、长短期记忆网络（LSTM）等。到了2006年，辛顿提出深度信念网络，开启了深度学习时代。</p><p>深度学习所对应的神经网络模型称为深度神经网络，这是相对浅层神经网络而言的。对于浅层神经网络而言，一般只有一个隐藏层（或称中间层），加上输入层和输出层，一共就三层。而深度神经网络的隐藏层则不止一层，对比两种神经网络：</p><p><img src="https://img.iamghf.top/md/202404241034380.png" alt="ndnn-dnn-compare.png"></p><p>深度学习之前人们一直聚焦于浅层神经网络的原因是神经网络层数的增加会导致训练难度增加，一方面缺乏足够的算力支撑，另一方面也没有很好的算法。而辛顿提出的深度信念网络则使用误差反向传播算法并通过逐层预训练的方式来解决这一训练难题。在深度信念网络之后，深度神经网络成为机器学习的主流模型，当前热门的GPT、Llama等大模型都是由一种或多种深度神经网络构建而成。</p><p>对于深度神经网络的理解可以参考上文感知机原理的介绍，将深度神经网络看成是多层多个神经元的组合，由前文可以了解，每一层输出结果跟权重、偏置和激活函数有关，而对于深度神经网络的输出还跟层数等数值相关。在深度神经网络中，这些数值可以分为两类，一类是层数、激活函数、优化器等，称为超参数（hyperparameter），它由工程师设定；另一类是权重和偏置，称为参数（parameter），它是在深度神经网络训练过程中自动得到的，寻找到合适的参数就是深度学习的目的。</p><p><img src="https://img.iamghf.top/md/202404241034125.png" alt="deep-learning-1.png"></p><p>但问题是，一个深度神经网络包含了海量的参数，而且修改一个参数将影响其他的参数行为，因此如何找到这些参数的正确取值是个难事。我们要找出参数正确取值，并让模型能够准确输出，那就需要有一个方法能够衡量模型输出与期望输出的差距。因此深度学习训练中使用损失函数（loss function）来衡量，损失函数也被称为目标函数或代价函数。损失函数通过比较深度神经网络的预测值与真实目标值，得到损失值，来表示该神经网络模型在这个训练样本上的效果好坏。</p><p><img src="https://img.iamghf.top/md/202404241034429.png" alt="deep-learning-2.png"></p><p>深度学习的方法是将损失值作为反馈信号，来对参数进行微调，以降低当前样本训练的损失值。实现这种调节的便是优化器，它来实现如梯度下降等优化算法，通过反向传播方式来更新各层神经元节点的参数。</p><p><img src="https://img.iamghf.top/md/202404241034501.png" alt="deep-learning-3.png"></p><p>一开始会对神经网络的参数进行随机赋值，输入一批训练数据，经输入层、隐藏层到输出层，得到网络的预测输出后，根据损失函数计算损失值，这是前向传播过程；然后从输出层开始，反向沿着每一层计算参数的梯度，直到输入层，并根据梯度使用优化算法更新网络的参数，这是反向传播过程。神经网络每处理一批训练样本，参数都会向正确的方向微调，损失值也会减小，这就是训练循环。训练循环足够次数，就可以得到使损失函数最小化的参数，这样就可以得到一个好的神经网络模型。</p><p>当然，实际的深度学习过程比这个要复杂得多，这里只是简要介绍下大概过程。</p><p>2012年时，辛顿带领他的两名学生 Alex Krizhevsky 和 Ilya Sutskever，开发了AlexNet 神经网络，参加 ImageNet 图像识别大赛，结果获得冠军，准确率远远高出第二名。随后辛顿和他的学生成立了DNNResearch公司，专注于深度神经网络的研究。这家公司没有任何产品或资产，但 AlexNet 的成功吸引了几大互联网巨头。2012年冬天，在美国加州和内华达州交界的太浩湖边，一场秘密的竞拍正在进行：被拍卖的对象是刚成立不久的DNNResearch，买家分别是谷歌、微软、DeepMind和百度。最后在谷歌和百度还在竞相抬价时，辛顿叫停了拍卖，选择以4400万美元卖给谷歌。2014年，谷歌又将DeepMind收入囊中。2016年，采用经典蒙特卡洛树搜索和深度神经网络结合的AlphaGo战胜了李世石，次年，又战胜了世界围棋排名第一的柯洁，AlphaGo将人工智能和深度学习推向了一个新的高潮。</p><h2 id="四-大模型"><a href="#四-大模型" class="headerlink" title="四 大模型"></a>四 大模型</h2><p>2015年，马斯克、Stripe的CTO Greg Brockman、YC创投CEO Sam Altman 和 Ilya Sutskever等人在加州的Resewood酒店里会面，商议创建一家人工智能实验室，以对抗大型互联网公司对人工智能技术的控制。接下来，Greg Brockman 又从谷歌、微软等公司邀请来一批研究人员，成立新的实验室，并命名为OpenAI。Greg Brockman、Sam Altman 和 Ilya Sutskever 分别担任 OpenAI的董事长、CEO 和 首席科学家。</p><p>马斯克和 Sam Altman 对 OpenAI 最初的设想是非营利组织，将人工智能技术面向所有人开放，以此对抗大型互联网公司控制人工智能技术而带来的危险性。因为深度学习人工智能技术正在爆炸式的发展，谁也预料不到这项技术在未来会不会形成对人类的威胁，而开放可能是最好的应对方式。而后来2019年OpenAI为了融资发展技术而选择成立盈利子公司，并闭源其核心技术，这是后话。</p><p>2017年，谷歌的工程师发表了一篇论文，名为《Attention is all you need》，在这篇论文中提出了 Transformer 神经网络架构，该架构的特点是将人类的注意力机制引入到了神经网络中。前文说到的图像识别是深度学习中的一种场景，图像数据是离散数据，之间没有关联。而现实生活中还有另外一种场景，就是处理时序型数据，比如文本，文字的上下文是有关联的，还有语音、视频等，都是时序型数据。这种时序型数据叫序列（sequence），并且实际任务中往往是将一个序列转换成另外一个序列，比如翻译，将一段中文翻译成一段英文，还有机器人问答，将一段问题转换成一段智能生成的回答，因此要用到转换器（Transformer），这也是Transformer 名称的由来。前文说到，一个神经元的激发是由它连接的输入数据加权和决定的，权重代表了连接的强度。在时序数据中，每个元素的权重也是不一样的，这跟我们日常生活的经验是一致的，比如看下面这段话：</p><blockquote><p>研表究明，汉字的序顺并不定一能影阅响读，比如当你完看这句话后，才发这现里的字全是都乱的。</p></blockquote><p>不仅是汉字，英语等其他人类语言同样如此。这是因为我们的大脑会自动判断句子里字词的权重，在冗杂的信息里抓中重点，这就是注意力Attention。谷歌工程师将注意力机制引入到神经网络模型中，用于自然语言处理，使得机器可以“理解”人类语言的意图。随后2018年，OpenAI基于Transformer架构发布了GPT-1，2019年发布GPT-2，2020年发布GPT-3，2022年底基于GPT-3.5发布了ChatGPT人工智能问答程序，它的对话能力让人震惊，人工智能也向着AGI方向迈进了一大步。</p><p>GPT全称是 Generative Pre-trained Transformer, Generative 生成式表明它的能力，能够生成新内容，Transformer 是它的基础架构，而中间的 Pre-trained 表明它的训练方式是预训练。为什么叫预训练呢？这是因为，从AlexNet开始，人们为了取得更好的效果，在神经网络训练中开始采用更大的数据和更多的参数，而这也意味着训练的资源和耗时也越来越大。这种成本对于训练特定任务有些高，且不能与其他神经网络共享，有些浪费。因此，业界开始采用一种预训练+微调的方式来训练神经网络模型，即先在较大的数据集上完成通用大模型的训练，然后在具体的任务场景用较小的数据集完成模型微调。ChatGPT采用了基于人类反馈的强化学习（Reinforcement learning from human feedback， RLHF）来进行预训练微调，分成三个步骤：第一步，预训练一个语言模型（LM）；第二步，收集问答数据并训练一个奖励模型（Reward Model，RM）；第三步，用强化学习（RL）方式微调语言模型（LM）。这个奖励模型包含了人工反馈，因此训练过程称为RLHF。</p><p><img src="https://img.iamghf.top/md/202404241034669.jpeg" alt="chatgpt-training-steps.jpeg"></p><p>用户在使用ChatGPT过程中，除了赞叹它的准确度外，还被多轮对话的能力所折服。根据神经网络的底层探析，我们看到每次推理过程是从输入经各神经元加权和激活到输出，是没有记忆能力的。而ChatGPT之所以多轮对话效果好，是因为它在对话管理中使用了Prompt Engineering的技术。</p><p>对于ChatGPT等大语言模型来说，它的输入是经过将一串文字转换的token，而大模型因为计算效率和内存限制，一般会设计固定的上下文窗口，限制输入token的数量。文本首先会被分词器（tokenizer）分词，并通过查表编号，然后embedding到矩阵中变成高维空间向量，这是文本向量化的过程，如下图所示。</p><p><img src="https://img.iamghf.top/md/202404241034867.webp" alt="tokenization-embeding.webp"></p><p>由于token数的限制，因此要在有限的上下文窗口中将更全面的信息告诉大模型，就这需要用到Prompt Engineering提示工程技术。提示工程利用一些策略来优化模型输入，以便让模型产生更符合期望的输出。</p><p>ChatGPT的成功背后是以GPT为代表的大模型的技术演进，OpenAI相信大力出奇迹，不断扩大GPT的参数，GPT-1模型参数有1.17亿，GPT-2模型参数提高到了15亿，GPT-3达到了1750亿，而GPT-4的模型参数据称有1.8万亿。更多的模型参数也就意味着需要更大的算力来支持训练，OpenAI因此总结了“Scaling Law”，称模型的性能与模型大小、数据量和计算资源有关，简单的说就是，模型越大、数据量越大、计算资源越大，模型的性能就越好。强化学习之父Rich Sutton在他的文章《苦涩的教训》(the Bitter Lesson)中也表达了类似的观点，他回顾人工智能近几十年的发展路程，总结说短期内人们总是试图通过构建知识来提升智能体的性能，但长期看强大的算力才是王道。</p><p>大模型的能力也由量变转为质变，谷歌首席科学家Jeff Dean称它为大模型的“涌现能力”(Emergent abilities)。市场看到了这个机会，一方面，各大厂商在大模型投资上呈现军备竞赛之态，另一方面，大模型的开源生态也如火如荼。</p><h2 id="五-Hugging-Face"><a href="#五-Hugging-Face" class="headerlink" title="五 Hugging Face"></a>五 Hugging Face</h2><p>2016年，法国人Clément Delangue、Julien Chaumond和Thomas Wolf成立了一家公司，起名为Hugging Face，并以该emoji图标为公司Logo. Hugging Face最初开发面向年轻人的智能聊天机器人，而后他们在训练模型的过程中开发了些模型训练工具并将它们开源，后来他们甚至调转重心来做后者，这种看似“不务正业”的做法却将他们带入了一个新的赛道，成为了深度学习领域不可或缺的角色。</p><p>硅谷有很多企业都是在副业上做出成就，比如Slack原来开发游戏，公司团队分布多地，在运作过程中开发了一款交流工具结果不小心火了，就是Slack。而Hugging Face的转向也类似，也是为了解决自己的痛点，2018年，谷歌发布了大模型BERT，而Hugging Face的员工便用了他们熟悉的Pytorch框架实现了BERT，将模型取名为pytorch-pretrained-bert，并将它开源到了GitHub。后来在社区的帮助下，又引入了GPT、GPT-2、Transformer-XL等一批模型，该项目便更名为pytorch-transformers。深度学习领域一直存在着两大框架Pytorch和TensorFlow之间的竞争，而研究人员为了比较两个框架的优劣，经常在两个框架间切换，因此该开源项目又增加了两个框架间的切换功能，项目名称也改成了Transformers。Transformers也成了GitHub上增长最快的项目。</p><p>Hugging Face继续开发了并开源了其他一系列的机器学习工具：Datasets、Tokenizer、Diffusers……这些工具也规范了AI开发的流程，在Hugging Face之前，可以说AI开发以研究人员为主，没有一套规范的工程化方法，Hugging Face则提供了完善的AI工具集并建立了一套事实标准，也使得更多的AI开发者甚至是非AI从业者可以快速上手并训练模型。</p><p><img src="https://img.iamghf.top/md/202404241034016.png" alt="huggingface.png"></p><p>接着，Hugging Face又基于Git和Git LFS技术推出了托管模型、数据集、AI应用的Hugging Face Hub，到目前为止，平台上已经托管了35万模型、7.5万数据集和15万个AI应用示例。托管并开源模型和数据集，并建立全球的开源仓库中心这项工作富有创意且意义深远。上文提到，预训练+微调的方式促进了神经网络训练资源的共享，而Hugging Face Hub则更进一步，让AI开发者可以轻松复用全世界最先进的成果，并在此基础上添砖加瓦，让人人使用AI、开发AI的AI民主化成为可能。Hugging Face也被称为是机器学习领域的GitHub，或如他们的Slogan所言：构建未来的AI社区。我之前写过两篇文章，一篇《<a href="https://hutusi.com/articles/the-greatest-git-commit" target="_blank" rel="noopener">改变世界的一次代码提交</a>》介绍Git，一篇《<a href="https://hutusi.com/articles/the-story-of-github-and-gitlab" target="_blank" rel="noopener">从零到百亿美金之路</a>》介绍GitHub，而Git、GitHub、Hugging Face，我觉得它们之间存在某种传承，一种改变世界构建未来的黑客精神的传承，这也是促使我写这篇文章的原因之一。</p><h2 id="六-后记"><a href="#六-后记" class="headerlink" title="六 后记"></a>六 后记</h2><p>在快要写完本文时，我看了辛顿最近在牛津大学做的一次演讲。在演讲中，辛顿介绍了人工智能领域的两大流派，一种辛顿称为逻辑方法，即符号主义；另一种他称之为生物方法，即模拟人类大脑的神经网络连接主义。而事实证明了生物方法明显战胜了逻辑方法。神经网络是模拟人类大脑理解而设计的模型，大模型也像大脑那样的工作和理解。辛顿认为，超越人脑的人工智能在未来会出现，而且会比我们预测的时间快得多。</p><h2 id="附1-大事记"><a href="#附1-大事记" class="headerlink" title="附1 大事记"></a>附1 大事记</h2><p>1943年，麦卡洛克和皮茨发表“M-P神经元模型”，用数理逻辑解释并模拟人脑的计算单元，并提出神经网络这一概念。</p><p>1956年，“人工智能”一词首先在达特茅斯会议上被提出。</p><p>1957年，罗森布拉特提出“感知机”模型，并在两年后成功制造能够识别英文字母的硬件感知机Mark-1.</p><p>1969年，明斯基发表《感知机》，书中指出的感知机缺陷沉重打击了感知机乃至神经网络的研究。</p><p>1983年，辛顿发明玻尔兹曼机。</p><p>1986年，辛顿发明误差反向传播算法。</p><p>1989年，杨立昆(Yann LeCun)发明“卷积神经网络”(CNN)。</p><p>2006年，辛顿提出深度信念网络，开启深度学习时代。</p><p>2012年，辛顿和他的两个学生设计AlexNet在ImageNet大赛中以绝对优势获得冠军，深度学习被业界所重视。</p><p>2015年，Google收购的DeepMind公司推出AlphaGo，2016年战胜李世石，2017年战胜柯洁。OpenAI成立。</p><p>2016年，Hugging Face成立。</p><p>2017年，Google发表Transformer模型论文。</p><p>2018年，OpenAI基于Transformer架构发布了GPT-1。Hugging Face发布 Transformers 项目。</p><p>2019年，OpenAI发布GPT-2。</p><p>2020年，OpenAI发布GPT-3。Hugging Face推出Hugging Face Hub。</p><p>2022年，OpenAI发布ChatGPT。</p><h2 id="附2-参考资料"><a href="#附2-参考资料" class="headerlink" title="附2 参考资料"></a>附2 参考资料</h2><p>书籍：</p><p>《智慧的疆界：从图灵机到人工智能》周志明（著） 机械工业出版社 2018年10月</p><p>《深度学习革命》凯德·梅茨（著） 杜曙光（译） 中信出版社 2023年1月</p><p>《Python深度学习》（第2版） 弗朗索瓦·肖莱（著） 张亮（译） 人民邮电出版社 2022年8月</p><p>《深度学习入门：基于Python的理论与实现》斋藤康毅（著）陆宇杰（译）人民邮电出版社 2018年</p><p>《深度学习进阶：自然语言处理》斋藤康毅（著）陆宇杰（译） 人民邮电出版社 2020年10月</p><p>《这就是ChatGPT》 斯蒂芬·沃尔夫拉姆（著） WOLFRAM传媒汉化小组（译） 人民邮电出版社 2023年7月</p><p>《生成式人工智能》丁磊（著）中信出版社 2023年5月</p><p>《Huggingface自然语言处理详解》李福林（著）清华大学出版社 2023年4月</p><p>文章：</p><p>《神经网络入门》阮一峰</p><p>《2012，改变人类命运的180天》远川研究所</p><p>《GPT家族进化史》MetaPost</p><p>《Transformer - Attention is all you need》知乎</p><p>《预训练语言模型的发展历程》 知乎</p><p>《提示工程指南》</p><p>《ChatGPT 背后的“功臣”——RLHF 技术详解》</p><p>《ChatGPT大模型技术发展与应用》</p><p>《The Bitter Lesson》 Rich Sutton</p><p>《专访HuggingFace CTO：开源崛起、创业故事和AI民主化》</p><p><a href="https://hutusi.com/articles/the-history-of-neural-networks" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chatgpt </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> huggingface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融大模型技术创新与应用探索</title>
      <link href="/20240422001.html"/>
      <url>/20240422001.html</url>
      
        <content type="html"><![CDATA[<h1 id="金融大模型技术创新与应用探索"><a href="#金融大模型技术创新与应用探索" class="headerlink" title="金融大模型技术创新与应用探索"></a>金融大模型技术创新与应用探索</h1><p>大模型时代已来临，每个组织以及每个人的知识体系都需要重塑，思考如何更好地利用 AI 工具提升效率，以应对未来的变化。而始终不变的是，我们要持续学习，时刻保持好奇心，以不变应对未来更多的变化。本文将分享金融行业对大模型技术的探索与实践。</p><p>*<em>主要内容包括以下几大部分 *</em></p><ol><li>从通用大模型到金融大模型</li><li>金融大模型的训练技术创新</li><li>金融大模型的评测方法创新</li><li>金融大模型的应用实践创新</li><li>总结：金融大模型迭代路径</li></ol><h2 id="01-从通用大模型到金融大模型"><a href="#01-从通用大模型到金融大模型" class="headerlink" title="01 从通用大模型到金融大模型"></a>01 从通用大模型到金融大模型</h2><h3 id="1-大模型涌现超预期能力，有望为金融行业创造价值增量"><a href="#1-大模型涌现超预期能力，有望为金融行业创造价值增量" class="headerlink" title="1.大模型涌现超预期能力，有望为金融行业创造价值增量"></a>1.大模型涌现超预期能力，有望为金融行业创造价值增量</h3><p><img src="https://img.iamghf.top/md/202404221354383" alt="图片"></p><p>金融行业具有三大特性：</p><ul><li>数据驱动：金融是一个关于数据的生意，所有的决定都需要通过分析数据来做决策。</li><li>高度知识化密集产业：金融是一个高度知识化密集的行业，有非常多的专业领域知识，不在这一行业中的人是很难知道的。另外，金融内部也有理财、保险、信贷等不同的细分领域，知识结构复杂密集。</li><li>业务流程极其复杂：金融是需要非常多人工去协作的一个产业，业务流程极其复杂。</li></ul><p>这三个特性其实跟大模型本身的逻辑理解记忆等能力是非常匹配的。所以我们一直认为金融领域是一个天然的大模型的最佳应用场景。我们也希望通过探索为金融行业带来更多的价值增量。</p><h3 id="2-通用模型难胜任金融任务，大模型落地金融面临挑战"><a href="#2-通用模型难胜任金融任务，大模型落地金融面临挑战" class="headerlink" title="2.通用模型难胜任金融任务，大模型落地金融面临挑战"></a>2.通用模型难胜任金融任务，大模型落地金融面临挑战</h3><p><img src="https://img.iamghf.top/md/202404221354634" alt="图片"></p><p>我们为什么需要一个金融行业自己的大模型呢？因为当前通用模型的能力还存在缺陷。主要包括以下三个方面：</p><ul><li>金融知识挑战：金融行业有自己领域内的专业知识，比如 KS、MOB、COB 等专业术语，通用大模型可能不了解。</li><li>金融能力挑战：大模型目前还存在幻觉问题、计算准确性问题、遗忘问题等。金融行业是数据驱动的业务，对数据准确性要求比较高，通用大模型存在的这些问题无法满足金融行业的需求。</li><li>应用成本挑战：通用模型的成本相对较高，我们希望通过行业模型去降低应用成本。</li></ul><p>基于以上三个挑战，我们认为做金融领域的行业大模型是非常有必要的。</p><h3 id="3-面对成本挑战，专项增强的领域模型更显高性价比"><a href="#3-面对成本挑战，专项增强的领域模型更显高性价比" class="headerlink" title="3.面对成本挑战，专项增强的领域模型更显高性价比"></a>3.面对成本挑战，专项增强的领域模型更显高性价比</h3><p><img src="https://img.iamghf.top/md/202404221354086" alt="图片"></p><p>上图左边的基础数据源自 meta 论文。可以看到，LLaMA-2 模型训练 2T tokens，用 A100 大概需要多少时间。如果参数是 70B，原论文里写的是需要 172 万卡时，折成 48 台 A100 机器，就需要 187  天，也就是半年的时间，这还是在训练过程中没有任何训练故障，训练效率和效果没有任何反复的情况下的一个时间。假设中间有一些机器发生故障，或者效果不及预期需要迭代，那用 48 台 A100 机器训练，可能就需要一年时间。这个训练成本对于很多企业来讲是极其昂贵的。</p><p>再来看下推理的资源，如果是一个 70B 的大模型，它所需要显卡内存是 129G，也就是需要两张 A100。所以对于大多数企业来讲，通用模型的训练和推理成本是非常高昂的。</p><p>上图右边是行业大厂的一些探索。比如微软有一篇论文提到，一个高质量的领域数据，能够让模型表现出比它参数大五倍的模型相近的效果。这一点很容易理解，如果把大模型当成一个人，一个天赋一般的选手，通过后天的不断努力，并且只专心某一个行业，那他在这个行业取得的成就可能会比天赋好的人更高。比如一个 13B 模型通过不断调优，它在金融领域内某个场景的效果会比通用的 70B  的效果更好。所以我们希望用一个更小的模型，通过不断学习行业知识，达到一个更大模型的效果。</p><h3 id="4-为解决通用模型不胜任问题，自研金融大模型"><a href="#4-为解决通用模型不胜任问题，自研金融大模型" class="headerlink" title="4.为解决通用模型不胜任问题，自研金融大模型"></a>4.为解决通用模型不胜任问题，自研金融大模型</h3><p><img src="https://img.iamghf.top/md/202404221354622" alt="图片"></p><p>为解决上述通用大模型在金融领域的问题，包括成本问题等，我们自研金融大模型。我们对自研模型主要做了以下优化：</p><ul><li>中文增强</li><li>金融增强</li><li>对话增强</li><li>应用增强</li></ul><h2 id="02-金融大模型的训练技术创新"><a href="#02-金融大模型的训练技术创新" class="headerlink" title="02 金融大模型的训练技术创新**"></a>02 金融大模型的训练技术创新**</h2><h3 id="1-为大模型注入专业金融知识，训练专业金融能力"><a href="#1-为大模型注入专业金融知识，训练专业金融能力" class="headerlink" title="1.为大模型注入专业金融知识，训练专业金融能力"></a>1.为大模型注入专业金融知识，训练专业金融能力</h3><p><img src="https://img.iamghf.top/md/202404221354518" alt="图片"></p><p>要提升大模型的金融专业能力，就要从小抓起，在它生命的每一个阶段，注入专业的知识体系。在预训练阶段，增加更丰富的金融语料，提升金融知识储备；在指令微调阶段，也要扩充不同场景的指令；在对齐环节，保证专业的金融数据和标注，满足行业偏好。接下来具体介绍其中的每个部分。</p><ul><li>数据准备：</li></ul><p><img src="https://img.iamghf.top/md/202404221354362" alt="图片"></p><p>数据质量是模型效果的保障。首先数据要丰富，这是必备的条件。我们在这一环节做了非常多的工作，也设计了一套通用的数据流水线。从文本的抽取到数据的清洗，再到最后做一些人工的校验和评估，不断反复迭代。原始的中文数据，通过篇章级的过滤，一直到最后质量模型的排序，大概可以形成 32% 的中文数据。最后，形成了 10TB 的通用语料，加上 1TB 的金融语料。当然我们还在做更多的数据，特别是一些行业领域内专有数据的清洗。</p><ul><li>增量预训练：</li></ul><p>在数据准备完之后，就要去做预训练。需要针对中文场景做词表构建，对此，行业内大概有两种解决方案。一种是通过字粒度去扩充，因为汉字只看一个单词的话相对有限，大概数量是 5K 到 8K。另外一种就是很多中文大模型所采用的方法，即大量引入中文词汇，这样词表会比较大。考虑到对原有模型要尽量减少破坏，所以我们最终采用了字粒度扩容的方式，加入了 7K 的中文字符。这使得我们的整个词表大小达到 39K，词表压缩率为 48%。</p><p>在预训练阶段词表优化完之后，训练采用的是两阶段的优化方式，使得收敛更加稳定。第一阶段主要还是解决新加词表的泛化能力，我们仅更新模型词表的 embedding 以及解码线性层，使模型能够适应新的词表。在整个过程中，数据分布与原始的数据分布基本是一致的，就是为了保证模型的稳定性。在训练过程中我们发现，通过少量数据，能够使模型的 loss 达到平稳。所以第一阶段只训练了 40B 的 token。第二阶段对模型进行全量的更新，这时会训练大量的中文语料和英文语料。在这一阶段，我们训练了 300B 的 token。</p><p><img src="https://img.iamghf.top/md/202404221354169" alt="图片"></p><p>数据配比直接影响基座模型的训练质量。开始时整体的中英语料是 3 比 1。在英文数据上，一开始仅加入了少量的金融数据。随着整个训练过程的不断优化，金融数据的比例也越来越高。在训练过程中，要保证原有的英文能力。</p><ul><li>指令微调：SFT 数据的丰富性和多样性直接影响对齐效果。在数据生成上，分为通用数据生成和金融专业领域数据生成。整体配比大概是 4 比 1。我们通过不同方式的自动生成以及人工改写，最后生成一个包含许多种类的 SFT 数据结果。</li></ul><p><img src="https://img.iamghf.top/md/202404221354593" alt="图片"></p><p>采用两阶段指令微调，保证通用能力的同时，提升金融问答能力。第一阶段是通过混合微调，用海量开源指令数据，同时加入一些预训练数据，保证其泛化性，并且可以有效减少幻觉问题。第二阶段是通过高质量的指令微调数据，提升整体的对话能力。整体的训练方式与预训练是一致的。</p><h3 id="2-价值对齐：通过强化学习对齐价值偏好"><a href="#2-价值对齐：通过强化学习对齐价值偏好" class="headerlink" title="2.价值对齐：通过强化学习对齐价值偏好"></a>2.价值对齐：通过强化学习对齐价值偏好</h3><p>接下来要做的是价值对齐，就是使模型的三观与我们一致，我们使用强化学习技术来对齐价值偏好。首先基于人类反馈做 reward model，这里我们选择 pair wise 的方式，并通过大量的人工标注排序。之后用 PPO  算法进行优化。未来，价值对齐会是做大模型非常核心的一个壁垒。</p><h3 id="3-应用增强：升级系统工程，弥补大模型本身能力欠缺"><a href="#3-应用增强：升级系统工程，弥补大模型本身能力欠缺" class="headerlink" title="3.应用增强：升级系统工程，弥补大模型本身能力欠缺"></a>3.应用增强：升级系统工程，弥补大模型本身能力欠缺</h3><p><img src="https://img.iamghf.top/md/202404221354735" alt="图片"></p><p>在数据微调以及价值对齐后，非常重要的一点是大模型与应用相结合、相绑定，因为所有模型的构建都是为了解决企业实际的问题。为了更好地为业务服务，需要提升大模型的整体能力，比如计算能力、多轮对话以及分析的能力等等。</p><h3 id="4-工程优化：大模型训练效率面临诸多瓶颈"><a href="#4-工程优化：大模型训练效率面临诸多瓶颈" class="headerlink" title="4.工程优化：大模型训练效率面临诸多瓶颈"></a>4.工程优化：大模型训练效率面临诸多瓶颈</h3><p><img src="https://img.iamghf.top/md/202404221355489" alt="图片"></p><p>当前算力带宽的发展与模型参数的扩大是不匹配的。如何通过技术手段解决这一问题，是一个关键瓶颈，在这方面当时我们也做了很多探索。</p><ul><li>突破内存与计算墙，提高训练吞吐。比如提升 batch size，优化模型占用显存的比例。通用的方式是 ZERO 的方式。在实践过程中，我们根据不同的方法来做不同的适配，并做不同算子的优化。通过优化，显存占用比例降低了 87%，batch size 提升了三倍，整体的训练吞吐能力提升了 36%。另外是计算复杂度，行业内用的比较多的是 Flash Attention，我们优化了很多底层算子，使用效率也有大幅提升。充分优化后，整体的训练吞吐比原来提升了 26%。</li><li>打破带宽墙，提升分布式效率。除了前面讲的内存以及计算复杂度的优化，另外一个重点是通讯效率的优化。通讯效率的优化包括算法和硬件两方面。算法方面，通过不同的算法提升 IO 效率，在金融行业用的比较多。另外在硬件上也可以做非常多的优化。目前我们搭了一个高速的网络，最高能支持八千多张卡，单机吞吐 800G。整体训练效率提升了三倍。另外，在做 GPU 分布式优化的时候，一个关键指标就是随着集群规模的扩大，单卡的 ROI 是否有折损。因为随着集群的扩大，通讯会变得越来越复杂，一个单卡的效率会变低。我们在 512 张卡以上规模的集群，整体的吞吐加速比基本是线性的，在 640 张卡下仍然可以达到 94%。</li></ul><h2 id="03-金融大模型的评测方法创新"><a href="#03-金融大模型的评测方法创新" class="headerlink" title="03 金融大模型的评测方法创新"></a>03 金融大模型的评测方法创新</h2><p>对于大模型来说，评估体系是非常重要的。如何设计考察的内容和题目，是至关重要的一个工作。</p><h3 id="1-大模型评测难题：主流榜单可靠性受质疑力"><a href="#1-大模型评测难题：主流榜单可靠性受质疑力" class="headerlink" title="1.大模型评测难题：主流榜单可靠性受质疑力"></a>1.大模型评测难题：主流榜单可靠性受质疑力</h3><p><img src="https://img.iamghf.top/md/202404221355842" alt="图片"></p><p>现在国内很多榜单是公开的，但是确实只能作为参考，不是说它没有意义，它起到了指引方向的作用。但在做大模型的过程中，要明晰大模型的每一个环节，明确每一步大模型能力的目标。如果训练一个模型，过了很长时间到结尾的时候才看到它的效果不佳，再去返工，那么造成的损失会是非常巨大的。</p><h3 id="2-拒绝榜单绑架，用评测指引模型优化方向"><a href="#2-拒绝榜单绑架，用评测指引模型优化方向" class="headerlink" title="2.拒绝榜单绑架，用评测指引模型优化方向"></a>2.拒绝榜单绑架，用评测指引模型优化方向</h3><p><img src="https://img.iamghf.top/md/202404221355097" alt="图片"></p><p>我们自己的评估体系是横评看差距，纵评看提升。横评是在每个环节看不同模型在各个项目上的优劣。纵评是看同一模型在不同阶段、不同版本，甚至不同优化方式下的效果。</p><h3 id="3-预训练阶段：评测指标走势判断是否符合预期"><a href="#3-预训练阶段：评测指标走势判断是否符合预期" class="headerlink" title="3.预训练阶段：评测指标走势判断是否符合预期"></a>3.预训练阶段：评测指标走势判断是否符合预期</h3><p><img src="https://img.iamghf.top/md/202404221355397" alt="图片"></p><p>针对每个环节，我们也做了非常多的评测体系。首先是通用知识的预训练环节，有多维度的自动评测集。除了看 loss 之外，还会看其他 NLP 相关评测指标。也会看它在新的未知数据下的 PPL。对于每个评测指标，会在整个训练过程中进行实时地监控。</p><h3 id="4-微调阶段：全面评估大模型“涌现”出的新能力"><a href="#4-微调阶段：全面评估大模型“涌现”出的新能力" class="headerlink" title="4.微调阶段：全面评估大模型“涌现”出的新能力"></a>4.微调阶段：全面评估大模型“涌现”出的新能力</h3><p><img src="https://img.iamghf.top/md/202404221355302" alt="图片"></p><p>在微调阶段，因为有对话测评，所以除了自动化的评估之外，也需要更多的人工介入。我们制定了非常多的人工评测方法，以保证整个对话的效果是完全符合预期的。</p><h3 id="5-强化阶段：评估相较微调阶段是否有能力提升"><a href="#5-强化阶段：评估相较微调阶段是否有能力提升" class="headerlink" title="5.强化阶段：评估相较微调阶段是否有能力提升"></a>5.强化阶段：评估相较微调阶段是否有能力提升</h3><p><img src="https://img.iamghf.top/md/202404221355820" alt="图片"></p><p>在强化阶段，主要是看两方面的标准，一方面经过强化学习之后，模型本身能力不能下降；另一方面是在安全性、有用性和稳定性这三个指标上要有明显提升，保证整个强化阶段达到预期。</p><h3 id="6-从模型训练到场景落地：像评测人一样测评大模型"><a href="#6-从模型训练到场景落地：像评测人一样测评大模型" class="headerlink" title="6.从模型训练到场景落地：像评测人一样测评大模型"></a>6.从模型训练到场景落地：像评测人一样测评大模型</h3><p><img src="https://img.iamghf.top/md/202404221355533" alt="图片"></p><p>无论是从大模型整体的训练，还是从大模型评测，我们都要像看人一样去看它。我们希望能够构建一个更加丰富完善的评测体系，去评估出大模型的各项能力，整个体系也在不断优化中。</p><h2 id="04-金融大模型的应用实践创新"><a href="#04-金融大模型的应用实践创新" class="headerlink" title="04 金融大模型的应用实践创新"></a>04 金融大模型的应用实践创新</h2><p>最后介绍一下金融行业大模型应用方面的探索。</p><h3 id="1-营销：个性化素材结合差异产品，重塑开放获客新模式"><a href="#1-营销：个性化素材结合差异产品，重塑开放获客新模式" class="headerlink" title="1.营销：个性化素材结合差异产品，重塑开放获客新模式"></a>1.营销：个性化素材结合差异产品，重塑开放获客新模式</h3><p><img src="https://img.iamghf.top/md/202404221355317" alt="图片"></p><p>第一个是通过大模型的生产能力，使营销获客的效率大幅提升。获客是所有行业的一大难点。之前我们很难做到差异化的获客，因为要给用户展示不同的文案广告，要实时获取用户的需求，特别像文案广告这种内容，如果是通过设计师去做的话，可能需要几小时或者天级。而通过大模型，可以实时地获取用户画像，然后实时地生成用户所需的内容。</p><h3 id="2-服务：体质降本，营销服务一体化"><a href="#2-服务：体质降本，营销服务一体化" class="headerlink" title="2.服务：体质降本，营销服务一体化"></a>2.服务：体质降本，营销服务一体化</h3><p><img src="https://img.iamghf.top/md/202404221355931" alt="图片"></p><p>第二个应用场景是服务。传统的机器人很难做到人与机器自然地交流。大模型出来之后，提高了对话能力的天花板。之前做不到的事情，现在能做到了。未来人与机器的自然交流成为了可能。我们在这方面也做了很多探索，比如让大模型辅助人工客服，获得了 25% 的提效。</p><p>另外，我们也找了一些简单的小场景，让大模型全面替代人工客服，当然在保证质量的同时，不能有客诉。未来大模型会为企业整体的效率提升和成本降低带来大幅改善。</p><h3 id="3-运营：数据驱动的业务运营新范式"><a href="#3-运营：数据驱动的业务运营新范式" class="headerlink" title="3.运营：数据驱动的业务运营新范式"></a>3.运营：数据驱动的业务运营新范式</h3><p><img src="https://img.iamghf.top/md/202404221355151" alt="图片"></p><p>第三个应用是运营。因为金融行业是一个数据驱动的行业，每天要做非常多的经济指标统计、业务指标统计、报表分析，并基于此做各种预测。分析预测的质量取决于数据科学家，而数据科学家能力不一，结果可能存在差异，因此需要大量的数据对齐和认知对齐工作。如果利用大模型，能够统一标准，从而大幅提升决策效率。</p><h3 id="4-办公：无处不在、无缝衔接的办公助手"><a href="#4-办公：无处不在、无缝衔接的办公助手" class="headerlink" title="4.办公：无处不在、无缝衔接的办公助手"></a>4.办公：无处不在、无缝衔接的办公助手</h3><p><img src="https://img.iamghf.top/md/202404221355487" alt="图片"></p><p>第四个应用是智能办公。大模型能够提升员工获取知识的效率，帮助每一个员工提升个人角色的能力。当你到一家新公司，一个新行业，很多知识是不知道的，这时就可以直接咨询辅助助手，获得详细的专业知识，帮助你快速进入角色。</p><h3 id="5-风控：提升感知和决策能力，智能风控更主动更实时"><a href="#5-风控：提升感知和决策能力，智能风控更主动更实时" class="headerlink" title="5.风控：提升感知和决策能力，智能风控更主动更实时"></a>5.风控：提升感知和决策能力，智能风控更主动更实时</h3><p><img src="https://img.iamghf.top/md/202404221355929" alt="图片"></p><p>最后要讲的应用场景是风控，这是与金融强相关的一个场景。风险控制是金融领域的核心问题之一，而风险本身是一个决策问题，通过大模型，可以将其理解和处理数据的能力与原有的决策式风控相结合，使风控能力得到进一步加强。</p><h2 id="05-总结：金融大模型迭代路径"><a href="#05-总结：金融大模型迭代路径" class="headerlink" title="05 总结：金融大模型迭代路径"></a>05 总结：金融大模型迭代路径</h2><p><img src="https://img.iamghf.top/md/202404221356070" alt="图片"></p><p>最后对前面的介绍做一个简单的总结，介绍一下大模型的迭代路径。大模型的迭代应该是模型训练与评估应用双轮驱动，持续迭代的。就像我们每个员工一样，在你的工作场景中要持续地学习创新，保持好奇心，得到工作反馈，再根据反馈不断进步。</p><p><a href="https://mp.weixin.qq.com/s/AdAd0mK1DCSdQDAROFIkIg" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP多版本对比</title>
      <link href="/20240418001.html"/>
      <url>/20240418001.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP多版本对比"><a href="#HTTP多版本对比" class="headerlink" title="HTTP多版本对比"></a>HTTP多版本对比</h1><p>上个世纪90年代初期，蒂姆·伯纳斯-李（Tim Berners-Lee）及其 CERN的团队共同努力，制定了互联网的基础，定义了互联网的四个构建模块：</p><ul><li>超文本文档格式（HTML）</li><li>数据传输协议（HTTP）</li><li>用于查看超文本的网络浏览器（第一个浏览器，WorldWideWeb）</li><li>用于传输数据的服务器（httpd的早期版本）</li></ul><p>HTTP重用了现有的 TCP/IP 协议来进行数据传输，其中 HTTP 消息字节位于应用层，如下图中的浅蓝色所示。</p><p><img src="https://img.iamghf.top/md/202404181033107" alt="http"></p><h2 id="1、HTTP-0-9"><a href="#1、HTTP-0-9" class="headerlink" title="1、HTTP/0.9"></a>1、HTTP/0.9</h2><p>这是第一个 HTTP草案。它只有一个 GET方法，也不支持头部或状态代码；唯一可用的数据格式是 HTML。就像 HTTP/1.0和 HTTP/1.1一样，HTTP消息以 ASCII文本结构呈现。</p><p>HTTP/0.9请求的示例：</p><pre class=" language-http"><code class="language-http">GET /mypage.html</code></pre><p>响应示例：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>A verysimple HTML page<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="2、HTTP-1-0"><a href="#2、HTTP-1-0" class="headerlink" title="2、HTTP/1.0"></a>2、HTTP/1.0</h2><p>这个版本定义了现在所用的 HTTP结构，类似于一份备忘录，同时引入了新的方法（HEAD和POST）、MIME类型、状态码和协议版本。</p><p>HTTP/1.0请求的示例：</p><pre class=" language-http"><code class="language-http">GET /mypage.html HTTP/1.0User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)</code></pre><p>响应示例：</p><pre class=" language-http"><code class="language-http">200 OK<span class="token header-name keyword">Date:</span> Tue, 15 Nov 1994 08:12:31 GMT<span class="token header-name keyword">Server:</span> CERN/3.0 libwww/2.17<span class="token header-name keyword">Content-Type:</span> text/html&lt;HTML>A page with an image&lt;IMG SRC="/myimage.gif"/>&lt;/HTML></code></pre><h2 id="3、HTTP-1-1"><a href="#3、HTTP-1-1" class="headerlink" title="3、HTTP/1.1"></a>3、HTTP/1.1</h2><p><strong>这个版本于1997年初推出，距离其前身只有几个月。主要变化包括：</strong></p><ul><li><p>持久的TCP连接（keep-alive），可以节省机器和网络资源。在之前的版本中，每个请求都要打开一个新的TCP连接，并在响应后关闭。</p></li><li><p>Host头部，支持在同一个IP下有多个服务器。</p></li><li><p>有关编码、缓存、语言和MIME类型的头部约定。</p></li></ul><p>HTTP/1.1请求的示例：</p><pre class=" language-http"><code class="language-http">GET /api/fruit/orange HTTP/1.1<span class="token header-name keyword">Host:</span> www.fruityvice.com<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate, br</code></pre><p>响应示例：</p><pre class=" language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span><span class="token header-name keyword">Server:</span> nginx/1.16.1<span class="token header-name keyword">Date:</span> Sun, 10 Mar 2024 20:44:25 GMT<span class="token header-name keyword">Transfer-Encoding:</span> chunked<span class="token header-name keyword">Connection:</span> keep-alive<span class="token header-name keyword">X-Content-Type-Options:</span> nosniff<span class="token header-name keyword">X-XSS-Protection:</span> 1; mode=block<span class="token header-name keyword">Cache-Control:</span> no-store, must-revalidate, no-cache,max-age=0<span class="token header-name keyword">Pragma:</span> no-cache<span class="token header-name keyword">X-Frame-Options:</span> DENY<span class="token header-name keyword">Content-Type:</span> application/json<span class="token header-name keyword">Expires:</span> 0{"name":"Orange","id":2,"family":"Rutaceae","order":"Sapindales","genus":"Citrus","nutritions":{"calories":43,"fat":0.2,"sugar":8.2,"carbohydrates":8.3,"protein":1.0}}</code></pre><p><img src="https://img.iamghf.top/md/202404181039427" alt="http/1.1"></p><h2 id="4、HTTP-2"><a href="#4、HTTP-2" class="headerlink" title="4、HTTP/2"></a>4、HTTP/2</h2><p><strong>2015年，在对互联网性能进行多年观察和研究后，人们基于谷歌的 SPDY协议，提出并建立了 HTTP/2。</strong></p><p>它与 HTTP/1.1有很多不同，包括将多个消息复用到单个 TCP数据包中、消息的二进制格式以及用于头部的 HPACK压缩。</p><p>在 HTTP/1.1中，两个请求不能共享同一个 TCP连接，必须等待第一个请求结束后才能开始后续请求。这被称为头部阻塞。在下面的图表中，由于只使用了一个 TCP连接，请求2必须等到响应1到达之后才能发送。</p><p><img src="https://img.iamghf.top/md/202404181041290" alt="http/1.1"></p><p>HTTP/2通过流（stream）解决了这个问题，每个流对应一个消息。许多流可以交错在单个 TCP数据包中。如果某个流由于某种原因无法发送其数据，其他流可以在 TCP数据包中顶替它。</p><p>HTTP/2的流被分成帧（frame），每个帧包含：帧类型、它所属的流以及长度（以字节为单位）。在下面的图表中，彩色矩形是一个 TCP数据包，✉ 代表其中的一个 HTTP/2帧。第一个和第三个 TCP数据包携带了不同流的帧。</p><p><img src="https://img.iamghf.top/md/202404181042261" alt="http/2"></p><p>下面的图像展示了帧如何放置在 TCP数据包中。流1携带了一个 JavaScript文件的 HTTP响应，而流2携带了一个 CSS文件的 HTTP响应。</p><p><img src="https://img.iamghf.top/md/202404181042581" alt="http"></p><h2 id="5、HTTP-3"><a href="#5、HTTP-3" class="headerlink" title="5、HTTP/3"></a>5、HTTP/3</h2><p>HTTP/3诞生于一个名为 QUIC的新传输协议，该协议由谷歌于2012年创建。QUIC被封装在 UDP内，与 TCP相比，它有以下优点：</p><ul><li>建立连接和TLS身份验证的往返包数量更少；</li><li>在处理数据包丢失方面具有更强的连接韧性；</li><li>解决了TCP和TLS中存在的头部阻塞问题。</li></ul><p>HTTP/2解决了 HTTP头部阻塞问题，但是，这个问题在 TCP和  TLS中也存在。TCP认为它需要发送的数据是一系列连续的数据包，如果有任何数据包丢失，必须重新发送，以保持信息的完整性。在  TCP中，直到丢失的数据包成功重新发送到目的地之前，后续的数据包都不能被发送。</p><p>下面的图示直观地解释了在 HTTP/2中这种情况是如何发生的。第二个数据包只包含了响应1的帧，但是它的丢失延迟了响应1和响应2，这意味着在这种情况下没有并行处理。</p><p><img src="https://img.iamghf.top/md/202404181043827" alt="http/2"></p><p>为了解决 TCP的头部阻塞问题，QUIC决定使用 UDP作为传输协议，因为UDP不保证到达。在TCP中作为传输层的数据完整性责任被移至QUIC的应用层，消息的帧可以无序到达，而不会阻塞不相关的流。</p><p><img src="https://img.iamghf.top/md/202404181045124" alt="http/3"></p><p><img src="https://img.iamghf.top/md/202404181052017" alt="quic"></p><p>与 TCP相关的 TLS（SSL）中的头部阻塞是因为加密通常应用于整个消息内容，这意味着需要接收所有数据之后才能进行解密。使用 QUIC时，加密是针对每个 QUIC数据包的，到达时就可以进行解密，而无需预先接收所有数据包。</p><p>带有 TLS的 TCP：</p><ol><li>输入：A+B+C</li><li>加密：crypt(A+B+C) = D+E+F</li><li>数据包：D, E, F</li><li>接收：decrypt(D+E+F)</li><li>A+B+C</li></ol><p>带有TLS的QUIC：</p><ol><li>输入：A+B+C</li><li>加密：crypt(A) = X, crypt(B) = Y, crypt(C) = Z</li><li>包：X, Y, Z</li><li>接收：decrypt(X) + decrypt(Y) + decrypt(Z)</li><li>A+B+C</li></ol><h2 id="6、比较表"><a href="#6、比较表" class="headerlink" title="6、比较表"></a>6、比较表</h2><p><img src="https://img.iamghf.top/md/202404181045178" alt="http对比"></p><p>* TLS 1.2需要2次往返进行加密握手，而 TLS 1.3只需要1次，还有 0-RTT（零往返时间恢复）选项，其中不需要先前的握手。然而，0-RTT会导致重放攻击，因此是不安全的。</p><p>** QUIC的连接 ID可能被用于指纹识别，一项研究指出，这存在对用户隐私的风险。</p><h2 id="7、哪个版本最好？"><a href="#7、哪个版本最好？" class="headerlink" title="7、哪个版本最好？"></a>7、哪个版本最好？</h2><p>目前最好的两个版本是 HTTP/2和 HTTP/3。</p><p>HTTP/3是为不稳定的连接设计的，例如手机和卫星网络。为了应对网络不稳定性，QUIC在数据流之间具有很高的独立性，并且在丢包时具有很好的弹性。然而，HTTP/3也存在性能损失，主要是因为1）由于 UDP的使用率较低，路由器和操作系统在过去几十年里没有对 UDP协议进行优化，使其相对于  TCP而言速度较慢；2）QUIC使用逐个数据包的加密需要更多的数学运算，效率低于  TCP中使用的整个消息加密。此外，UDP协议在某些网络中受到限制，以防止诸如 UDP洪水攻击和 DNS放大攻击等攻击。</p><p>在可靠和稳定的连接上，HTTP/2通常比 HTTP/3提供更好的性能。</p><p>一般来说，建议进行兼容性和性能测试，以确定哪个版本最合适。此外，服务器可以接受 HTTP/2和 HTTP/3连接，让客户端决定使用哪个版本。</p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> QUIC </tag>
            
            <tag> tcp/ip </tag>
            
            <tag> udp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据中台知识体系总结</title>
      <link href="/20240415002.html"/>
      <url>/20240415002.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据中台知识体系总结"><a href="#数据中台知识体系总结" class="headerlink" title="数据中台知识体系总结"></a>数据中台知识体系总结</h1><p>当前，大部分企业不再建设从源数据采集到分析应用的烟囱式系统，更倾向于数据集中式采集、存储，并应用分层建设。这种方式一方面有利于应用系统的快速部署，另一方面也保证数据的集中管理与运营，体现数据的资产、资源属性。笔者根据个人数据中台的工作实践和学习以及思考总结，撰写成本文数据中台知识体系，供参考交流。</p><h2 id="一、数据中台是什么"><a href="#一、数据中台是什么" class="headerlink" title="一、数据中台是什么"></a>一、数据中台是什么</h2><h3 id="01-定义"><a href="#01-定义" class="headerlink" title="01 定义"></a>01 定义</h3><p>数据中台是一套可持续“让企业的数据用起来”的机制，是一种战略选择和组织形式，是依据企业特有的业务模式和组织架构，通过有形的产品和实施方法论支撑，构建的一套持续不断把数据变成资产并服务于业务的机制。</p><p>数据中台是处于业务前台和技术后台的中间层，是对业务提供的数据能力的抽象和共享的过程，数据中台通过将企业的数据变成数据资产，并提供数据能力组件和运行机制，形成聚合数据接入、集成、清洗加工、建模处理、挖掘分析，并以共享服务的方式将数据提供给业务端使用，从而与业务产生联动，而后结合业务系统的数据生产能力，最终构建数据生产&gt;消费&gt;再生的闭环，通过这样持续使用数据、产生智能、反哺业务从而实现数据变现的系统和机制。</p><p><img src="https://img.iamghf.top/md/202404151422797" alt="图片"></p><h3 id="02-本质"><a href="#02-本质" class="headerlink" title="02 本质"></a>02 本质</h3><p>数据中台服务于数字化转型，而企业数字化转型的终局是传统业务变成数字化业务，数字化业务的本质就是以数据作为新生产要素进行加工，构建以数据作为主要存在形式的产品，产生商业价值的业务模型。</p><p>因此数据中台的本质更像一种企业架构，是一套互联网技术和行业特性，在企业发展的不确定性中，寻找确定性，并且持续沉淀和提炼企业核心能力，最终支持企业快速、高效、低成本进行业务创新和增强的企业架构。</p><h3 id="03-数据中台、数仓、大数据平台的区别"><a href="#03-数据中台、数仓、大数据平台的区别" class="headerlink" title="03 数据中台、数仓、大数据平台的区别"></a>03 数据中台、数仓、大数据平台的区别</h3><h4 id="1）数据中台-vs-数据仓库"><a href="#1）数据中台-vs-数据仓库" class="headerlink" title="1）数据中台 vs 数据仓库"></a>1）数据中台 vs 数据仓库</h4><p>数据仓库的主要场景是支持管理决策和业务分析，而数据中台则是将数据服务化之后提供给业务系统，目标是将数据能力渗透到各个业务环节，不限于决策分析类场景。数据中台持续不断地将数据进行资产化、价值化并应用到业务，而且关注数据价值的运营。</p><p>数据中台建设包含数据体系建设，也就是数据中台包含数据仓库的完整内容，数据中台将企业数据仓库建设的投入价值进行最大化，以加快数据赋能业务的速度，为业务提供速度更快、更多样的数据服务。数据中台也可以将已建好的数据仓库当成数据源，对接已有数据建设成果，避免重复建设。当然也可以基于数据中台提供的能力，通过汇聚、加工、治理各类数据源，构建全新的离线或实时数据仓库。</p><h4 id="2）数据中台-vs-大数据平台"><a href="#2）数据中台-vs-大数据平台" class="headerlink" title="2）数据中台 vs 大数据平台"></a>2）数据中台 vs 大数据平台</h4><p>大数据基础能力层：Hadoop、Spark、Hive、HBase、Flume、Sqoop、Kafka、Elasticsearch等。在大数据组件上搭建的ETL流水线，包括数据分析、机器学习程序。数据治理系统。数据仓库系统。数据可视化系统。</p><p>数据中台应该是大数据平台的一个超集。在大数据平台的基础之上，数据中台还应该提供下面的系统功能：</p><ul><li><p>全局的数据应用资产管理</p></li><li><p>全局的数据治理机制</p></li><li><p>自助的、多租户的数据应用开发及发布</p></li><li><p>数据应用运维</p></li><li><p>数据应用集成</p></li><li><p>数据即服务，模型即服务</p></li><li><p>数据能力共享管理</p></li><li><p>完善的运营指标</p></li></ul><h2 id="二、数据中台核心能力"><a href="#二、数据中台核心能力" class="headerlink" title="二、数据中台核心能力"></a>二、数据中台核心能力</h2><p>数据中台需要具备数据<strong>汇聚整合、数据提纯加工、数据服务可视化、数据价值变现</strong>４个核心能力，让企业员工、客户、伙伴能够方便地应用数据。</p><h3 id="1-汇聚整合（数据治理-数据整合和管理能力）"><a href="#1-汇聚整合（数据治理-数据整合和管理能力）" class="headerlink" title="1. 汇聚整合（数据治理-数据整合和管理能力）"></a>1. 汇聚整合（数据治理-数据整合和管理能力）</h3><ul><li>数据丰富和完善：多样的数据源进行合并和完善</li><li>管理易用：可视化任务配置、丰富的监控管理功能</li><li>数据集成运营：数据接入、转换、写入或缓存内部来源的各来源数据</li><li>数据目录与治理：用户可以方便定位所需数据，理解数据（技术/业务治理）</li><li>数据安全：确保数据的访问权限</li><li>数据可用：用户可简便、可扩展的访问异构数据，可用性和易用性高</li><li>部署灵活：本地、公有云、私有云等多种部署方式</li></ul><p><img src="https://img.iamghf.top/md/202404151425388" alt="图片"></p><h3 id="2-提纯加工（数据资产化——数据提炼与分析加工能力）"><a href="#2-提纯加工（数据资产化——数据提炼与分析加工能力）" class="headerlink" title="2. 提纯加工（数据资产化——数据提炼与分析加工能力）"></a>2. 提纯加工（数据资产化——数据提炼与分析加工能力）</h3><ul><li>完善的安全访问控制</li><li>完善的数据质量保障体系</li><li>规范的、紧密结合业务的可扩展的标签体系</li><li>面向业务主题的资产平台</li><li>智能的数据映射能力，简化数据资产生成</li></ul><p><img src="https://img.iamghf.top/md/202404151425034" alt="图片"></p><h3 id="3-服务可视化（数据资产服务化能力）"><a href="#3-服务可视化（数据资产服务化能力）" class="headerlink" title="3. 服务可视化（数据资产服务化能力）"></a>3. 服务可视化（数据资产服务化能力）</h3><ul><li>提供自然语言等人工智能服务</li><li>提供丰富的数据分析功能</li><li>提供友好的数据可视化服务</li><li>便捷、快速的服务开发环境，方便业务人员开发数据应用</li><li>提供实时流数据分析</li><li>提供预测分析、机器学习等高级服务</li></ul><p><img src="https://img.iamghf.top/md/202404151425986" alt="图片"></p><h3 id="4-价值变现"><a href="#4-价值变现" class="headerlink" title="4. 价值变现"></a>4. 价值变现</h3><ul><li>提供数据应用的管理能力</li><li>提供数据洞察直接驱动业务行动的通路</li><li>提供跨行业务场景的能力</li><li>提供跨部门的普适性业务价值能力</li><li>提供基于场景的数据应用</li><li>提供业务行动效果评估功能</li></ul><p><img src="https://img.iamghf.top/md/202404151425135" alt="图片"></p><h2 id="三、数据中台的价值"><a href="#三、数据中台的价值" class="headerlink" title="三、数据中台的价值"></a>三、数据中台的价值</h2><p>数据中台价值如下：</p><p><img src="https://img.iamghf.top/md/202404151426411" alt="图片"></p><h3 id="1）业务价值（业务创新，形成核心壁垒）"><a href="#1）业务价值（业务创新，形成核心壁垒）" class="headerlink" title="1）业务价值（业务创新，形成核心壁垒）"></a>1）业务价值（业务创新，形成核心壁垒）</h3><p>1、以客户为中心，用洞察驱动企业稳健行动</p><p>2、以数据为基础，直系大规模商业模式创新</p><p>3、盘活全量数据，构筑坚实壁垒已持续领先</p><h3 id="2）技术价值（成本低、能力多、应用广）"><a href="#2）技术价值（成本低、能力多、应用广）" class="headerlink" title="2）技术价值（成本低、能力多、应用广）"></a>2）技术价值（成本低、能力多、应用广）</h3><p>1、应对多数据处理的需求</p><p>2、丰富标签数据，减低管理成本</p><p>3、数据价值能体现业务系统效果而不仅是准确度</p><p>4、支持跨主题域访问数据</p><p>5、数据可以快速复用、不仅是复制</p><p>总结：数据中台是把业务生产资料转变为数据生产力，同时数据生产力反哺业务，不断迭代循环的闭环过程——数据驱动决策、运营。</p><h2 id="四、数据中台要解决什么问题"><a href="#四、数据中台要解决什么问题" class="headerlink" title="四、数据中台要解决什么问题"></a>四、数据中台要解决什么问题</h2><h3 id="1-指标口径不一致"><a href="#1-指标口径不一致" class="headerlink" title="1. 指标口径不一致"></a>1. 指标口径不一致</h3><p>通常表现在3个方面：业务口径不一致、计算逻辑不一致、数据来源不一致。</p><ul><li><p>业务口径不一致：业务口径不一致的指标，应该要有不同的标识去区分，比如上面提到的销售额这一指标，明明口径是不一致的，但却没有区分，容易让业务误解。</p></li><li><p>计算逻辑不一致：业务口径的描述往往是一段话，但对于一些计算逻辑比较复杂的指标，一段话通常是描述不清楚的，如果碰巧两个相同业务口径的指标是不同的数据研发实现的，极有可能会出现计算逻辑不一致的情况。</p></li><li><p>数据来源不一致：对于部分指标，有多个数据源可供选择，如果数据源正好有些细微差异不被发现时，即使加工逻辑一样，也有可能结果不一致。另外，实时数据和离线数据也会有一定差异。</p></li></ul><p>因此，要实现一致性，就要确保对同一个指标，只有一个业务口径，只加工一次，且数据来源必须一致。</p><h3 id="2-烟囱式建设数据平台，大量源被浪费，响应速度慢"><a href="#2-烟囱式建设数据平台，大量源被浪费，响应速度慢" class="headerlink" title="2. 烟囱式建设数据平台，大量源被浪费，响应速度慢"></a>2. 烟囱式建设数据平台，大量源被浪费，响应速度慢</h3><p>主要在于烟囱式的开发模式，使得数据复用性低，导致大量重复逻辑代码的研发，影响需求响应速度。</p><p>比如，两个指标都需要对同一份原始数据进行清洗，原则上来说，只用一个任务对原始数据做清洗，产出一张明细表，另一个指标开发时，便可直接引用已经清洗好的明细表，这样便可节省一个清洗逻辑的研发工作量。但现实往往是对同一份原始数据做了两次清洗。因此，要解决需求响应速度慢的问题，就要提升数据的复用性，确保相同数据只加工一次，实现数据的共享。</p><h3 id="3-取数效率低"><a href="#3-取数效率低" class="headerlink" title="3. 取数效率低"></a>3. 取数效率低</h3><p>主要表现在两个方面，一方面是找不到数据，另一方面是取不到数据。要解决找不到数据的问题，就要构建企业数据资产目录，让数据使用者快速找到并理解数据。取不到数据的主要是非技术人员不会写SQL去提取数据，所以可以为其提供自助取数工具，使其简单快速的获取数据。</p><h3 id="4-数据质量低"><a href="#4-数据质量低" class="headerlink" title="4. 数据质量低"></a>4. 数据质量低</h3><p>面对业务已经沉淀的大量数据，逐步形成了企业的数据资产。而这些数据资产如何成为可持续使用的，为企业带来价值的数据，需要数据治理进行提升数据质量，比如设计数据质量校验的规则和使用流程，设计数据管控权限，数据如何安全输出及共享的设计等，如何在整体上发挥出数据的协同效应，为业务提供更高价值的数据服务链路，数据中台可以将这些数据能力整合到一起，对业务端提供稳定的持续的服务能力。</p><h2 id="五、什么企业适合做数据中台"><a href="#五、什么企业适合做数据中台" class="headerlink" title="五、什么企业适合做数据中台"></a>五、什么企业适合做数据中台</h2><p>数据中台的构建需要大量人力物力的投入，所以数据中台的建设一定要结合企业的现状，按需选择，不可盲目跟风。因此，企业在选择是否构建数据中台的时，可以从以下几个方面思考：</p><p><strong>首先，看企业是否有一定的数据基础</strong>，是否实现了业务数据化的过程，有了一定的数据沉淀，数据中台，顾名思义，数据是基础。</p><p><strong>其次，企业是否存在业务数据孤岛</strong>，是否有需要整合各个业务系统的数据，进行关联分析的需求，如果有，需要通过构建数据中台，打通数据孤岛，整合各业务系统数据，满足关联分析的需求。比如某零售企业，在业务发展初期，商品、销售、供应链等都是独立的数据仓库，后期要构建智能补货系统，需要打通多个业务系统的数据，因此选择建设数据中台。</p><p>最后，在日常的数据使用过程中是否遇到指标口径不一致、需求响应速度慢、数据质量差、数据成本高等痛点，如果满足前两个条件，且在数据应用中存在以上所述的一些痛点，那建议你可以考虑将数据中台项目提上日程。</p><h2 id="六、数据中台怎么建设"><a href="#六、数据中台怎么建设" class="headerlink" title="六、数据中台怎么建设"></a>六、数据中台怎么建设</h2><h3 id="01-入手点"><a href="#01-入手点" class="headerlink" title="01 入手点"></a>01 入手点</h3><p>应从面向“业务价值”入手，简单来讲就是，面向应用更有目标性，能更早地发挥数据的价值，让企业客户的数字化转型路径不再是一个漫长的周期建设，而是一个逐步演进的过程。换一个更好的理解方式，其实是面向企业客户实际需求，以及业务价值构建数据中台。</p><p>首先，上数据中台最好是业务发展或变化快速的部门，因为这些业务上中台，一是ROI容易成正比，二也能充分发挥数据的价值，容易得到各方认可。</p><p>其次，一开始不一定就得从统一数据口径入手，是不是可以先容忍数据层面一定程度的混乱，验证价值。当业务发展起来后，再去治理它，这很大程度上符合敏捷的理念，也符合很多企业的实际情况。</p><p>然后，针对业务价值或实际存在的问题提供服务，务实而非务虚。比如，①先上专家或架构师，进行项目诊断；②用产品和解决方案，走通关键路径；③当核心业务问题被解决后，也有一些事情是需要客户自己来完成，这时也能够针对性提供一些咨询服务。</p><h3 id="02-匹配企业数字化进程"><a href="#02-匹配企业数字化进程" class="headerlink" title="02 匹配企业数字化进程"></a>02 匹配企业数字化进程</h3><p>建设数据中台要遵循企业数字化进程各阶段的要求，因此，企业数字化发展可以分为<strong>数据汇集、融合、开放、智能化</strong>处理几个阶段。</p><p>第一阶段，对于本身已经覆盖较多信息系统的企业，需要考虑把有关数据汇聚到一起。而对于信息化程度相对偏低的企业，则要实现企业业务的在线化。</p><p>第二阶段，需要企业评估其自身数据是否已经实现了有机的融合。所谓的“融合”指的是企业通过一种标准把各个系统产生的数据进行有效的资产化。也就是说，这个阶段企业需要完成数据治理和归集工作。</p><p>第三阶段，涉及数据的开放，即企业需要有专门的部门把归集以后的数据开放给内部各个部门，让各部门了解企业的数据资产情况，从而更好地实现企业基于数据的服务提升与创新。有条件的企业再把数据开放给生态链上下游的企业，实现服务创新、协作方式的重构，从而形成更大范围的协同。</p><p>第四阶段，指的是利用数据进行智能化处理。众所周知，企业通过机器学习等人工智能的方式进行数据处理，可以创造出十分广阔的增值空间，就像寻找矿产资源一样，通过数据智能的方式，企业可以从前所未有的角度挖掘出全新的数据价值。 </p><p>以上的数字化进程对于计划实施数字化战略的企业而言，是相对比较适合的一个过程。同时，由于各企业的实际情况不同，各自的战略也会有所差别。大型企业建设中台主要需要考虑转体系问题，即企业应从整个组织、商业模式、战略协同方面，开展全面的改造，即三个全：全在线、全链接、全协同。而发展中企业则需要先考虑“工具化”问题，即企业可以借助数据平台、工具，首先实现业务的在线化，然后再考虑基于数据的服务提升。</p><h3 id="03-数据中台架构"><a href="#03-数据中台架构" class="headerlink" title="03 数据中台架构"></a>03 数据中台架构</h3><p>从数据处理与数据治理两个维度出发，可以设计一个解耦的数据中台体系架构。该数据中台体系架构具有一定的柔性，可按照企业应用需求进行组合，或者对单个模块进行扩充，能满足大多数企业数据中台建设的需求。</p><p><img src="https://img.iamghf.top/md/202404151426756" alt="图片"></p><p>数据中台的通用体系架构如图  所示。该中台体系架构以减少功能冗余和提高功能复用为原则，把数据中台解耦为 6 个可以分别独立建设、演进的功能子系统。</p><p>数据结构与数据处理子系统是数据中台体系架构的核心，数据治理是提升数据价值的重要手段。该数据中台体系架构的通用性表现在以下几点：</p><p>（1）该数据中台体系架构综合考虑了数据中台的各种要素，参考这个架构进行建设可以有效提升数据资产价值，提供数据及服务的共享。</p><p>（2）参考这个数据中台体系架构，企业可以一次规划、分步实施。首先建设处理子系统及数据存储子系统，然后根据业务发展需求，逐步补充数据采集、数据安全及数据治理子系统。</p><p>（3）该数据中台由 6 个解耦的子系统组成。企业在立项建设时可以灵活组合，每个子系统单独招标建设，也可以把多个子系统合并招标建设。数据中台通用体系架构包含<strong>数据采集框架、数据存储框架、数据处理框架、数据治理框架、数据安全框架及数据运营框架</strong>等 6 大部分。</p><h4 id="1）数据采集框架"><a href="#1）数据采集框架" class="headerlink" title="1）数据采集框架"></a>1）数据采集框架</h4><p>数据中台的采集框架应对纳入数据中台的各种源数据进行统一采集管理。数据采集框架中应提供多种数据采集方式，如<strong>文件传输协议采集、数据库采集、接口应用程序接入采集、流式采集及网络爬虫采集。</strong></p><p>同时采集框架应按照数据采集规范对源数据进行预处理，从而去除明显不需要的数据及多余数据，并对采集过程进行管理。虽然数据中台的体系架构没有统一模板，但各企业数据采集框架基本一致。</p><h4 id="2）数据存储框架"><a href="#2）数据存储框架" class="headerlink" title="2）数据存储框架"></a>2）数据存储框架</h4><p>数据中台的核心是数据，数据通过采集系统获取，然后数据经过处理框架加工，并接受数据治理框架的管理，同时也要接受数据安全管理框架的管理，最后开放的价值数据将通过数据运营框架对外提供数据服务。</p><p>数据中台的数据架构应该独立规划，并采用合理的技术架构对不同类型的数据进行存储。数据存储框架中，无论数据采用对象存储、块存储还是数据库存储技术，各种中台数据可按照上图所示分类管理。</p><p>源数据主要由采集框架进行管理，数据治理框架按照数据特征把数据简单分为结构化和非结构化数据两大类，而规范化分域数据则是数据治理框架对全量数据的规范化分域整理。宽表数据是数据关联的结果，利用宽表数据可以对人、事、地、物、组等对象进行完整的数据画像，同时宽表数据也可以作为上层模型数据的中间层数据。</p><p>元数据和标签数据都是对数据的描述，其中元数据用来对数据的客观属性进行表示，标签数据更倾向于管理者对数据的主观表述及等级划分，比如质量等级标签、安全标签、属性标签等。主数据需要在各系统间频繁更新、交换，且需要独立的存储空间进行维护管理。</p><h4 id="3）数据处理框架"><a href="#3）数据处理框架" class="headerlink" title="3）数据处理框架"></a>3）数据处理框架</h4><p>数据处理是每个数据应用的基本环节之一，经典的数据抽取、转换和加载（ETL）处理流程在数据采集预处理、数据整合、数据建模等多个地方均要使用。单独建设数据处理框架有利于数据处理工具组件的集中开发与管理，也有利于数据中台数据处理任务的协调与调度。</p><p>数据处理框架专门负责数据处理相关的任务，包括<strong>批处理、流处理、人工智能分析、数据清洗、数据交换及查询，</strong>此外数据处理的相关工具组件可在处理框架中配置。任务调度模块在数据处理框架中处于居中指挥的作用，并对运行的数据处理任务进行监控及异常处理等操作。</p><h4 id="4）数据治理框架"><a href="#4）数据治理框架" class="headerlink" title="4）数据治理框架"></a>4）数据治理框架</h4><p>广义的数据治理不仅包含提升数据价值的内容，如数据管理、数据目录、数据质量等，也包含数据安全管理及数据共享服务。</p><p>数据安全管理与数据价值提升是一个矛盾体，如果由一个厂商或开发团队进行数据安全管理及数据价值提升相关软件的开发，则开发者的操作难免有所偏向，而且矛盾不容易公开，少了冲突也就少了优质的解决方案。</p><p>另外，数据共享与数据治理的其他内容也存在相同的问题。因此，本文建议数据中台的数据治理框架中不包含数据安全与共享的相关内容。</p><p>数据治理框架包含<strong>数据资产目录、数据管理、模型管理和数据质量</strong> 4 个模块：</p><p>（1）数据地图、数据资产目录、知识图谱及数据血缘的主要作用是展示数据的属性及相互关系，因此都纳入数据目录模块。</p><p>（2）数据模型能提高数据中台对外部应用需求的反应能力，固化的中间模型数据需要专门管理。模型管理包括模型目录、模型血缘及模型地图等。</p><p>（3）数据管理又可以细分为元数据管理、主数据管理、标签数据管理及源数据管理。</p><p>（4）数据质量管理模块按照制定的数据标准及数据稽核规则对数据中台中的数据进行质量管理。</p><h4 id="5）数据安全框架"><a href="#5）数据安全框架" class="headerlink" title="5）数据安全框架"></a>5）数据安全框架</h4><p>数据已经成为数据资产，数据安全框架是数据中台必不可少的组成部分。数据安全叠加在数据中台其他功能框架之上，数据采集、处理、交换、共享等每个环节均必须实施安全控制策略。安全框架可以分为日志管理、用户认证、权限管理及加解密等几个功能模块。</p><p>此外，安全全门户也可以对外提供安全能力封装，展示数据中台的安全态势及安全视图。</p><h4 id="6）数据运营框架"><a href="#6）数据运营框架" class="headerlink" title="6）数据运营框架"></a>6）数据运营框架</h4><p>数据中台的核心功能是综合众多数据应用的数据处理及数据治理功能，集中建设、集中管理、减少冗余、增加复用。数据中台的最终目的还是为其他应用或开发者提供数据服务，而对外数据服务功能将直接面向不确定的外部对象。</p><p>因此单独建设数据运营，一方面有利于针对外部用户提供针对性功能；另一方面，数据运营模块作为用户与数据中台核心数据服务之间的中间层，可以有效隔离外部用户直接控制、接触核心数据及应用，可保护数据中台的安全性及内部功能的稳定性。</p><p>综合以上因素，数据运营应配置运营门户、能力开放、数据开放及运营监控等功能：</p><p><strong>（1）运营门户</strong>：对数据中台管理者提供管理门户，对开发者提供开发者门户。对内部应用提供内部应用门户，对外部应用提供外部应用门户。运营门户针对不同的用户提供不同的通道并开放不同的数据中台能力。</p><p><strong>（2）能力开放</strong>：把数据中台的数据处理能力、数据分析能力等经过适当的封装后对用户提供服务，可以是微服务，也可以是 API 接口，或者直接提供二次开发能力。</p><p><strong>（3）数据开放</strong>：通过数据目录，数据/模型展示（可视化、数据视图等）为其他数据应用系统提供数据服务。</p><p><strong>（4）运营监控</strong>：对数据中台的总体运营情况进行监控管理，包括硬件环境、软件环境，并且确定监控指标，按需求提供运营日报，处理告警信息。</p><h2 id="七、数据中台发展趋势"><a href="#七、数据中台发展趋势" class="headerlink" title="七、数据中台发展趋势"></a>七、数据中台发展趋势</h2><h3 id="1-标准化与市场下沉"><a href="#1-标准化与市场下沉" class="headerlink" title="1. 标准化与市场下沉"></a>1. 标准化与市场下沉</h3><p>数据中台的核心在于共享和沉淀能力，随着数据中台在行业头部及领先企业逐渐落地，供应商经历了各类业务场景能力沉淀的过程。</p><p>在深度上，数据中台厂商承载细分行业的各类定制化业务，不断沉淀业务能力。</p><p>在广度上，随着不同业务场景的持续输入，数据中台厂商产品的能力越来越丰富，覆盖的领域也越来越广泛。</p><p>完善数据中台的深度和广度，提炼和整合数据中台的服务，尤其是对于对数据中台能力要求相对简单的中小企业，为客户提供标准化的整体解决方案将成为数据中台服务商的产品方向。</p><p><img src="https://img.iamghf.top/md/202404151426486" alt="图片"></p><h3 id="2-精细化"><a href="#2-精细化" class="headerlink" title="2. 精细化"></a>2. 精细化</h3><p>首先，数据中台所提供的底层技术支撑能力，需要供应商在软件架构、云技术、容器编排、DevOps等多方面有充足的技术储备，还需要具备资本和技术实力的双重积累。</p><p>纵观中国数据中台行业，虽然界限并不明晰，但是大致形成了以阿里、腾讯等技术雄厚的头部企业侧重提供底层架构技术，其他中小供应商侧重提供行业化服务和产品的竞争格局。</p><p>其次，没有一家供应商可以覆盖企业庞大的、所有的需求，尤其是多组织、多板块、跨业务的大型企业，所以在一个领域内已经完成实践和形成规模的供应商会优先深耕本领域，提供更加细分的场景切入口。</p><p>最后，企业也会根据业务需求面向不同领域的数据中台产品进行选择，不会局限于一家中台服务商。随着创业公司不断成长，细小赛道逐渐被填充，愈加激烈的市场竞争会使差异化成为供应商采取的产品战略。</p><p><img src="https://img.iamghf.top/md/202404151426765" alt="图片"></p><h3 id="3-SAAS化"><a href="#3-SAAS化" class="headerlink" title="3. SAAS化"></a>3. SAAS化</h3><p>从内部来看，数据中台不断沉淀跨行业、跨企业复用的组件、模块，存在朝SaaS和本地部署混合模式发展的趋势。从外部来看，随着云计算的普及，部分系统SaaS化趋势较强。因此，作为前台和后台的连接，数据中台与SaaS应用融合对接的实践越来越多，市场将逐渐形成一套成熟的中台+SaaS系统融合闭环方案。</p><p>敏捷开发、快速迭代以适应业务需求是数据中台的基本能力。随着数据中台市场渗透率的提高，应对小量应用调整的场景，低代码需求在近期兴起。允许通过零代码或少量代码就可以快速创建应用，对企业运维团队的要求降低，将充分提升数据 中台的应用性。</p><p><img src="https://img.iamghf.top/md/202404151426482" alt="图片"></p><h3 id="4-智能化"><a href="#4-智能化" class="headerlink" title="4. 智能化"></a>4. 智能化</h3><p>海量数据与多样的业务场景导致数据中台数据量大增，积累了丰富的数据指标，未来数据中台将会应用智能技术提供通用化智能服务，为业务决策提供直接辅助场景，比如商品销量预测，千人千面推荐算法、营销活动预测等。同时，通过智能技术算法可以为前端员工降低数据使用的门槛，提高整体工作效率和生产效率。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkzMzQxODU3Mg==&mid=2247487834&idx=1&sn=70ad6a964fa1a81118048aabf5a4634c&chksm=c3f6dd4d1dd6ce13ff58f9a0abe5213849f7bfeae9e4984f4475cd6ca9d7e50076ffced72473&scene=132&exptype=timeline_recommend_article_extendread_samebiz&show_related_article=1&subscene=21&scene=132#wechat_redirect" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 数据中台 </tag>
            
            <tag> 数据仓库 </tag>
            
            <tag> 中台价值 </tag>
            
            <tag> 数据中台架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业主数据系统建设方案</title>
      <link href="/20240415001.html"/>
      <url>/20240415001.html</url>
      
        <content type="html"><![CDATA[<h1 id="企业主数据系统建设方案"><a href="#企业主数据系统建设方案" class="headerlink" title="企业主数据系统建设方案"></a>企业主数据系统建设方案</h1><p>在许多企业中，主数据分布在众多彼此隔离的系统中。客户服务部门、生产部门以及采购部门都有各自的系统。即使在一个业务部门里，也有众多前端和后端系统，这些系统包含对业务至关重要的数据，但通常情况下无法与其他系统共享这些信息。正是由于构建在各种架构之上的不兼容系统中的这种部门化数据，使得企业几乎不可能创建和维护主数据的“单一”视图。</p><p><img src="https://img.iamghf.top/md/202404151416839" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417875" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417368" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417265" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417818" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417264" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417228" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417623" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417819" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417740" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417782" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417041" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151417954" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151418450" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151418446" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151418923" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151418875" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151418635" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404151418593" alt="图片"></p><p>企业通过主数据管理平台实现主数据全生命周期的统一管理，使得各部门、各系统都可以使用唯一的、准确的、一致的主数据；通过主数据管理平台的集成接口，为各系统提供高效一致的主数据，从而降低企业基础数据维护成本，保障基础数据的一致性，提高企业数据质量。企业开展主数据治理活动，首先需要建立统一的主数据治理体系，主要从数据标准、主数据代码库、主数据管理平台、主数据运维体系、目标系统代码转换这5个方面来建立治理体系框架。其中，首要的就是统一主数据标准，然后基于该标准建立主数据代码库，设计主数据运维体系保障主数据常态化运转，最终所有的主数据治理成果都必须通过主数据管理平台进行落地。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据治理 </tag>
            
            <tag> 主数据 </tag>
            
            <tag> 数据标准 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主数据管理体系建设方案</title>
      <link href="/20240412002.html"/>
      <url>/20240412002.html</url>
      
        <content type="html"><![CDATA[<h1 id="主数据管理体系建设方案"><a href="#主数据管理体系建设方案" class="headerlink" title="主数据管理体系建设方案"></a>主数据管理体系建设方案</h1><p><img src="https://img.iamghf.top/md/202404121140071" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121140556" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121141830" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121141768" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121141812" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121141044" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121141290" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121141511" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121141810" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121141197" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121141091" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142884" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142996" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142933" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142970" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142592" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142294" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142882" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142155" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142553" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142029" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142089" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142388" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121142955" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143856" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143019" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143766" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143585" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143267" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143662" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143810" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143074" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143159" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143170" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143167" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121143556" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144479" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144642" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144854" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144319" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144328" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144541" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144357" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144860" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144073" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121144287" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据治理 </tag>
            
            <tag> 主数据 </tag>
            
            <tag> 元数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据治理平台与数据运营体系建设方案</title>
      <link href="/20240412001.html"/>
      <url>/20240412001.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据治理平台与数据运营体系建设方案"><a href="#数据治理平台与数据运营体系建设方案" class="headerlink" title="数据治理平台与数据运营体系建设方案"></a>数据治理平台与数据运营体系建设方案</h1><p><img src="https://img.iamghf.top/md/202404121127542" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121127384" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121127494" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121127510" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121127750" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121127840" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121127427" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128505" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128276" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128013" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128266" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128906" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128687" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128287" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128285" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128189" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128776" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121128821" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129550" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129820" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129142" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129000" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129867" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129174" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129838" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129299" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129343" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121129766" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130320" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130786" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130840" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130798" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130187" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130804" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130040" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130717" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130490" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130552" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130717" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121130152" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121131468" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121131620" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121131171" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121131066" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121131483" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121131171" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121131468" alt="图片"></p><p><img src="https://img.iamghf.top/md/202404121131041" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据治理 </tag>
            
            <tag> 数据运营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大模型LLM在Text2SQL上的应用实践</title>
      <link href="/llm.html"/>
      <url>/llm.html</url>
      
        <content type="html"><![CDATA[<h1 id="大模型LLM在Text2SQL上的应用实践"><a href="#大模型LLM在Text2SQL上的应用实践" class="headerlink" title="大模型LLM在Text2SQL上的应用实践"></a>大模型LLM在Text2SQL上的应用实践</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前，大模型的一个热门应用方向Text2SQL，它可以帮助用户快速生成想要查询的SQL语句，再结合可视化技术可以降低使用数据的门槛，更便捷的支持决策。本文将从以下四个方面介绍LLM在Text2SQL应用上的基础实践。</p><p>· Text2SQL概述</p><p>· LangChain基础知识</p><p>· 基于SQLDatabaseChain的Text2SQL实践</p><p>· 后续计划</p><h2 id="Text2SQL概述"><a href="#Text2SQL概述" class="headerlink" title="Text2SQL概述"></a>Text2SQL概述</h2><p>Text-to-SQL（或者Text2SQL），顾名思义就是把文本转化为SQL语言，更学术一点的定义是：把数据库领域下的自然语言（Natural Language，NL）问题，转化为在关系型数据库中可以执行的结构化查询语言（Structured Query Language，SQL），因此Text-to-SQL也可以被简写为NL2SQL。</p><p><img src="https://img.iamghf.top/md/202404121107833" alt="图片"></p><p>· 输入：自然语言问题，比如“<em>查询表t_user的相关信息，结果按id降序排序，只保留前10个数据</em> ”</p><p>· 输出：SQL，比如 “<em>SELECT \</em> FROM t_user ORDER BY id DESC LIMIT 10*”</p><p>Text2SQL应用主要是帮助用户减少开发时间，降低开发成本。“打破人与结构化数据之间的壁垒”，即普通用户可以通过自然语言描述完成复杂数据库的查询工作，得到想要的结果。</p><p><img src="https://img.iamghf.top/md/202404121108802" alt="架构"></p><p>基于LLM的应用开发基本架构如上图，本文介绍以LangChain + OpenAI + RDB的方式来实现Text2SQL的实践方案。</p><h2 id="LangChain基础知识"><a href="#LangChain基础知识" class="headerlink" title="LangChain基础知识"></a>LangChain基础知识</h2><p>LangChain是一个面向大语言模型的应用开发框架，如果将大语言模型比作人的大脑，那么可以将LangChain可以比作人的五官和四肢，它可以将外部数据源、工具和大语言模型连接在一起，既可以补充大语言模型的输入，也可以承接大语言模型的输出。</p><p>LangChain提供各种不同的组件帮助使用LLM，如下图所示，核心组件有Models、Indexes、Chains、Memory、Prompt以及Agent。</p><p><img src="https://img.iamghf.top/md/202404121111236" alt="图片"></p><h3 id="3-1-Models"><a href="#3-1-Models" class="headerlink" title="3.1 Models"></a>3.1 Models</h3><p>LangChain本身不提供LLM，提供通用的接口访问LLM，可以很方便的更换底层的LLM以及自定义自己的LLM。主要有2大类的Models：</p><p>1）LLM：将文本字符串作为输入并返回文本字符串的模型，类似OpenAI的text-davinci-003</p><p>2）Chat Models：由语言模型支持将聊天消息列表作为输入并返回聊天消息的模型。一般使用的ChatGPT以及Claude为Chat Models。</p><p>与模型交互可以通过给予Prompt的方式，LangChain通过PromptTemplate的方式方便我们构建以及复用Prompt。</p><p>代码示例如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> langchain <span class="token keyword">import</span> PromptTemplate<span class="token comment" spellcheck="true"># 定义提示模板</span>prompt <span class="token operator">=</span> PromptTemplate<span class="token punctuation">(</span>input_variables<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"question"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> template<span class="token operator">=</span><span class="token triple-quoted-string string">"""  简洁和专业的来回答用户的问题。  如果无法从中得到答案，请说 “根据已知信息无法回答该问题” 或 “没有提供足够的相关信息”，不允许在答案中添加编造成分，答案请使用中文。 问题是：{question}"""</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>prompt<span class="token punctuation">.</span>format_prompt<span class="token punctuation">(</span>question<span class="token operator">=</span><span class="token string">"如何进行数据治理"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="3-2-Indexes"><a href="#3-2-Indexes" class="headerlink" title="3.2 Indexes"></a>3.2 Indexes</h3><p>索引和外部数据进行集成，用于从外部数据获取答案。如下图所示，主要的步骤：</p><p>· 通过Document Loaders加载各种不同类型的数据源</p><p>· 通过Text Splitters进行文本语义分割</p><p>· 通过Vectorstore进行非结构化数据的向量存储</p><p>· 通过Retriever进行文档数据检索</p><p><img src="https://img.iamghf.top/md/202404121112599" alt="图片"></p><h3 id="3-3-Chains"><a href="#3-3-Chains" class="headerlink" title="3.3 Chains"></a>3.3 Chains</h3><p>LangChain通过chain将各个组件进行链接，以及chain之间进行链接，用于简化复杂应用程序的实现。其中主要有LLMChain、SQLDatabase Chain以及Sequential Chain。</p><h4 id="3-3-1-LLMChain"><a href="#3-3-1-LLMChain" class="headerlink" title="3.3.1 LLMChain"></a>3.3.1 LLMChain</h4><p>最基本的链为LLMChain，由PromptTemplate、LLM和OutputParser组成。LLM的输出一般为文本，OutputParser用于让LLM结构化输出并进行结果解析，方便后续的调用。</p><p><img src="https://img.iamghf.top/md/202404121112175" alt="图片"></p><p>其实现原理如图所示，包含三步：</p><p>· 输入问题</p><p>· 拼接提示，根据提示模板将问题转化为提示</p><p>· 模型推理，输出答案</p><p>代码如下所示：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> langchain<span class="token punctuation">.</span>prompts <span class="token keyword">import</span> PromptTemplate<span class="token keyword">from</span> langchain<span class="token punctuation">.</span>chains <span class="token keyword">import</span> LLMChain<span class="token keyword">from</span> langchain <span class="token keyword">import</span> OpenAI<span class="token keyword">import</span> osos<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"OPENAI_API_KEY"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Your openai key"</span><span class="token comment" spellcheck="true"># 定义模型</span>llm <span class="token operator">=</span> OpenAI<span class="token punctuation">(</span>temperature<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义提示模板</span>prompt <span class="token operator">=</span> PromptTemplate<span class="token punctuation">(</span>input_variables<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"question"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> template<span class="token operator">=</span><span class="token triple-quoted-string string">"""    简洁和专业的来回答用户的问题。    如果无法从中得到答案，请说 “根据已知信息无法回答该问题” 或 “没有提供足够的相关信息”，不允许在答案中添加编造成分，答案请使用中文。    问题是：{question}"""</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义chain</span>chain <span class="token operator">=</span> LLMChain<span class="token punctuation">(</span>llm<span class="token operator">=</span>llm<span class="token punctuation">,</span> prompt<span class="token operator">=</span>prompt<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 执行chain</span><span class="token keyword">print</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">"如何开展数据治理"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="3-3-2-SQLDatabaseChain"><a href="#3-3-2-SQLDatabaseChain" class="headerlink" title="3.3.2 SQLDatabaseChain"></a>3.3.2 SQLDatabaseChain</h4><p>SQLDatabaseChain能够通过模型自动生成SQL并执行，其实现原理如图所示，包含如下过程：</p><p><img src="https://img.iamghf.top/md/202404121112394" alt="图片"></p><p>· 输入问题；</p><p>· 获取数据库Schema，Schema包含数据库所有表的建表语句和数据示例，LangChain支持多种关系型数据库，包括MariaDB、MySQL、SQLite、ClickHouse、PrestoDB等；</p><p>· 拼接提示，根据提示模板将问题、数据库Schema转化为提示，并且提示中包含指示，要求模型在理解问题和数据库Schema的基础上，能够按一定的格式输出查询SQL、查询结果和问题答案等；</p><p>· 模型推理，这一步预期模型根据问题、数据库Schema推理、输出的答案中包含查询SQL，并从中提取出查询SQL；</p><p>· 执行查询SQL，从数据库中获取查询结果；</p><p>· 拼接提示，和上一次拼接的提示基本一致，只是其中的提示中包含了前两步已获取的查询SQL、查询结果；</p><p>· 模型推理，这一步预期模型根据问题、数据库Schema、查询SQL和查询结果推理出最终的问题答案。</p><h4 id="3-3-3-SequentialChain"><a href="#3-3-3-SequentialChain" class="headerlink" title="3.3.3 SequentialChain"></a>3.3.3 SequentialChain</h4><p>SequentialChains是按预定义顺序执行的链。SimpleSequentialChain为顺序链的最简单形式，其中每个步骤都有一个单一的输入/输出，一个步骤的输出是下一个步骤的输入。SequentialChain为顺序链更通用的形式，允许多个输入/输出。</p><h3 id="3-4-Memory"><a href="#3-4-Memory" class="headerlink" title="3.4 Memory"></a>3.4 Memory</h3><p>正常情况下Chain无状态的，每次交互都是独立的，无法知道之前历史交互的信息。LangChain使用Memory组件保存和管理历史消息，这样可以跨多轮进行对话，在当前会话中保留历史会话的上下文。Memory组件支持多种存储介质，可以与Mongo、Redis、SQLite等进行集成，以及简单直接形式就是Buffer Memory。</p><h3 id="3-5-Agent"><a href="#3-5-Agent" class="headerlink" title="3.5 Agent"></a>3.5 Agent</h3><p>Agent字面含义就是代理，如果说LLM是大脑，Agent就是代理大脑使用工具Tools。目前的大模型一般都存在知识过时、逻辑计算能力低等问题，通过Agent访问工具，可以去解决这些问题。目前这个领域特别活跃，诞生了类似AutoGPT、BabyAGI、AgentGPT等一堆优秀的项目。传统使用LLM，需要给定Prompt一步一步地达成目标，通过Agent是给定目标，其会自动规划并达到目标。</p><h2 id="基于SQLDatabaseChain的Text2SQL实践"><a href="#基于SQLDatabaseChain的Text2SQL实践" class="headerlink" title="基于SQLDatabaseChain的Text2SQL实践"></a>基于SQLDatabaseChain的Text2SQL实践</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p>LangChain提供基于LLM的SQLDatabaseChain，可以利用LLM的能力将自然语言的query转化为SQL，连接DB进行查询，并利用LLM来组装润色结果，返回最终answer。</p><p>在后台，LangChain 使用<code>SQLAlchemy</code>连接到 SQL 数据库。因此，<code>SQLDatabaseChain</code>可以与 SQLAlchemy 支持的任何 SQL 方言一起使用，例如 MS SQL、MySQL、MariaDB、PostgreSQL、Oracle和 SQLite。</p><h3 id="4-2-数据准备"><a href="#4-2-数据准备" class="headerlink" title="4.2 数据准备"></a>4.2 数据准备</h3><p>本案例使用SQLite 和示例Chinook 数据库，用户可按照<a href="https://database.guide/2-sample-databases-sqlite/" target="_blank" rel="noopener">https://database.guide/2-sample-databases-sqlite/</a> 上的说明进行设置。Chinook表示一个数字多媒体商店，包含了顾客（Customer）、雇员（Employee）、歌曲（Track）、订单（Invoice）及其相关的表和数据，数据模型如下图所示。</p><p><img src="https://img.iamghf.top/md/202404121115655" alt="图片"></p><h3 id="4-3-实践过程"><a href="#4-3-实践过程" class="headerlink" title="4.3 实践过程"></a>4.3 实践过程</h3><p><strong>需求：</strong>测试中文提问“总共有多少员工？”，即英文提问“How many employees are there?”</p><p><strong>期望：</strong>模型先给出查询Employee表记录数的SQL，再根据查询结果给出最终的答案。</p><p><strong>（1）测试中文提问</strong>，代码如下所示：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> langchain<span class="token punctuation">.</span>llms <span class="token keyword">import</span> OpenAI<span class="token keyword">from</span> langchain<span class="token punctuation">.</span>utilities <span class="token keyword">import</span> SQLDatabase<span class="token keyword">from</span> langchain_experimental<span class="token punctuation">.</span>sql <span class="token keyword">import</span> SQLDatabaseChain<span class="token keyword">import</span> osos<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"OPENAI_API_KEY"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Your openai key"</span>db <span class="token operator">=</span> SQLDatabase<span class="token punctuation">.</span>from_uri<span class="token punctuation">(</span><span class="token string">"sqlite:///..../Chinook.db"</span><span class="token punctuation">)</span>llm <span class="token operator">=</span> OpenAI<span class="token punctuation">(</span>temperature<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>db_chain <span class="token operator">=</span> SQLDatabaseChain<span class="token punctuation">.</span>from_llm<span class="token punctuation">(</span>llm<span class="token punctuation">,</span> db<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>db_chain<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">"总共有多少员工?"</span><span class="token punctuation">)</span></code></pre><p>输出结果如下：</p><p><img src="https://img.iamghf.top/md/202404121115347" alt="图片"></p><p>这里我们使用商业化的OpenAI，并将其temperature设为0，因为查询DB不太需要创造性和多样性。从返回的过程来看，自然语言被翻译成了SQL，得到查询结果后，解析包装结果，最终返回我们可以理解的答案。这里LLM成功将“总共”转成select count(*)，并准确地识别出表名，且最终组装出正确的结果。</p><blockquote><p><strong>注意：</strong>对于数据敏感项目，可以在 SQLDatabaseChain 初始化中指定 return_direct=True，以直接返回 SQL 查询的输出，而无需任何其他格式设置。这样可以防止 LLM 看到数据库中的任何内容。<strong>但请注意，默认情况下，LLM 仍然可以访问数据库方案（即所用方言、表名和列名）</strong>。</p></blockquote><p><strong>（2）测试英文提问</strong>，也可以得到我们想要的结果：</p><p><img src="https://img.iamghf.top/md/202404121116286" alt="图片"></p><p>通过上例，我们可以借助LangChain提供的SQLDatabaseChain，轻松地连接LLM与Database，自然语言的方式输入，自然语言的方式输出，借助LLM的强大能力来理解问题、生成SQL查询数据并输出结果。</p><h2 id="五、后续计划"><a href="#五、后续计划" class="headerlink" title="五、后续计划"></a>五、后续计划</h2><p>随着大模型的发展，LangChain是目前最火的LLM开发框架之一，能和外部数据源交互、能集成各种常用的组件等等，大大降低了LLM应用开发的门槛。基于SQLDatabaseChain实现的Text2SQL只是最基础的实践方式，但对于逻辑复杂的查询在稳定性、可靠性、安全性方面可能无法达到预期，比如输出幻觉问题、数据安全问题。如何解决或减少该类问题的出现，可改进的措施和方案在后续专题中继续讨论，大家一起群策群力。总之，实现高稳定、高可靠的基于LLM的应用，是一个持续改进的过程，是一个多种技术相结合的过程。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkzMzQxODU3Mg==&mid=2247486388&idx=1&sn=9ed0d499322f89a8f74b39ca48d4cea8&chksm=c24d8897f53a0181d63dde6df905a216af7217d03d70709ddd0ab376d293fc0a6406497e0f37&scene=21#wechat_redirect" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
            <tag> llm </tag>
            
            <tag> text2sql </tag>
            
            <tag> langchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Request Smuggling</title>
      <link href="/web-lou-dong-1.html"/>
      <url>/web-lou-dong-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-Request-Smuggling"><a href="#HTTP-Request-Smuggling" class="headerlink" title="HTTP Request Smuggling"></a>HTTP Request Smuggling</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>攻击者通过构造特殊结构的请求，干扰网站服务器对请求的处理，从而实现攻击目标</p><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><blockquote><p>注：以下文章中的前端指的是(代理服务器、CDN、WAF,负载均衡,Nginx,HAproxy等)</p></blockquote><p><code>Persistent Connection:</code>持久连接，<strong>Connection: keep-alive</strong>。<br>比如打开一个网页，我们可以在浏览器控制端看到浏览器发送了许多请求(HTML、图片、css、js)，而我们知道每一次发送HTTP请求需要经过 TCP 三次握手，发送完毕又有四次挥手。当单个用户同时需要发送多个请求时，这一点消耗或许微不足道，但当有许多用户同时发起请求的时候，便会给服务器造成很多不必要的消耗。为了解决这一问题，在 HTTP 协议中便新加了 Connection: keep-alive 这一个请求头，当有些请求带着 Connection: close 的话，通信完成之后，服务器才会中断 TCP 连接。如此便解决了额外消耗的问题，但是服务器端处理请求的方式仍旧是请求一次响应一次，然后再处理下一个请求，当一个请求发生阻塞时，便会影响后续所有请求，为此 Pipelining 异步技术解决了这一个问题</p><p><code>Pipelining:</code>能一次处理多个请求，客户端不必等到上一个请求的响应后再发送下一个请求。服务器那边一次可以接收多个请求，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端<br><img src="https://img.iamghf.top/md/202404080951446.png" alt="pipelining"></p><p>但是这样也会带来一个问题————如何区分每一个请求才不会导致混淆————前端与后端必须短时间内对每个数据包的边界大小达成一致。否则，攻击者就可以构造发送一个特殊的数据包发起攻击。那么如何界定数据包边界呢？<br>有两种方式： <strong>Content-Length</strong> 、 <strong>Transfer-Encoding</strong>.</p><p><code>Content-Length:</code><strong>CL</strong>，请求体或者响应体长度(十进制)。字符算一个，CRLF(一个换行)算两个。通常如果 Content-Length 的值比实际长度小，会造成内容被截断；如果比实体内容大，会造成 pending，也就是等待直到超时。</p><p><code>Transfer-Encoding:</code><strong>TE</strong>，其只有一个值 <strong>chunked</strong> (分块编码)。分块编码相当简单，在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\r\n），也不包括分块数据结尾的 CRLF，但是包括分块中的换行，值算2。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。<br>例如：</p><pre class=" language-http"><code class="language-http">POST /langdetect HTTP/1.1<span class="token header-name keyword">Host:</span> fanyi.baidu.com<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0<span class="token header-name keyword">Content-Type:</span> application/x-www-form-urlencoded<span class="token header-name keyword">Content-Length:</span> 93<span class="token header-name keyword">Transfer-Encoding:</span> chunked2;逗号后面是注释qu3;3表示后面的字符长度为3(十六进制)，不算CRLF(\r\n回车换行)ery1=2ja2ck0;0表示实体结束</code></pre><p>注：根据 RFC 标准，如果接收到的消息同时具有传输编码标头字段和内容长度标头字段，则必须忽略内容长度标头字段，当然也有不遵循标准的例外。</p><p>根据标准，当接受到如 Transfer-Encoding: chunked, error 有多个值或者不识别的值时的时候，应该返回 400 错误。但是有一些方法可以绕过<br>(导致既不返回400错误，又可以使 Transfer-Encoding 标头失效)：</p><pre class=" language-http"><code class="language-http"><span class="token header-name keyword">Transfer-Encoding:</span> xchunkedTransfer-Encoding : chunked<span class="token header-name keyword">Transfer-Encoding:</span> chunked<span class="token header-name keyword">Transfer-Encoding:</span> x<span class="token header-name keyword">Transfer-Encoding:</span>[tab]chunkedGET / HTTP/1.1 Transfer-Encoding: chunked<span class="token header-name keyword">X:</span> X[\n]Transfer-Encoding: chunkedTransfer-Encoding : chunked</code></pre><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>HTTP规范提供了两种不同方式来指定请求的结束位置，它们是 Content-Length 标头和 Transfer-Encoding 标头。当前/后端对数据包边界的校验不一致时，<br>使得后端将一个恶意的残缺请求需要和下一个正常的请求进行拼接，从而吞并了其他用户的正常请求。如图：</p><p><img src="https://img.iamghf.top/md/202404080953272.png" alt="原因">]</p><p>那么前/后端校验不一致有那些情况呢呢呢呢？😵</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li><code>CL-TE:</code> 前端: Content-Length,后端: Transfer-Encoding</li></ol><p><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">BURP实验环境</a></p><p>第一次请求：<br><img src="https://img.iamghf.top/md/202404080958234.png" alt="第一次请求"></p><p>第二次请求：<br><img src="https://img.iamghf.top/md/202404080959655.png" alt="第二次请求"></p><p>原理：前端服务器通过 Content-Length 界定数据包边界，检测到数据包无异常通过，然后传输到后端服务器，后端服务器通过 Transfer-Encoding 界定数据包边界，导致 <em>R0oKi3</em> 字段被识别为下一个数据包的内容，而被送到了缓冲区，由于内容不完整，会等待后续数据，当正常用户的请求传输到后端时，与之前滞留的恶意数据进行了拼接，组成了 <em>R0OKI3POST</em> ，为不可识别的请求方式，导致403。</p><ol><li><code>TE-CL:</code> 前端: Transfer-Encoding,后端: Content-Length</li></ol><p><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">BURP实验环境</a><br><em>记得关 burp 的 Update Content-Length 功能</em></p><p>第一次请求：<br><img src="https://img.iamghf.top/md/202404081000851.png" alt="img"></p><p>第二次请求：<br><img src="https://img.iamghf.top/md/202404081000459.png" alt="img"></p><p>原理：跟 CL-TE 相似</p><ol><li><code>TE-TE:</code> 前端: Transfer-Encoding,后端: Transfer-Encoding</li></ol><p><a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">BURP实验环境</a><br><em>记得关 burp 的 Update Content-Length 功能</em></p><p>第一次请求：<br><img src="https://img.iamghf.top/md/202404081001738.png" alt="img"></p><p>第二次请求：<br><img src="https://img.iamghf.top/md/202404081001653.png" alt="img"></p><p>原理：前端服务器通过第一个 Transfer-Encoding 界定数据包边界，检测到数据包无异常通过，然后传输到后端服务器，后端服务器通过第二个 Transfer-Encoding 界定数据包边界，结果为一个不可识别的标头，然后便退而求其次使用 Content-Length 校验，结果就跟 TE-CL 形式无异了。同样若是前端服务器校验第二个，后端服务器校验第一个，那结果也就跟 CL-TE 形式无异了。</p><ol><li><code>CL-CL:</code> 前端: Content-Length,后端: Content-Length</li></ol><p>在RFC7230规范中，规定当服务器收到的请求中包含两个 Content-Length，而且两者的值不同时，需要返回400错误。但难免会有服务器不严格遵守该规范。假设前端和后端服务器都收到该类请求，且不报错，其中前端服务器按照第一个Content-Length的值对请求进行为数据包定界，而后端服务器则按照第二个Content-Length的值进行处理。</p><p>这时攻击者可以恶意构造一个特殊的请求：</p><pre class=" language-http"><code class="language-http">POST / HTTP/1.1<span class="token header-name keyword">Host:</span> example.com<span class="token header-name keyword">Content-Length:</span> 11<span class="token header-name keyword">Content-Length:</span> 5123R0oKi3</code></pre><p>原理：前端服务器获取到的数据包的长度11，由此界定数据包边界，检测到数据包无异常通过，然后传输到后端，而后端服务器获取到的数据包长度为5。当读取完前5个字符后，后端服务器认为该请求已经读取完毕。便去识别下一个数据包，而此时的缓冲区中还剩下 <em>R0oKi3</em>，它被认为是下一个请求的一部分，由于内容不完整，会等待后续数据，当正常用户的请求传输到后端时，与之前滞留的恶意数据进行了拼接，攻击便在此展开。</p><ol><li><code>CL 不为 0 的 GET 请求:</code></li></ol><p>假设前端服务器允许 GET 请求携带请求体，而后端服务器不允许 GET 请求携带请求体，它会直接忽略掉 GET 请求中的 Content-Length 头，不进行处理。这就有可能导致请求走私。<br>比如发送下面请求：</p><pre class=" language-makefile"><code class="language-makefile">GET / HTTP/1.1<span class="token symbol">Host</span><span class="token punctuation">:</span> example.com<span class="token symbol">Content-Length</span><span class="token punctuation">:</span> 72POST /comment HTTP/1.1<span class="token symbol">Host</span><span class="token punctuation">:</span> example.com<span class="token symbol">Content-Length</span><span class="token punctuation">:</span>666msg<span class="token operator">=</span>aaa</code></pre><p>前端服务器通过读取Content-Length，确认这是个完整的请求，然后转发到后端服务器，而后端服务器因为不对 Content-Length 进行判断，于是在后端服务器中该请求就变成了两个：<br>第一个：</p><pre class=" language-http"><code class="language-http">GET / HTTP/1.1<span class="token header-name keyword">Host:</span> example.com<span class="token header-name keyword">Content-Length:</span> 72</code></pre><p>第二个：</p><pre class=" language-http"><code class="language-http">POST /comment HTTP/1.1<span class="token header-name keyword">Host:</span> example.com<span class="token header-name keyword">Content-Length:</span>666msg=aaa</code></pre><p>而第二个为 POST 请求，假定其为发表评论的数据包，再假定后端服务器是依靠 Content-Length 来界定数据包的，那么由于数据包长度为 666，那么便会等待其他数据，等到正常用户的请求包到来，便会与其拼接，变成 msg=aaa……………… ，然后会将显示在评论页面，也就会导致用户的 Cookie 等信息的泄露。</p><h2 id="PortSwigger-其他实验"><a href="#PortSwigger-其他实验" class="headerlink" title="PortSwigger 其他实验"></a>PortSwigger 其他实验</h2><ol><li><strong>使用 CL-TE 绕过前端服务器安全控制</strong></li></ol><p><a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">BURP实验环境</a><br>坑点：有时候实体数据里需要添加一些别的字段或者空行，不然会出一些很奇怪的错误，所以我在弄的时候参照了<a href="https://paper.seebug.org/1048/#51" target="_blank" rel="noopener">seebug 404Team</a><br>实验要求：获取 admin 身份并删除 carlos 用户</p><p>第一步：实验提示我们 admin 管理面版在 /admin 目录下，直接访问，显示：<br><img src="https://img.iamghf.top/md/202404081002537.png" alt="img"></p><p>第二步：利用 CL-TE 请求走私绕过前端服务器安全控制</p><ul><li>第一次发包<br><img src="https://img.iamghf.top/md/202404081003080.png" alt="img"></li></ul><p>坑点：数据实体一定要多一些其他字段或者多两行空白，不然报 Invalid request 请求不合法</p><pre class=" language-http"><code class="language-http">0GET /admin HTTP/1.1# 若是多了两行空白，那么 foo: bar 字段可以不要</code></pre><p>提示 admin 要从 localhost 登陆</p><ul><li>改包后多发几次得到<br><img src="https://img.iamghf.top/md/202404081003789.png" alt="img"></li><li>改包删除用户<br><img src="https://img.iamghf.top/md/202404081003220.png" alt="img"></li><li>再次请求 /admin 页面，发现 carlos 用户已不存在<br><img src="https://img.iamghf.top/md/202404081004166.png" alt="img"><br>坑点：这里再次请求的时候记得多加两个空行改变一下 Content-Length 的值，不然会显示不出来，神奇 BUG？</li></ul><p>原理：网站进行身份验证的处理是在前端服务器，当直接访问 /admin 目录时，由于通过不了前端验证，所以会返回 Blocked。利用请求走私，便可以绕过前端验证，直接在后端产生一个访问 /admin 目录的请求包，当发起下一个请求时，响应的数据包对应的是走私的请求包，如此便可以查看 admin 面板的页面数据，从而达到绕过前端身份验证删除用户的目的。</p><ol><li><strong>使用 TE-CL 绕过前端服务器安全控制</strong></li></ol><p><a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">BURP实验环境</a></p><p>实验过程与上一个实验相仿，不过要记得关 burp 的 <em>Update Content-Length</em><br><img src="https://img.iamghf.top/md/202404081004174.png" alt="img"></p><p>这里：不知道为什么一定要加 Content-Length 和其他的一些词，不加的话会显示 Invalid request 请求不合法 ？？？？？？？？？</p><ol><li><strong>获取前端服务器重写请求字段(CL-TE)</strong></li></ol><p><a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">BURP实验环境</a></p><blockquote><p>摘自<a href="https://paper.seebug.org/1048/#52" target="_blank" rel="noopener">seebug 404Team</a><br>在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如：</p><ul><li>描述TLS连接所使用的协议和密码</li><li>包含用户IP地址的XFF头</li><li>用户的会话令牌ID<br>总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤：</li><li>找一个能够将请求参数的值输出到响应中的POST请求</li><li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li><li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li></ul></blockquote><ul><li>第一步：找一个能够将请求参数的值输出到响应中的POST请求<br><img src="https://img.iamghf.top/md/202404081005750.png" alt="img"></li><li>第二步：利用 CL-TE 走私截获正常数据包经前端服务器修改后发送过来的内容，并输出在响应包中<br><img src="https://img.iamghf.top/md/202404081005882.png" alt="img"></li></ul><p>这一步的原理：由于我们走私构造的请求包为：</p><pre class=" language-makefile"><code class="language-makefile">POST / HTTP/1.1<span class="token symbol">Content-Length</span><span class="token punctuation">:</span> 100search<span class="token operator">=</span>66666</code></pre><p>从这里可以看到，Content-Length 的值为 100，而我们的实体数据仅为 search=66666，远没有 100，于是后端服务器便会进入等待状态，当下一个正常请求到来时，会与之前滞留的请求进行拼接，从而导致走私的请求包吞并了下一个请求的部分或全部内容，并返回走私请求的响应。</p><ul><li>第三步：在走私的请求上添加这个字段，然后走私一个删除用户的请求。<br><img src="https://img.iamghf.top/md/202404081005723.png" alt="img"></li><li>查看 /admin 页面，发现用户已被删除<br><img src="https://img.iamghf.top/md/202404081006646.png" alt="img"></li></ul><h2 id="能用来干什么"><a href="#能用来干什么" class="headerlink" title="能用来干什么"></a>能用来干什么</h2><ol><li>账户劫持 CL-TE<br><a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">BURP实验环境</a></li></ol><ul><li>构造特殊请求包，形成一个走私请求<br><img src="https://img.iamghf.top/md/202404081006837.png" alt="img"></li><li>查看评论<br><img src="https://img.iamghf.top/md/202404081006473.png" alt="img"></li></ul><p>原理：(跟 <em>获取前端服务器重写请求字段</em> 相似)<br>我们走私构造的请求包为：</p><pre class=" language-makefile"><code class="language-makefile">POST /post/comment HTTP/1.1<span class="token symbol">Host</span><span class="token punctuation">:</span> aca41ff41e89d28f800d3e82001a00c8.web-security-academy.net<span class="token symbol">Content-Length</span><span class="token punctuation">:</span> 900<span class="token symbol">Cookie</span><span class="token punctuation">:</span> session<span class="token operator">=</span>XPbI3LJQJCoBcQOvsLdfyCNbOKqsGudycsrf<span class="token operator">=</span>Nk6OsCxcNIUdfnrpQuy9N3WO0zLLcAWU&amp;postId<span class="token operator">=</span>4&amp;name<span class="token operator">=</span>aaa&amp;email<span class="token operator">=</span>aaa%40aaa.com&amp;website<span class="token operator">=</span>&amp;comment<span class="token operator">=</span>aaaa</code></pre><p>可以看到 Content-Length 值为 900，而我们的实体数据仅为 csrf=Nk6OsCxcNIUdfnrpQuy9N3WO0zLLcAWU&amp;postId=4&amp;name=aaa&amp;email=aaa%40aaa.com&amp;website=&amp;comment=aaaa，远不足900，于是后端服务器便会进入等待状态，当下一个正常请求到来时，会与之前滞留的请求进行拼接，从而导致走私的请求包吞并了下一个请求的部分或全部内容，并且由于是构造发起评论的请求包，所以数据会存入数据库，从而打开页面便会看到其他用户的请求包内容，获取其敏感数据，由于环境只有我一个人在玩，所以只能获取到自己的敏感数据。</p><p>注意：一定要将 comment=aaaa 放在最后</p><ol><li>Reflected XSS + Smuggling 造成无需交互的 XSS（CL-TE）<br><a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss" target="_blank" rel="noopener">BURP实验环境</a></li></ol><ul><li>首先反射型 XSS 在文章页面<br><img src="https://img.iamghf.top/md/202404081007032.png" alt="img"></li><li>构造请求走私 payload<br><img src="https://img.iamghf.top/md/202404081007198.png" alt="img"></li><li>导致无交互 XSS<br><img src="https://img.iamghf.top/md/202404081007654.png" alt="img"></li></ul><ol><li>恶意重定向<br><a href="http://codesharer.cn.com/" target="_blank" rel="noopener">环境暂无</a></li></ol><blockquote><p>许多应用程序执行从一个 URL 到另一个URL的重定向，会将来自请求的 Host 标头的主机名放入重定向URL。一个示例是 Apache 和 IIS Web 服务器的默认行为，在该行为中，对不带斜杠的文件夹的请求将收到对包含该斜杠的文件夹的重定向：</p></blockquote><pre class=" language-http"><code class="language-http">请求GET /home HTTP/1.1<span class="token header-name keyword">Host:</span> normal-website.com响应<span class="token response-status">HTTP/1.1 <span class="token property">301 Moved Permanently</span></span><span class="token header-name keyword">Location:</span> https://normal-website.com/home/</code></pre><blockquote><p>通常，此行为被认为是无害的，但是可以在走私请求攻击中利用它来将其他用户重定向到外部域。例如：</p></blockquote><pre class=" language-http"><code class="language-http"> POST / HTTP/1.1<span class="token header-name keyword">Host:</span> vulnerable-website.com<span class="token header-name keyword">Content-Length:</span> 54<span class="token header-name keyword">Transfer-Encoding:</span> chunked0GET /home HTTP/1.1<span class="token header-name keyword">Host:</span> attacker-website.com<span class="token header-name keyword">Foo:</span> X </code></pre><blockquote><p>走私的请求将触发重定向到攻击者的网站，这将影响后端服务器处理的下一个用户的请求。例如：</p></blockquote><pre class=" language-makefile"><code class="language-makefile">正常请求GET /home HTTP/1.1<span class="token symbol">Host</span><span class="token punctuation">:</span> attacker-website.com<span class="token symbol">Foo</span><span class="token punctuation">:</span> XGET /scripts/<span class="token keyword">include</span>.js HTTP/1.1<span class="token symbol">Host</span><span class="token punctuation">:</span> vulnerable-website.com恶意响应HTTP/1.1 301 Moved Permanently<span class="token symbol">Location</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//attacker-website.com/home/ </code></pre><blockquote><p>若用户请求的是一个 JavaScript 文件，该文件是由网站上的页面导入的。攻击者可以通过在响应中返回自己的 JavaScript 文件来完全破坏受害者用户。</p></blockquote><p>4.缓存投毒</p><blockquote><p>一般来说，前端服务器出于性能原因，会对后端服务器的一些资源进行缓存，如果存在HTTP请求走私漏洞，则有可能使用重定向来进行缓存投毒，从而影响后续访问的所有用户。</p></blockquote><p><a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning" target="_blank" rel="noopener">BURP实验环境</a></p><p><a href="https://paper.seebug.org/1048/#55" target="_blank" rel="noopener">实验参考</a></p><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><blockquote><p>检测请求走私漏洞的明显方法是发出一个模糊的请求，然后发出正常的“受害者”请求，然后观察后者是否得到意外的响应。但是，这极易受到干扰。</p></blockquote><blockquote><p>如果另一个用户的请求在我们的受害者请求之前命中，他们将得到损坏的响应，我们将不会发现该漏洞。这意味着在具有大量流量的实时站点上，很难证明请求走私存在而不会在此过程中影响众多真正的用户。即使在没有其他流量的站点上，您也可能会因应用程序级别的怪癖终止连接而导致漏报。</p></blockquote><blockquote><p>为了解决这个问题，作者开发了一种检测策略，该策略使用一系列消息，这些消息使易受攻击的后端系统挂起并使连接超时。这种技术几乎没有误报，抵制应用程序级别的怪癖，最重要的是几乎没有影响其他用户的风险。</p></blockquote><blockquote><p>假设前端服务器使用Content-Length头，后端使用Transfer-Encoding头。我将此定位称为CL.TE。我们可以通过发送以下请求来检测潜在的请求走私：</p></blockquote><pre class=" language-http"><code class="language-http">POST / HTTP/1.1<span class="token header-name keyword">Host:</span> example.com<span class="token header-name keyword">Content-Length:</span> 4<span class="token header-name keyword">Transfer-Encoding:</span> chunked1Rx</code></pre><blockquote><p>由于较短的Content-Length，前端将仅转发到 R 丢弃后续的 X，而后端将在等待下一个块大小时超时。这将导致明显的时间延迟。<br>如果超时说明两个服务器为CL.TE，正常响应就是CL.CL，被拒绝就可能是TE.TE或者TE.CL,那么只需要在拒绝的时候，再使用第二个请求，TE.TE就会正常响应，TE.CL就会超时。</p></blockquote><blockquote><p>如果两个服务器同步（TE.TE或CL.CL），请求将被前端拒绝或由两个系统无害地处理。最后，如果以相反的方式发生（TE.CL），前端将拒绝该消息，而不会将其转发到后端，这要归功于无效的块大小“Q”。这可以防止后端中毒。</p></blockquote><blockquote><p>我们可以使用以下请求安全地检测TE.CL：</p></blockquote><pre class=" language-http"><code class="language-http">POST / HTTP/1.1<span class="token header-name keyword">Host:</span> example.com<span class="token header-name keyword">Content-Length:</span> 6<span class="token header-name keyword">Transfer-Encoding:</span> chunked0X</code></pre><blockquote><p>如果以相反的方式发生（CL.TE），则此方法将使用X毒化后端套接字，可能会损害合法用户。幸运的是，通过首先运行先前的检测方法，我们可以排除这种可能性。</p></blockquote><blockquote><p>这些请求可以适应目标解析中的任意差异，并且它们用于通过HTTP Request Smuggler自动识别请求走私漏洞。HTTP Request Smuggler是为帮助此类攻击而开发的开源Burp Suite扩展。它们现在也被用在Burp Suite的核心扫描仪中。虽然这是服务器级漏洞，但单个域上的不同接口通常会路由到不同的目标，因此应将此技术单独应用于每个接口。</p></blockquote><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><blockquote><ol><li>禁用后端连接的重用，以便每个后端请求通过单独的网络连接发送。</li><li>使用HTTP / 2进行后端连接，因为此协议可防止对请求之间的边界产生歧义。</li><li>前端服务器和后端服务器使用完全相同的Web服务器软件，以便它们就请求之间的界限达成一致。<br>以上的措施有的不能从根本上解决问题，而且有着很多不足，就比如禁用代理服务器和后端服务器之间的 TCP 连接重用，会增大后端服务器的压力。使用 HTTP/2 在现在的网络条件下根本无法推广使用，哪怕支持 HTTP/2 协议的服务器也会兼容 HTTP/1.1。从本质上来说，HTTP 请求走私出现的原因并不是协议设计的问题，而是不同服务器实现的问题，个人认为最好的解决方案就是严格的实现 RFC7230-7235 中所规定的的标准，但这也是最难做到的。</li></ol></blockquote><p>HTTP 参数污染也能算是一种请求走私 <a href="https://www.cnblogs.com/wjrblogs/p/12966636.html" target="_blank" rel="noopener">HTTP参数污染</a></p><p><a href="https://www.cnblogs.com/wjrblogs/p/13152813.html" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> smuggling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie、Session、Token、JWT的区别</title>
      <link href="/cookie-session-token-jwt-de-qu-bie.html"/>
      <url>/cookie-session-token-jwt-de-qu-bie.html</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie、Session、Token、JWT的区别"><a href="#Cookie、Session、Token、JWT的区别" class="headerlink" title="Cookie、Session、Token、JWT的区别"></a>Cookie、Session、Token、JWT的区别</h1><h2 id="什么是认证（Authentication）"><a href="#什么是认证（Authentication）" class="headerlink" title="什么是认证（Authentication）"></a>什么是认证（Authentication）</h2><ul><li>通俗地讲就是<strong>验证当前用户的身份</strong>，证明 “你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）</li><li>互联网中的认证：<ul><li>用户名密码登录</li><li>邮箱发送登录链接</li><li>手机号接收验证码</li><li>只要你能收到邮箱 / 验证码，就默认你是账号的主人</li></ul></li></ul><h2 id="什么是授权（Authorization）"><a href="#什么是授权（Authorization）" class="headerlink" title="什么是授权（Authorization）"></a>什么是授权（Authorization）</h2><ul><li><strong>用户授予第三方应用访问该用户某些资源的权限</strong><ul><li>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</li><li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</li></ul></li><li>实现授权的方式有：cookie、session、token、OAuth</li></ul><h2 id="什么是凭证（Credentials）"><a href="#什么是凭证（Credentials）" class="headerlink" title="什么是凭证（Credentials）"></a>什么是凭证（Credentials）</h2><ul><li><strong>实现认证和授权的前提</strong>是需要一种<strong>媒介（证书）</strong> 来标记访问者的身份<ul><li>在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。</li><li>在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡 / 银行卡 / 个人贷款 / 交通出行等等，这就是<strong>认证的凭证。</strong></li><li>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞 / 收藏 / 分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</li></ul></li></ul><h2 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h2><ul><li><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li><li><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li><li><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</li></ul><p><strong>cookie 重要的属性</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name=value</strong></td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong></td></tr></tbody></table><ul><li>如果值为 Unicode 字符，需要为字符编码。</li><li>如果值为二进制数据，则需要使用 BASE64 编码。<br>| | <strong>domain</strong> | 指定 cookie 所属域名，默认是当前域名 | | <strong>path</strong> | <strong>指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘</strong>。<br>如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。| | <strong>maxAge</strong> | cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。</li><li><strong>比 expires 好用</strong>。<br>| | <strong>expires</strong> | 过期时间，在设置的某个时间点后该 cookie 就会失效。<br>一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除 | | <strong>secure</strong> | 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。<br>当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。| | <strong>httpOnly</strong> | <strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong> |</li></ul><h2 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h2><ul><li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li><li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中</strong></li></ul><p><img src="https://img.iamghf.top/md/202404080942985" alt="session认证流程"></p><ul><li><strong>session 认证流程：</strong><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul></li></ul><p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p><h2 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h2><ul><li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><h2 id="什么是-Token（令牌）"><a href="#什么是-Token（令牌）" class="headerlink" title="什么是 Token（令牌）"></a>什么是 Token（令牌）</h2><h3 id="Acesss-Token"><a href="#Acesss-Token" class="headerlink" title="Acesss Token"></a>Acesss Token</h3><ul><li><strong>访问资源接口（API）时所需要的资源凭证</strong></li><li><strong>简单 token 的组成：</strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li><li><strong>特点：</strong><ul><li><strong>服务端无状态化、可扩展性好</strong></li><li><strong>支持移动端设备</strong></li><li>安全</li><li>支持跨程序调用</li></ul></li><li><strong>token 的身份验证流程：</strong></li></ul><p><img src="https://img.iamghf.top/md/202404080943834" alt="token验证流程"></p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ol><ul><li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li><li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li></ul><h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><ul><li>另外一种 token——refresh token</li><li>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</li></ul><p><img src="https://img.iamghf.top/md/202404080944712" alt="refresh token"></p><ul><li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</li><li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</li></ul><h2 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h2><ul><li>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</strong>。而 Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></li><li>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</strong></li><li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：<strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</strong></li></ul><h2 id="什么是-JWT"><a href="#什么是-JWT" class="headerlink" title="什么是 JWT"></a>什么是 JWT</h2><ul><li>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</li><li>是一种<strong>认证授权机制</strong>。</li><li>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li><li>可以使用 HMAC 算法或者是 RSA 的公 / 私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</li><li><strong>阮一峰老师的 JSON Web Token 入门教程 讲的非常通俗易懂，这里就不再班门弄斧了</strong></li></ul><h3 id="生成-JWT"><a href="#生成-JWT" class="headerlink" title="生成 JWT"></a>生成 JWT</h3><p>jwt.io/<br><a href="http://www.jsonwebtoken.io/" target="_blank" rel="noopener">www.jsonwebtoken.io/</a></p><h3 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h3><p><img src="https://img.iamghf.top/md/202404080944450" alt="jwt"></p><ul><li><strong>JWT 认证流程：</strong><ul><li>用户输入用户名 / 密码登录，服务端认证成功后，会返回给客户端一个 JWT</li><li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样</li></ul></li></ul><pre><code>Authorization: Bearer &lt;token&gt;</code></pre><ul><li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</li><li>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</li><li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li></ul><h3 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h3><ul><li>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</li></ul><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><ul><li><p>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。</p><pre><code>GET /calendar/v1/eventsHost: api.example.comAuthorization: Bearer &lt;token&gt;复制代码</code></pre><ul><li>用户的状态不会存储在服务端的内存中，这是一种 <strong>无状态的认证机制</strong></li><li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。</li><li>由于 JWT 是自包含的，因此减少了需要查询数据库的需要</li><li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。</li><li>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而<strong>不需要担心跨域资源共享问题</strong>（CORS）</li></ul></li></ul><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><ul><li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li></ul><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><ul><li>通过 URL 传输</li></ul><pre><code>http://www.example.com/user?token=xxx</code></pre><h3 id="项目中使用-JWT"><a href="#项目中使用-JWT" class="headerlink" title="项目中使用 JWT"></a>项目中使用 JWT</h3><p><strong>项目地址</strong></p><p>Token 和 JWT 的区别</p><hr><p><strong>相同：</strong></p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p><strong>区别：</strong></p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul><p>常见的前后端鉴权方式</p><hr><ol><li>Session-Cookie</li><li>Token 验证（包括 JWT，SSO）</li><li>OAuth2.0（开放授权）</li></ol><h2 id="常见的加密算法"><a href="#常见的加密算法" class="headerlink" title="常见的加密算法"></a>常见的加密算法</h2><p><img src="https://img.iamghf.top/md/202404080944946" alt="加密算法"></p><ul><li>哈希算法 (Hash Algorithm) 又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字 “指纹” 的方法。哈希算法将数据重新打乱混合，重新创建一个哈希值。</li><li>哈希算法主要用来保障数据真实性 (即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实。</li><li>哈希算法通常有以下几个特点：<ul><li>2 的 128 次方为 340282366920938463463374607431768211456，也就是 10 的 39 次方级别</li><li>2 的 160 次方为 1.4615016373309029182036848327163e+48，也就是 10 的 48 次方级别</li><li>2 的 256 次方为 1.1579208923731619542357098500869 × 10 的 77 次方，也就是 10 的 77 次方</li></ul></li><li></li><li>正像快速：原始数据可以快速计算出哈希值</li><li>逆向困难：通过哈希值基本不可能推导出原始数据</li><li>输入敏感：原始数据只要有一点变动，得到的哈希值差别很大</li><li>冲突避免：很难找到不同的原始数据得到相同的哈希值，宇宙中原子数大约在 10 的 60 次方到 80 次方之间，所以 2 的 256 次方有足够的空间容纳所有的可能，算法好的情况下冲突碰撞的概率很低：</li></ul><p><strong>注意：</strong></p><ol><li>以上不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改，可以使用 RSA 公钥私钥方案，再配合哈希值。</li><li>哈希算法主要用来防止计算机传输过程中的错误，早期计算机通过前 7 位数据第 8 位奇偶校验码来保障（12.5% 的浪费效率低），对于一段数据或文件，通过哈希算法生成 128bit 或者 256bit 的哈希值，如果校验有问题就要求重传。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="使用-cookie-时需要考虑的问题"><a href="#使用-cookie-时需要考虑的问题" class="headerlink" title="使用 cookie 时需要考虑的问题"></a>使用 cookie 时需要考虑的问题</h3><ul><li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li><li>不要存储敏感数据，比如用户密码，账户余额</li><li>使用 httpOnly 在一定程度上提高安全性</li><li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li><li>设置正确的 domain 和 path，减少数据传输</li><li><strong>cookie 无法跨域</strong></li><li>一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie</li><li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li></ul><h3 id="使用-session-时需要考虑的问题"><a href="#使用-session-时需要考虑的问题" class="headerlink" title="使用 session 时需要考虑的问题"></a>使用 session 时需要考虑的问题</h3><ul><li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li><li>当网站采用<strong>集群部署</strong>的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li><li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li><li><strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？</strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li><li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li></ul><h3 id="使用-token-时需要考虑的问题"><a href="#使用-token-时需要考虑的问题" class="headerlink" title="使用 token 时需要考虑的问题"></a>使用 token 时需要考虑的问题</h3><ul><li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li><li><strong>token 可以避免 CSRF 攻击 (因为不需要 cookie 了)</strong></li><li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li></ul><h3 id="使用-JWT-时需要考虑的问题"><a href="#使用-JWT-时需要考虑的问题" class="headerlink" title="使用 JWT 时需要考虑的问题"></a>使用 JWT 时需要考虑的问题</h3><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul><h3 id="使用加密算法时需要考虑的问题"><a href="#使用加密算法时需要考虑的问题" class="headerlink" title="使用加密算法时需要考虑的问题"></a>使用加密算法时需要考虑的问题</h3><ul><li>绝不要以<strong>明文存储</strong>密码</li><li><strong>永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码</strong>。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。</li><li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。</li><li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 <strong>一次性的</strong>（这点很重要）密码，然后把这个密码发送给用户。</li></ul><h3 id="分布式架构下-session-共享方案"><a href="#分布式架构下-session-共享方案" class="headerlink" title="分布式架构下 session 共享方案"></a>分布式架构下 session 共享方案</h3><h4 id="1-session-复制"><a href="#1-session-复制" class="headerlink" title="1. session 复制"></a>1. session 复制</h4><ul><li>任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步</li></ul><p><strong>优点：</strong> 可容错，各个服务器间 session 能够实时响应。<br><strong>缺点：</strong> 会对网络负荷造成一定压力，如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。</p><h4 id="2-粘性-session-IP-绑定策略"><a href="#2-粘性-session-IP-绑定策略" class="headerlink" title="2. 粘性 session /IP 绑定策略"></a>2. 粘性 session /IP 绑定策略</h4><ul><li><strong>采用 Ngnix 中的 ip_hash 机制，将某个 ip 的所有请求都定向到同一台服务器上，即将用户与服务器绑定。</strong> 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。</li></ul><p><strong>优点：</strong> 简单，不需要对 session 做任何处理。<br><strong>缺点：</strong> 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。<br><strong>适用场景：</strong> 发生故障对客户产生的影响较小；服务器发生故障是低概率事件 。<br><strong>实现方式：</strong> 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。</p><h4 id="3-session-共享（常用）"><a href="#3-session-共享（常用）" class="headerlink" title="3. session 共享（常用）"></a>3. session 共享（常用）</h4><ul><li>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群</li><li>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：<ul><li>实现了 session 共享；</li><li>可以水平扩展（增加 Redis 服务器）；</li><li>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新 / 失效机制）；</li><li>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）</li></ul></li></ul><p><img src="https://img.iamghf.top/md/202404080945206" alt="session共享"></p><h4 id="4-session-持久化"><a href="#4-session-持久化" class="headerlink" title="4. session 持久化"></a>4. session 持久化</h4><ul><li>将 session 存储到数据库中，保证 session 的持久化</li></ul><p><strong>优点：</strong> 服务器出现问题，session 不会丢失<br><strong>缺点：</strong> 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p><h3 id="只要关闭浏览器-，session-真的就消失了？"><a href="#只要关闭浏览器-，session-真的就消失了？" class="headerlink" title="只要关闭浏览器 ，session 真的就消失了？"></a><strong>只要关闭浏览器 ，session 真的就消失了？</strong></h3><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。<br>然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。<br>恰恰是<strong>由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
            <tag> token </tag>
            
            <tag> jwt </tag>
            
            <tag> 认证 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BurpSuite破解</title>
      <link href="/burpsuite-po-jie.html"/>
      <url>/burpsuite-po-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="BurpSuite-破解"><a href="#BurpSuite-破解" class="headerlink" title="BurpSuite 破解"></a>BurpSuite 破解</h1><p>最近系统暴露了毕竟多的安全问题，有必要在安全方法补补课，搞个BurpSuite先学习下。</p><ol><li><p>安装官网Mac版Burp。<a href="https://portswigger.net/burp/releases" target="_blank" rel="noopener">https://portswigger.net/burp/releases</a></p></li><li><p>准备破解的java agent程序</p></li><li><p>将破解程序放置到<code>/Applications/Burp Suite Professional.app/Contents/Resources/app</code>目录下</p></li><li><p>执行以下命令启动注册机</p><pre><code>cd &quot;/Applications/Burp Suite Professional.app/Contents/Resources/app&quot;&quot;/Applications/Burp Suite Professional.app/Contents/Resources/jre.bundle/Contents/Home/bin/java&quot; -jar BurpLoaderKeygen.jar</code></pre></li><li><p>修改<code>/Applications/Burp Suite Professional.app/Contents/vmoptions.txt</code>, 增加以下参数</p><pre><code>--add-opens=java.base/java.lang=ALL-UNNAMED--add-opens=java.base/java.lang=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.Opcodes=ALL-UNNAMED-javaagent:BurpLoaderKeygen.jar-noverify</code></pre><p>可以正常启动了。</p></li></ol><p><strong>附</strong></p><p>提示app已损坏，无法打开，解决方法：</p><pre><code>sudo xattr -r -d com.apple.quarantine /Applications/Burp\ Suite\ Professional.app</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 破解 </tag>
            
            <tag> BurpSuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署chatglm3</title>
      <link href="/chatglm3.html"/>
      <url>/chatglm3.html</url>
      
        <content type="html"><![CDATA[<h1 id="MacBook部署chatglm3-6b"><a href="#MacBook部署chatglm3-6b" class="headerlink" title="MacBook部署chatglm3-6b"></a>MacBook部署chatglm3-6b</h1><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><pre><code>git clone https://github.com/THUDM/ChatGLM3cd ChatGLM3pip install -r requirements.txt</code></pre><h2 id="本地加载模型"><a href="#本地加载模型" class="headerlink" title="本地加载模型"></a>本地加载模型</h2><p><a href="https://huggingface.co/THUDM/chatglm3-6b" target="_blank" rel="noopener">Huggingface</a>  国内网络问题推荐使用镜像站：<a href="https://hf-mirror.com/" target="_blank" rel="noopener">hf-mirror</a> 支持断点续传</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>MacBook M1 Pro 16g 部署</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> transformers <span class="token keyword">import</span> AutoTokenizer<span class="token punctuation">,</span> AutoModel<span class="token comment" spellcheck="true"># 本地模型</span>model_directory <span class="token operator">=</span> <span class="token string">"模型地址路径（推荐绝对路径）"</span><span class="token comment" spellcheck="true">#model_directory = "THUDM/chatglm3-6b"</span>tokenizer <span class="token operator">=</span> AutoTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_directory<span class="token punctuation">,</span> trust_remote_code<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>model <span class="token operator">=</span> AutoModel<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_directory<span class="token punctuation">,</span> trust_remote_code<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>half<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'mps'</span><span class="token punctuation">)</span>model <span class="token operator">=</span> model<span class="token punctuation">.</span>eval<span class="token punctuation">(</span><span class="token punctuation">)</span>response<span class="token punctuation">,</span> history <span class="token operator">=</span> model<span class="token punctuation">.</span>chat<span class="token punctuation">(</span>tokenizer<span class="token punctuation">,</span> <span class="token string">"你好"</span><span class="token punctuation">,</span> history<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span></code></pre><p><img src="https://img.iamghf.top/md/202312271505023.png" alt="image-20231227150509116"></p><p>速度感人，20分钟才出结果。电脑配置不行放弃治疗。。。</p><p>mac优化：</p><pre><code>将/ChatGLM3/composite_demo/client.py中的第140行左右中的device_map = “auto”改为device_map = “mps”</code></pre><p>环境变量：</p><p>export MODEL_PATH=本地模型路径。指定从本地加载模型</p><p>Jupyter 内核，可以通过 <code>export IPYKERNEL=&lt;kernel_name&gt;</code> 来指定。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chatglm3 </tag>
            
            <tag> MacBook M1 Pro </tag>
            
            <tag> chatgpt </tag>
            
            <tag> 大模型 </tag>
            
            <tag> chatglm3-6b </tag>
            
            <tag> 本地部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装配置conda</title>
      <link href="/an-zhuang-pei-zhi-conda.html"/>
      <url>/an-zhuang-pei-zhi-conda.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装配置conda环境"><a href="#安装配置conda环境" class="headerlink" title="安装配置conda环境"></a>安装配置conda环境</h1><h2 id="关于conda"><a href="#关于conda" class="headerlink" title="关于conda"></a>关于conda</h2><pre><code>conda是一个配置隔离python环境的工具因为有些时候我们需要不同版本的python或不同版本的pip模块（比如你需要跑两个从github上下下来的代码，他们的tensorflow版本一个要求1.0一个要求2.0）conda既可以实现pip模块不同版本共存，也可以实现python不同版本共存conda只是一个工具，它有两种发行版，分别是Anaconda和Miniconda    anaconda是一个大而全的工具集合，包括了非常多常用的pip模块（如numpy、pandas、scipy、matplotlib等），它还有图形化的管理工具等    miniconda是一个单纯的conda工具，仅自带极少的python必要的包，干净纯粹，可以按照自己的需求构建任意环境    miniconda比anaconda小非常多，可以实现全部日常需求，只不过需要自己动手</code></pre><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>miniconda下载地址: <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a></p><p>anaconda下载地址: <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a> </p><p>MacOs为例，下载当前最新的安装包<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2023.09-0-MacOSX-arm64.pkg" target="_blank" rel="noopener">Anaconda3-2023.09-0-MacOSX-arm64.pkg</a></p><p>双击执行安装即可。</p><h2 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h2><pre class=" language-shell"><code class="language-shell">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes</code></pre><p>原理是修改在～目录下的.condarc里的配置，直接打开此文件复制进去也可以。</p><p>修改后若想换回原来的源，执行命令：</p><pre class=" language-shell"><code class="language-shell">conda config --remove-key channels</code></pre><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><pre class=" language-shell"><code class="language-shell">conda create -n xxxx python=3.5   #创建python3.5的，名字为xxxx的虚拟环境</code></pre><p>示例：</p><pre class=" language-shell"><code class="language-shell"># 创建版本为2.7的名为venv27conda create --name venv27 python=2.7# 查看已有的虚拟环境conda env list# 进入venv27虚拟环境conda activate venv27# 查看python版本python -V# 退出此虚拟环境（默认进去base环境）conda deactivate# 退出base 环境 到达点击默认环境conda deactivate</code></pre><h2 id="查看环境"><a href="#查看环境" class="headerlink" title="查看环境"></a>查看环境</h2><pre class=" language-shell"><code class="language-shell">conda env list</code></pre><h2 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h2><pre class=" language-shell"><code class="language-shell">conda activate xxx</code></pre><h2 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h2><pre><code>conda remove -n xxxx --all   #删除xxxx虚拟环境conda clean -p      #删除没有用的包 conda clean -t      #删除无用的tar包 conda clean -y --all #删除所有的安装包及cache</code></pre><h2 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h2><pre><code>#pip 安装本地包 pip install   ～/Downloads/a.whl #conda 安装本地包 conda install --use-local  ~/Downloads/a.tar.bz2conda list         #查看已安装的包conda list  -n xxx       #指定查看xxx虚拟环境下安装的包conda update xxx   #更新xxx包 conda uninstall xxx   #卸载xxx包</code></pre><p>参考:</p><p><a href="https://zhuanlan.zhihu.com/p/378258193" target="_blank" rel="noopener">1</a> </p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> conda </tag>
            
            <tag> anaconda </tag>
            
            <tag> miniconda </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小红书引流</title>
      <link href="/xiao-hong-shu-yin-liu.html"/>
      <url>/xiao-hong-shu-yin-liu.html</url>
      
        <content type="html"><![CDATA[<p>正常来说，小红书发链接是无法点击的！<br>所以无法通过链接去引流！<br>但是，小红书自家的域名却可以点击！<br>于是，就有了一次大胆的尝试~</p><p>小红书有一个严重的bug，就是他识别的并不是根域名，而是只要二级域名包含了<a href="http://www.xiaohongshu.com/" target="_blank" rel="noopener">www.xiaohongshu.com</a>就是一个可以点击的链接！</p><p>实现方式简单来说就是：*<em>小红书域名+自己的域名 *</em></p><p>自己的域名： abc.com</p><p>小红书的域名：<a href="http://www.xionghongshu.com" target="_blank" rel="noopener">www.xionghongshu.com</a></p><p>在域名解析中增加一条记录 <a href="http://www.xionghongshu.com.abc.com" target="_blank" rel="noopener">www.xionghongshu.com.abc.com</a></p><p>然后发送到小红书，就是一个可以点击的链接！</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>改成你二维码图片地址<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">max-width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wechat-enable-text-zoom-em<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html; charset<span class="token punctuation">=</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>color-scheme<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>light dark<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width,initial-scale<span class="token punctuation">=</span>1.0,maximum-scale<span class="token punctuation">=</span>1.0,user-scalable<span class="token punctuation">=</span>0,viewport-fit<span class="token punctuation">=</span>cover<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token comment" spellcheck="true">// 这里是跳转到微信的Url Scheme</span>        <span class="token comment" spellcheck="true">// 自己看微信小程序开发文档生成</span>    location<span class="token punctuation">.</span>href<span class="token operator">=</span><span class="token string">"weixin://dl/business/?t=xxx"</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>以上示例代码，就是你自定义的一个页面，然后小红书打开，显示二维码并且跳转到微信小程序暂时你的微信二维码就实现了引流了！</p><p><strong>这样玩可能会封你小红书，仅供学习~</strong></p><p><a href="https://www.52pojie.cn/thread-1860887-1-1.html" target="_blank" rel="noopener"><em>摘自</em></a></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小红书 </tag>
            
            <tag> 引流 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google搜索技巧</title>
      <link href="/google-sou-suo-ji-qiao.html"/>
      <url>/google-sou-suo-ji-qiao.html</url>
      
        <content type="html"><![CDATA[<p>知识爆炸时代，如何快速从海量信息中，获取到自己需要的信息。推荐以下常用的Google搜索小技巧。</p><h2 id="“”"><a href="#“”" class="headerlink" title="“”"></a>“”</h2><p>限定关键字。用法：”关键字”。 在搜索中输入关键字，但搜索出来的结果可能是分词后的结果，使用”“后，搜索结果是不会分词。</p><p><img src="https://img.iamghf.top/md/202311031048344.png" alt="image-20231103104819214"></p><h2 id="intitle"><a href="#intitle" class="headerlink" title="intitle"></a>intitle</h2><p>限定标题。用法：intitle: 关键字。 搜索出来的结果，标题中会包含关键字。</p><p><img src="https://img.iamghf.top/md/202311031050171.png" alt="image-20231103105037636"></p><h2 id="allintitle"><a href="#allintitle" class="headerlink" title="allintitle"></a>allintitle</h2><p>限定标题多个关键字.用法： allintitle:关键字1 关键字2</p><p><img src="https://img.iamghf.top/md/202311031052754.png" alt="image-20231103105231011"></p><h2 id="intext"><a href="#intext" class="headerlink" title="intext"></a>intext</h2><p>限定内容关键字。用法：intext:关键字。</p><p><img src="https://img.iamghf.top/md/202311031054943.png" alt="image-20231103105403448"></p><h2 id="site"><a href="#site" class="headerlink" title="site"></a>site</h2><p>搜索制定网站的内容，用法：关键字 site: 网站。如：Linux site:iamghf.top</p><p><img src="https://img.iamghf.top/md/202311031034138.png" alt="image-20231103103435927"></p><h2 id="filetype"><a href="#filetype" class="headerlink" title="filetype"></a>filetype</h2><p>指定文件类型。用法filetype:文件类型。如filetype:pdf。搜素出来的结果都是pdf文件。</p><p><img src="https://img.iamghf.top/md/202311031057895.png" alt="image-20231103105702293"></p><h2 id="imagesize"><a href="#imagesize" class="headerlink" title="imagesize"></a>imagesize</h2><p>限定图片尺寸。用法imagesize: 图片尺寸。如imagesize:1920X1080, 搜索结果为1920X1080尺寸大小的图片。</p><p><img src="https://img.iamghf.top/md/202311031059426.png" alt="image-20231103105920376"></p><p><strong>ps.</strong>  以上条件可以进行自由组合。如 intext:”2023财富报告”。</p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 信息获取 </tag>
            
            <tag> 搜索条件 </tag>
            
            <tag> 用法 </tag>
            
            <tag> intitle </tag>
            
            <tag> filetype </tag>
            
            <tag> site </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Costco 代购店推荐</title>
      <link href="/costco-dai-gou-dian-tui-jian.html"/>
      <url>/costco-dai-gou-dian-tui-jian.html</url>
      
        <content type="html"><![CDATA[<p>推荐一家Costco代购店。</p><p><a href="https://m.tb.cn/h.5R0VbX0" target="_blank" rel="noopener">苏小小CostcoSAM甄选</a></p><p><img src="https://img.iamghf.top/md/202311021658337.png" alt="https://gqrcode.alicdn.com/img?type=cs&amp;shop_id=113760037&amp;seller_id=1742218004&amp;w=360&amp;h=360&amp;el=q&amp;v=1"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> costco </tag>
            
            <tag> 开市客 </tag>
            
            <tag> 代购 </tag>
            
            <tag> 淘宝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建一个拖垮公司的技术架构</title>
      <link href="/ru-he-da-jian-yi-ge-tuo-kua-gong-si-de-ji-zhu-jia-gou.html"/>
      <url>/ru-he-da-jian-yi-ge-tuo-kua-gong-si-de-ji-zhu-jia-gou.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统主链路尽可能单点"><a href="#系统主链路尽可能单点" class="headerlink" title="系统主链路尽可能单点"></a>系统主链路尽可能单点</h2><p>单点系统，就像苏伊士运河一样，一旦航道出故障，整个运输系统都瘫痪，非常酸爽。</p><p><strong>单点就像单身，开始的时候滋味不好受，但是不用担心，因为后面你就习惯了</strong>。</p><h2 id="程序中多用循环"><a href="#程序中多用循环" class="headerlink" title="程序中多用循环"></a>程序中多用循环</h2><p>无限死循环，是老K最爱用的编程技巧之一，当你看到CPU利用率百分百的时候，你就知道应该甩锅给运维了。</p><p>这年头，没点特长技能还真不行。<strong>比如我，玩得一手好乐器—-退堂鼓，打得特好</strong>。</p><h2 id="系统间增加依赖"><a href="#系统间增加依赖" class="headerlink" title="系统间增加依赖"></a>系统间增加依赖</h2><p>在系统里增加内部依赖、外部依赖、第三方依赖。总之，能依赖的，决不自己动手写。</p><p>有今天的成就，主要是因为我的动手能力强，<strong>我这辈子只有两件事不会：这也不会，那也不会</strong>。</p><h2 id="不做服务补偿"><a href="#不做服务补偿" class="headerlink" title="不做服务补偿"></a>不做服务补偿</h2><p>很多东西，错过就是错过，没法补偿，这就是人生。</p><p>作为架构师，要有哲学高度。</p><p>所以说小伙子，<strong>你只看到了第二层，而你把我只想成了第一层，实际上我是第五层</strong>，你知道我讲的是什么意思吗？</p><h2 id="不做幂等设计"><a href="#不做幂等设计" class="headerlink" title="不做幂等设计"></a>不做幂等设计</h2><p>凭啥后端接口要做幂等性设计？前端提交的时候不做判断吗？全都丢给后端开发做？</p><p>大家都是打工人，<strong>人要脸，树要皮，电线杆子要水泥</strong>。</p><h2 id="不设置超时"><a href="#不设置超时" class="headerlink" title="不设置超时"></a>不设置超时</h2><p>连接超时、读超时，有多大设置多大，不管内部调用还是外部调用，都设置成60分钟。</p><p>只要努力搞，没有时间搞不砸的事情。做不成时间的朋友，就做时间的炮友。</p><h2 id="不控制流量"><a href="#不控制流量" class="headerlink" title="不控制流量"></a>不控制流量</h2><p>让流量来得猛烈一些吧，千万别限流，什么漏桶算法、令牌桶算法，<strong>那都不如啤酒桶算法—-喝完就睡，爱谁谁</strong>。</p><p>还控制啥流量啊？你连体重都控制不了，趁早放弃吧。你看看八戒，<strong>走了十万八千里也没见瘦下来，而且，他还吃素</strong>。</p><h2 id="不做监控预警"><a href="#不做监控预警" class="headerlink" title="不做监控预警"></a>不做监控预警</h2><p>大家都是职场成年人，做好分内事，别多管闲事。</p><p>工作几年以后，我明白一个道理：<strong>熟练的运用“关我屁事”和“关你屁事”，可以省下人生80%的时间</strong>。</p><h2 id="没有重试策略"><a href="#没有重试策略" class="headerlink" title="没有重试策略"></a>没有重试策略</h2><p>服务调用失败，你还想重试？我可不是随便的接口。</p><p><strong>人生不能重来，更不能乱来</strong>。</p><p>不信？<strong>你让医生，给你开点后悔药，再来杯忘情水，医生立马送你去精神病院</strong>。</p><h2 id="不做系统隔离"><a href="#不做系统隔离" class="headerlink" title="不做系统隔离"></a>不做系统隔离</h2><p>千万别做系统隔离，要挂一起挂。</p><p>什么是真正的兄弟？<strong>就是当兄弟需要女人的时候，挺身而出做他的女人</strong>。</p><p>面对困<strong>男</strong>，要排除万<strong>男</strong>，迎<strong>男</strong>而上。</p><h2 id="代码同步调用"><a href="#代码同步调用" class="headerlink" title="代码同步调用"></a>代码同步调用</h2><p>做系统就要步调一致、讲究和谐，尽量同步调用，多写bug。</p><p><strong>通常我写bug的时候，喜欢中午写，知道为什么吗？因为早晚会有报应</strong>。</p><h2 id="不做热数据缓存"><a href="#不做热数据缓存" class="headerlink" title="不做热数据缓存"></a>不做热数据缓存</h2><p>RPC的意义是什么？就是被调用啊。疯狂地调用，是对一个服务最起码的尊重。</p><p>你知道为什么大项目上线都要选个好日子吗？<strong>这么说吧，你认为上线以后还会有好日子吗？</strong></p><h2 id="不做系统分级"><a href="#不做系统分级" class="headerlink" title="不做系统分级"></a>不做系统分级</h2><p>对系统要一视同仁，不要区分核心系统、非核心系统，你有考虑过系统的感受吗？</p><p>如果你被分门别类，你会开心吗？回想起来，<strong>小时候我们都很快乐，就是因为那个时候的我们，丑和穷得都还不是那么明显</strong>。</p><h2 id="没有服务降级"><a href="#没有服务降级" class="headerlink" title="没有服务降级"></a>没有服务降级</h2><p>服务降级就low了，就算宕机也要一起扛。</p><p><strong>人生没有白走的路，如果有，那就是微信运动出bug了</strong>。</p><h2 id="无灰度和回滚方案"><a href="#无灰度和回滚方案" class="headerlink" title="无灰度和回滚方案"></a>无灰度和回滚方案</h2><p>上线全凭运气，没有回滚方案！就是那么自信。</p><p>我这个人，长这么大没学到别的本事，就掌握了一项特殊技能，<strong>白天不用安眠药也能安眠，晚上不用兴奋剂也能兴奋</strong>。</p><p>论熬夜发布，我从来没服过谁。</p><h2 id="程序多做远程调用"><a href="#程序多做远程调用" class="headerlink" title="程序多做远程调用"></a>程序多做远程调用</h2><p>能远程调用的，绝不本地调用，都5G时代了，网络延迟那点事不算什么。</p><p>再说了，做人要有点耐心，女朋友约会迟到一小时，你敢发火吗？</p><h2 id="不做熔断机制"><a href="#不做熔断机制" class="headerlink" title="不做熔断机制"></a>不做熔断机制</h2><p>炒股炒昏头了吧，做啥熔断机制？你问过韭零后吗？基金都绿成啥样了，他喊熔断了吗？</p><p><strong>作为韭菜，学费还是要交的，趁年轻的时候多交点，这样到老了再交你就习惯了</strong>。</p><h2 id="不做代码扫描"><a href="#不做代码扫描" class="headerlink" title="不做代码扫描"></a>不做代码扫描</h2><p>要有工匠精神，自己代码自己review，机器哪里懂得欣赏你的代码艺术？</p><p>我那骚气的注释、奇妙的函数、神乎其技的Copy/Paste。<strong>每次看代码，都被自己的才华吓到</strong>。</p><h2 id="不做线上压测"><a href="#不做线上压测" class="headerlink" title="不做线上压测"></a>不做线上压测</h2><p>上线就完了，后面的事情交给菩萨吧。</p><p>一分耕耘，一分收获。<strong>天下没有免费的午餐，所以我一般都睡到下午才起床</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统一事件管理</title>
      <link href="/tong-yi-shi-jian-guan-li.html"/>
      <url>/tong-yi-shi-jian-guan-li.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzU2MDcwNg==&mid=2247484022&idx=1&sn=d2b9ccd50d9146c642059a4ac9228168&chksm=ceb8fe1bf9cf770d110051a9d70cfb5420a7c7975158a49202a43427f5c1be13aee8992d8589&scene=132&exptype=timeline_recommend_article_extendread_extendread_for_notrec#wechat_redirect" target="_blank" rel="noopener">转载</a></p><p>在生活中，我的衣柜里永远只有深蓝、黑色和灰色三种颜色的衣服。我很少改变，总是给人一种中规中矩的印象。</p><p>在工作中，我不喜欢墨守成规，而是喜欢接受新事物、新方法和新技术，以打破和优化现有的管理、流程、制度和技术等。我持怀疑的、辩证的态度去看待所研发的产品，以更好、更有效率的方式去支持业务的数字化转型。</p><p>我写这篇文章的原因是发现我们的客户、我们自身以及竞争对手等仍在使用十多年前的流程和思想来思考业务和产品的未来。这样所做的产品是没有任何生命力的。做产品必须明确该产品未来的业务发展方向，否则研发出的东西只是应对当前可见的客户需求（项目需求而非产品需求）。只有精准把握业务未来的方向，才能设计出长期、分阶段、持续可销售且有价值产品。</p><p>本文，我将从统一事件管理的过去、现在和未来进行分析，探讨统一事件管理的未来发展趋势，主要包括：</p><ul><li><p>单一告警管理</p></li><li><p>统一告警管理</p></li><li><p>统一事件（incident）管理</p></li><li><p>智能事件（incident）分析及处置</p></li><li><p>总结</p></li></ul><h2 id="单一告警管理"><a href="#单一告警管理" class="headerlink" title="单一告警管理"></a>单一告警管理</h2><p><strong>面临问题</strong></p><p>在这个阶段，由于所运维系统架构简单，而且数据比较少，运维团队还能够很好地应对系统进行运维，并无任何不适。</p><p><strong>主要特征</strong></p><p>本阶段的告警管理大约可以追溯到15年前，相关特征可总结如下：</p><ul><li><p>技术上：大多数系统都是单体应用，系统复杂性非常低，在这个阶段不同的监控工具监控不同的专业领域（机房环境、主机、网络等）。</p></li><li><p>告警种类：比较单一，一般只有有限一种或几种，因此告警的处理也比较简单，很容易让人掌握。</p></li><li><p>人员组成：由于告警的种类单一，对人员的学习成本就会比较低。各不同应用厂商会提供对系统运维的日常手册，出了问题运维团队不需要太多的技术能力和专业技能，只要能够按照手册进行处理即可，如果不能解决只能升级到厂商即可。</p></li><li><p>组织流程：由于分散的监控工具，需要一个统一的地方和流程能够配合进行告警的分配和处置，</p><p>因此早期阶段会采用工单系统。产生告警后进入手工流程或工单系统（较大型组织），进行告警工单的分派和流转，流程通常都比较短，这时处置会比较高效。</p></li></ul><p><strong>业务功能范围</strong></p><p><img src="https://img.iamghf.top/md/202311021537530.png" alt="图片"></p><p>主要业务功能包括：</p><ul><li>监控系统生成异常事件：监控源配置阈值或异常检测算法，生成异常事件(event)。</li><li>对告警进行源端压缩：在配置告警策略时，会一并配置针对告警对象在一定时间范围内连续达到多少次异常之后会生成告警。</li><li>生成告警：生成告警并存储。</li><li>告警通知：会配置相应的通知模板、通知策略并完成对告警的通知。</li><li>告警中心：会有一个告警中心，针对当前监控源产生的告警进行统一存放。</li><li>同步工单：一些流程化比较规范的组织，会通过一些工单类的系统完成对告警转工单的开立，由工单来驱动告警的处置。</li></ul><h2 id="统一告警管理"><a href="#统一告警管理" class="headerlink" title="统一告警管理"></a>统一告警管理</h2><p><strong>面临问题</strong></p><p>在进行统一告警的建设之前，我们发现如下问题：</p><ul><li>告警量大：由于云战略和数字化转型，导致系统的复杂性、应用的数量增加，使得监控对象、监控方法工具等产生的告警量成倍增长。</li><li>人员增长：由于告警量的增大，以及不同领域的组件问题突出，造成人员规模的增长。</li><li>成本增加：人员的增长直接导致成本的巨大支出。</li><li>告警噪音：虽然人员的增长很大，但是依旧不能处理所有的告警，很多告警是无效的，需要对告警进行有效的降噪处理。</li><li>工具重复建设：告警的处理流程基本是一致的，但是因为监控工具的分散，导致不同的流程需要在不同的监控工具进行落地，如：告警工作台、告警分析处置、告警数据的丰富、告警的通知等，不同工具的相同功能重复建设。</li></ul><p><strong>主要特征</strong></p><p>本阶段大约在7年前，相关的特征可总结如下：</p><ul><li>技术上：基于SOA和分布式系统架构的复杂系统已经成为常态。系统变得越来越复杂，因此需要越来越多的监控工具，例如应用监控、用户体验监控、基础设置监控、数据库监控、存储设备、中间件、交易链路等，监控工具不断丰富。</li><li>告警种类：由于技术复杂性的提高，需要更多的监控工具，进而产生越来越多的告警种类和告警。</li><li>人员组成：不同的技术组件以及系统架构的复杂性，要求具有不同领域的专家来专职负责本领域的运维工作，如ORACLE DBA、存储、网络、应用领域的专家等。对应本领域内的专家仅专攻本领域内的问题分析及处置，因此随着系统复杂性的增加，运维团队也需要成倍增加。</li><li>组织流程：随着人员规模的增加，管理方面迫切需要一些有效的流程来协调人员、加速决策效率。以下列出两种不同的做法，它们在不同的流程选择上所带来的系统研发成本、人力投入成本、管理成本、流程线路拉长程度是完全不同的：<ul><li>方法一：我们看到一些南方小城商行采取的做法是，在告警生成后第一时间发出通知，然后完成与工单系统的集成，将告警同步到工单系统中。接下来，工单系统将驱动告警的分派、确认、指派、分析、处置和关闭等操作。运维人员在接收到告警后，还需要登录工单系统进行认领。在分析处置环节，需要登录统一告警查看告警基本信息、登录监控源查看指标曲线以验证告警是否真实，然后再登录自动化平台手动执行一些代码或脚本，容易出错。总结如下缺点：</li></ul></li></ul><p><img src="https://img.iamghf.top/md/202311021537521.png" alt="图片"></p><ul><li><p>流程过长：不利于快速处理告警。</p></li><li><p>集成成本高：需要建立同工单系统的双向信息同步。</p></li><li><p>调查分析效率低：由于工单系统本身是一套流程性的平台，不适合进行调查和分析。这就导致当人们接收到工单后，无法从一个统一的界面完成告警的调查、分析、处置等操作，导致效率过低。</p></li><li><p>方法二：我们也观察到很多银行和头部的券商企业并不会墨守成规，会对流程进行适当的调整。为了快速处置告警并恢复生产，他们会进行以下优化：</p></li></ul><p><img src="https://img.iamghf.top/md/202311021537674.png" alt="图片"></p><ul><li>缩短流程：由于每个告警都已经明确指定了负责处理的运维团队，因此一旦告警产生，相应的运维人员会在第一时间得到通知。运维人员可以立即登录到统一告警平台，并利用该平台的集成能力获取推荐的信息和知识进行分析，以提高排障效率。对于严重的告警，生产恢复后会在工单系统中补充工单以备审计，整个流程非常高效。</li><li>调查分析速度快：统一告警定位为运维人员的日常工作平台，完成了与指标、日志、trace等的集成，并提供了一些自动化或智能化的数据分析功能，帮助运维人员快速分析和处置告警，加速生产恢复。</li><li>集成信息：为了满足运维人员分析和处理告警的需求，统一告警平台与指标、日志、trace、变更单、知识库等进行了集成。</li></ul><ul><li>依赖告警平台提供的信息及集成能力：还有一些南方的小银行表示他们的二线从来不会登录告警平台，只进工单系统。我认为本质原因是他们没有认识到工单系统仅仅是一个流程平台，而对于告警的分析和处理，他们已经习惯了用最笨的方法——登录不同的平台去查信息、手动分析告警。而不思考通过工具系统提高信息收集和分析的效率，以及将分析结果提供给人来做决策，从而提高效率。</li></ul><h2 id="业务功能范围"><a href="#业务功能范围" class="headerlink" title="业务功能范围"></a>业务功能范围</h2><p><img src="https://img.iamghf.top/md/202311021537270.png" alt="图片"></p><p>主要业务功能包括：</p><ul><li>集成：拥有不同监控源告警的集成、变更、自动化平台、指标、日志等的集成能力。</li><li>数据清洗及标准化：企业为了后续告警的分析、处置需求，通常会制定统一的告警数据模型规范。该系统可以针对不同厂商的监控源系统所产生的告警进行统一的数据清洗及标准化操作，然后将数据存入统一告警管理平台。</li><li>数据丰富：由于监控源为了保障快速对接入的指标进行监控的需求，一般只会抛出告警对象、发生时间、发生了什么问题、什么指标发生的问题这四个重要信息，但为了满足对告警的通知、分析、处理需求，需要通过一些数据源完成告警数据的丰富。</li><li>过滤及维护期：针对被运维人员识别为告警噪音的告警需要进行过滤处理。对于在变更阶段所产生的告警，不需要进行通知，这就需要维护期管理的能力。</li><li>压缩降噪：是该系统的核心能力。它可以针对同一告警对象、同一时间段的多个重复告警进行压缩，以降低告警噪音量。</li><li>通知：针对压缩之后的告警，按合适的时间、通过合适的渠道、通知给正确的人进行处置。</li><li>告警工作台是运维人员的统一告警管理工作平台。它可以查看权限控制范围内的告警列表、详情、压缩的原始告警列表、自动收集近期变更及日志和指标信息并展示相关曲线，以及针对告警的认领、指派、关闭、恢复、静默等操作的能力。</li></ul><h2 id="统一事件管理"><a href="#统一事件管理" class="headerlink" title="统一事件管理"></a>统一事件管理</h2><p><strong>面临问题</strong></p><p>在进入本阶段之前，仍然存在以下问题：</p><ul><li>告警量大：尽管在统一告警阶段已经对告警进行了统一的管理、过滤和压缩治理，但要处理的告警量仍然很大，需要一种方法能够更进一步地完成告警的收敛。</li><li>关系复杂：难以识别相互之间的影响。</li><li>人员增长：为了应对数字化转型带来的压力，人员规模持续增长。</li><li>协作不畅：传统的团队分工以及基于工单的流程系统导致相互之间的协作不畅。每次出现事件，需要不同团队之间反复沟通以确认业务上技术上的影响范围，然后再通过工单流系统发起工单，效率低下。</li></ul><p><strong>主要特征</strong></p><p>本阶段的主要特征类似于统一告警管理阶段，但在管理对象、业务流程、组织结构等方面发生了很大的变化：</p><p><img src="https://img.iamghf.top/md/202311021537067.png" alt="图片"></p><ul><li>技术方面：由于数字化转型的需求，对研发效率、系统稳定性、快速满足客户需求等方面提出了更高的要求。大型企业要同时面对老旧的系统架构和新的分布式架构所带来的挑战。即使是规模较小的新创业团队也会采用复杂的分布式应用来保障应用程序的灵活性和高开发效率。</li><li>组织结构方面：一切皆服务。服务所有权模型是一种用于管理现代IT系统的有效模型。它能够将运维团队、开发团队和测试团队连接起来，促进协作，快速响应所运维的IT服务设施，并按服务方式对业务系统的模块进行细粒度的拆分和管理。这种模型更符合现代分布式架构的研发及运维一体化团队组成结构。（后续我会整理针对传统IT架构下的服务所有权模型如何自治建模，以及在应急及事件处置场景下如何替代CMDB使之更容易落地）</li><li>管理及处置对象：由传统的告警转变为事件 (incident)。当发生告警时，可以按照告警路由规则路由到不同的服务模型，对告警进行进一步的收敛生成事件。并将收敛后的事件信息通过各种通知渠道通知给所在的运维团队。其所带来的价值改变如下图所示：</li></ul><p><img src="https://img.iamghf.top/md/202311021538320.png" alt="图片"></p><ul><li><p>人员：由于推行了一系列有效的管理手段、服务所有权模型、告警收敛为事件，人员规模不再像统一告警阶段那样无限制地增长。</p></li><li><p>流程：通过实行服务所有权，业务服务和技术服务得以有效结合。客户的业务投诉和内部用户的电话或工单报障会首先同步到统一事件管理平台，并根据客户投诉所在的业务服务自动创建相应的事件，驱动分析和处理。当事件处理完成后，最新的结果和状态信息会同步给客户服务渠道和工单系统，然后由客户服务团队通知最终用户，避免中间工单环节流转来流转去，加快效率。</p></li></ul><p><strong>业务功能范围</strong></p><p><img src="https://img.iamghf.top/md/202311021538048.png" alt="图片"></p><p>统一事件管理平台在统一告警管理平台的基础上增强了以下能力：</p><ul><li>服务模型管理：服务模型管理是统一事件管理平台的一个增强能力。服务模型除了兼容传统技术架构，可以对业务系统的模块进行细粒度的拆分和管理，还能更好地适应分布式微服务架构，很好地表达服务之间的相互依赖关系。通过服务模型管理，无论是业务服务还是技术服务出现问题，都能更快地定位问题，快速恢复服务，提高系统的稳定性和可靠性。</li><li>服务可视化及影响分析：可以通过可视化的方式展示业务服务由哪些技术服务组件构成，以及它们之间的依赖关系。并可以通过可视化的方式来展示服务之间的关联关系。当发生问题时，通过服务可视化及影响分析，可以追踪一个事件的起源以及它的上下游的影响情况，帮助企业快速了解问题的规模和范围，并采取相应的措施。</li><li>告警关联生成事件（incident）：处理的对象不再是告警，而是有关联关系的事件。可以通过多种方式（如下图所示）将相互之间有关联关系或影响关系的告警组合成事件。运维人员在处理事件时，可以提供更丰富的告警上下文信息，并可以有效降低要处理的告警数量，加速对事件的分析及恢复过程。</li></ul><p><img src="https://img.iamghf.top/md/202311021538434.png" alt="图片"></p><ul><li>用户组绑定服务模型：通过用户组的管理方式将开发、测试、运维团队形成对服务的所有权管理模式，构建开发、运维一体化团队，确保每一个服务都有对应的用户组进行运维。当发生问题时，初级问题由用户组内部的运维团队负责解决，而高级问题则可以直接由测试或开发人员来完成，增强协作效率。</li><li>通知事件（incident）而非告警：通过单个告警会形成大量的噪音干扰，而对最终的运维团队而言，更想知道发生了什么业务、什么服务、什么系统在什么时间发生了什么问题。例如：[二代支付系统]的[跨行转帐服务(1000089)]交易缓慢，支持该业务的3台应用服务器出现GCCOUNT、CPU使用率等5种类型的告警，共计33条关联告警。事件编码:INC202308281535401001，发生时间:2023年08月28日15:35:40。</li><li>事件（incident）管理工作台：形成统一的事件管理工作台，不同的用户群组可以根据自己的数据权限查看相应的事件，并在该工作台上完成对事件的调查、分析和处理操作。</li></ul><h2 id="智能事件分析及处置"><a href="#智能事件分析及处置" class="headerlink" title="智能事件分析及处置"></a>智能事件分析及处置</h2><p><strong>面临问题</strong></p><p>在进入本阶段的设计之前，主要存在如下问题：</p><ul><li>历史处置方案及知识难以有效借鉴。</li><li>占用大量的专家资源，专家经验难以工具化。</li><li>处置效率慢，缺乏自动化排查及分析手段，无法快速定位并修复问题。</li><li>难以从历史事件中获取更深入的洞见。</li></ul><p>…</p><p><strong>主要特征</strong></p><ul><li>积极推行SRE的运维文化：SRE文化的核心是通过事后的复盘分析找到问题的根本原因，通过工程的方法将问题彻底解决，防止下次再次发生，或不能彻底杜绝的情况下可以通过自动化的手段来再次捕捉问题，并进行自动化的响应。通过该文化的落地使运维团队不断治理发现的事件，从而使开发运维团队从告警噪音中解放出来，有更多的时间和精力放到如何优化现有的工具、系统，为客户创造更大的价值上。</li><li>专家经验需要沉淀：通过管理流程和技术手段相结合的方式，使专家对事件的处置经验沉淀到系统中。当再次发生类似的事件时，可以快速借鉴之前类似事件的分析过程和处置方案，加速业务恢复过程。</li><li>可编排的自动化能力：不同情境下的事情是变化的，但是针对人类进行问题排查的过程是相同的。因此，需要一套可编排的自动化排查系统（产品级的），能够根据不同事件情境进行参数化配置。通过按照运维人员针对不同情境的事件变化配置不同的排查策略，当事件发生时能够快速触发排查并产生结论报告，以节省大量的人力，提高排查分析及自动化处置的效率。例如：<ul><li>验证告警与实际情况是否相符：当数据库主机DOWN机时，主机管理员通常会首先使用ping方法进行主机探活操作，以验证是否误报。通过自动化的方法，可以大大降低这类告警的噪音，同时会节省人工排查的时间成本。</li><li>某行二代支付系统故障排查：当发现二代支付系统故障时，首先需要根据告警信息来判断是来报异常、往报异常、渠道异常等情况。如果是来报异常，则可以判断是行外系统异常而非行内系统。这时需要排查前置机是否出现异常。如果前置机未出现异常，则会认为是他行给到的交易出现了问题。重点排查哪个银行发来的交易引起了问题。</li><li>…</li></ul></li><li>推行智能化：包括智能化的根因推荐、智能化的相似事件识别、已知事件的识别和判断、以及针对事件推送相应的知识和处置建议。同时，结合可编排的自动化能力，最终实现数据中心的自治和自愈能力。</li><li>人员规模：由于SRE运维文化的导入，自动化和智能化的普及，团队规模的工作负载会越来越少。</li><li>成为企业数字化转型必不可少的基础设施：智能事件分析及处置平台将成为企业数字化转型必不可少的基础设施。通过该中心，可以链接监控源、变更管理、自动化平台、知识库、通知渠道、客户服务团队、IT服务团队、测试及开发团队，驱动协调整个体系使其高效运转，从而将IT风险最小化。</li></ul><h2 id="业务功能范围-1"><a href="#业务功能范围-1" class="headerlink" title="业务功能范围"></a>业务功能范围</h2><p><img src="https://img.iamghf.top/md/202311021538039.png" alt="图片"></p><p>在统一事件管理平台的基础上提供了如下能力：</p><p><strong>相似事件识别</strong></p><p>在事件处理完成后，需要将事件的分析处理过程记录到智能事件分析和处置平台。当下次类似事件发生时，智能算法会根据事件的特征识别出来，并推荐历史上针对该类事件的处置策略，从而加速事件处理过程。</p><p><strong>可编排的自动化分析能力</strong></p><p>可编排的自动化分析能力是实现AIOPS的最后一公里的关键。在2018年，PAGERDUTY以1亿美金收购了RUNDECK，splunk以3.5亿美金收购了Phantom，以加强其可编排的自动能力。这种能力是智能化运维的核心组件。下面我们看一个主机down机的用例，来看一下该产品所具备的能力：</p><p><img src="https://img.iamghf.top/md/202311021538893.png" alt="图片"></p><ul><li>首先，设置一个触发器来捕捉告警或事件。在这个例子中，我们针对服务器宕机告警进行配置。如上图中圈1位置所示，当告警产生时，如果alert_source=’zabbix’且alert_title=’SERVER_DOWN’，则触发该分析流程。</li><li>进入流程逻辑处理层：<ul><li>第一步：如上图圈2所示，先执行ping指令进行主机探活。执行完成后，解析脚本执行的结果，并生成针对该步骤的中间变量存放在上图圈5所在的位置，以供全局流程使用。</li><li>第二步：如上图圈3所示，执行主机探活返回结果状态的判断。如果STATUS=TRUE，则表示当前主机处于活动状态。</li><li>第三步：如上图圈4所示，如果主机可以ping通，则表明当前告警为误报，需要执行“告警操作”中的“告警关闭”，这样就不会产生告警噪音的通知。如果主机ping不通，则表明主机确实已经down机，当前流程即结束。</li></ul></li></ul><p><img src="https://img.iamghf.top/md/202311021538741.png" alt="图片"></p><ul><li>其它功能说明：<ul><li>配置触发条件支持：<ul><li>捕捉告警或事件进行触发</li><li>通过数据库创建某些记录、更新记录来触发</li><li>定时触发：比较适用于定时对告警进行清理或其它一些特殊的批量操作</li></ul></li></ul></li></ul><p><img src="https://img.iamghf.top/md/202311021538508.png" alt="图片"></p><ul><li>配置执行逻辑：<ul><li>支持条件判断</li><li>支持对数据集的逐条处理逻辑</li><li>支持调用其它的分析流程，如之前创建了一个针对WEBLOGIC告警的排查逻辑，当业务系统发生问题时，也同时要排障WEBLOGIC，这时就可以直接调用其它排查流程。</li><li>等待时间比较适合对告警进行延时类的操作，如延时等待恢复信号再进行通知的流程。</li></ul></li></ul><p><strong>根因推荐</strong></p><p><img src="https://img.iamghf.top/md/202311021539245.png" alt="图片"></p><p>当完成告警聚合为事件后，事件中可能包含多个告警的异常信号。为了找到问题是由什么告警所引起的，系统需要推荐可能的根因，将其推送到运维人员的事件详情页面上以协助其进行判断。运维人员进行分析后，会将结果反馈给系统，算法将重新优化算法的推荐结果。</p><p><strong>已知事件识别</strong></p><p><img src="https://img.iamghf.top/md/202311021539658.png" alt="图片"></p><p>在事件处理过程中，运维人员会总结出大量规律，形成已知事件。针对这些已知事件，会配置快速恢复策略。当出现这种问题时，会触发全自动化或半自动化的处置策略。例如：</p><ul><li>示例1：当 WEBLOGIC 出现 FULLGC 告警，并且在同一时间段出现应用交易响应时间过长的告警时，应该针对该告警主机上 WEBLOGIC 进行的DUPMP 信息收集和服务重启操作，以快速解决该事件。</li><li>示例2：某交易的处理时间变长，且在同一时段出现了该交易的某台AP主机打开文件句柄超限的告警。如果出现这两种类型的告警，则需要对该AP主机进行重启操作。</li><li>…</li></ul><p>在识别出已知事件之后，可以向运维人员推荐处理动作，如上图所示，由运维人员经过判断之后手动触发执行。</p><p><strong>处置方案推荐</strong></p><p>如上图所示，针对已知事件识别之后可以推荐其处置方案。</p><p><strong>知识推荐</strong></p><p>如上图所示，针对已知事件识别之后可以推荐其相关知识和手册。</p><p><strong>自动化处置库管理</strong></p><p>在进行自动化处置时，必须将每个对象类型及其可执行的操作关联起来。这样，在出现已知故障或运维人员分析之后，可以快速锁定针对告警对象可执行的操作列表。可执行的操作一般由自动化平台、云管平台等同步过来，并进行有效的分类管理。真正的执行操作由统一事件管理平台调用自动化平台或云管平台提供的API完成最终的执行动作。</p><p><img src="https://img.iamghf.top/md/202311021539983.png" alt="图片"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>统一事件管理平台的建设非常重要：它是企业数字化转型的基础设施，可以连接监控源、变更管理、自动化平台、知识库、通知渠道、客户服务团队、IT服务团队、测试及开发团队。通过对产生的风险事件进行有效管理，可以驱动整个体系高效运转，最小化IT风险。</li><li>对统一事件管理的认识也非常重要：不论是国内的厂商还是客户，都需要打破固化的思维以及老旧的ITSM流程规范，采用新科技、新方法、新流程和新工具来武装自己，不断优化事件处理流程，从而使数据中心高效运转。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 告警 </tag>
            
            <tag> 事件 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macbook彩虹圈卡顿问题解决</title>
      <link href="/macbook-cai-hong-quan-qia-dun-wen-ti-jie-jue.html"/>
      <url>/macbook-cai-hong-quan-qia-dun-wen-ti-jie-jue.html</url>
      
        <content type="html"><![CDATA[<p>手头MacBook Pro M1 14寸的电脑自从系统升级到13后，就经常出现转彩虹圈圈，而且一旦卡顿开始，除非重启，否则问题不会有所好转。电话咨询了技术支持后，重启，出现 LOGO 之前按住 shift 键进入安全模式，一周内没有出现问题，但后面又频繁出现。一周内至少两次。最近系统又升级到最新的14，问题依然存在。网上翻阅资料，出现卡顿后，在活动监视器把中文输入法强行关闭，就不卡了，也不会转圈。推断是中文输入法导致iCloud卡住，从而导致系统卡顿。</p><p>终极解决方案：</p><ol><li><p>将系统回退到12。</p></li><li><p>或者删除自带的中文输入法，使用第三方输入法。</p></li></ol><p>希望苹果能尽快解决这个bug。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacBook pro </tag>
            
            <tag> m1 </tag>
            
            <tag> 卡顿 </tag>
            
            <tag> 中文输入法 </tag>
            
            <tag> 彩虹圈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>m1 mac上openvpn无法连接排查</title>
      <link href="/mac-shang-openvpn-wu-fa-lian-jie-pai-cha.html"/>
      <url>/mac-shang-openvpn-wu-fa-lian-jie-pai-cha.html</url>
      
        <content type="html"><![CDATA[<p>最近公司openvpn突然连不上了，最开始以为是网络调整导致了。等了几天后发现还不行，让同事在window上连接，发现并没有问题，自己用命令行连接也没问题。简单排查后，最后发现是柠檬清理导致的。<br>只需要，把openvpn相关的服务启动打开就行了。</p><p><img src="https://img.iamghf.top/md/202310242209350.png" alt="image-20231024220925380"></p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> openvpn </tag>
            
            <tag> MacBook m1 </tag>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用Java部署运行脚本</title>
      <link href="/tong-yong-java-yun-xing-jiao-ben.html"/>
      <url>/tong-yong-java-yun-xing-jiao-ben.html</url>
      
        <content type="html"><![CDATA[<p>记录下jar 部署发布脚本。</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash# 主类APP_NAME="$1"APP_MAINCLASS="jxict-digitalvillage-modules-$APP_NAME"# 服务jar包位置和日志位置APP_FILE_PATH="/data/app/$APP_NAME/$APP_MAINCLASS.jar"# 进程ID文件PID_FILE="/data/app/$APP_NAME/$APP_NAME.pid"# 获取进程ID，如果进程不存在则返回0getpid() {   if [ -f "$PID_FILE" ]; then       psid=$(cat "$PID_FILE")   else       psid=0   fi}# 函数：检查进程是否存在# 参数 $1：要检查的进程号# 返回值：如果进程存在，返回 0，否则返回 1checkPid(){    local pid_to_check="$1"    if ps -p "$pid_to_check" > /dev/null; then        return 0  # 进程存在    else        return 1  # 进程不存在    fi}start() {   echo "Starting $APP_MAINCLASS..."   if [ -f "$PID_FILE" ]; then       echo "$APP_NAME is already running."   else       nohup java -jar "$APP_FILE_PATH" --spring.profiles.active=mobile >> "/data/app/$APP_NAME/nohup.log" 2>&1 &       echo "$!" > "$PID_FILE"       echo "Started $APP_NAME. PID: $!"   fi}stop() {   getpid   if [ $psid -ne 0 ]; then       echo "Stopping $APP_MAINCLASS..."       kill "$psid"       rm "$PID_FILE"   else       echo "$APP_NAME is not running."   fi}restart() {     getpid   local jpid=$psid   checkPid $jpid   local flag=$?   stop   while [ $flag -ne 0 ]; do       sleep 1       checkPid $jpid       flag=$?   done   sleep 2   start}method="$2"case "$method" in    "start")        start        ;;    "stop")        stop        ;;    "restart")        restart        ;;    *)        echo "Usage: $0 <app_name> <start|stop|restart>"        exit 1        ;;esac</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> shell </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装MinIO</title>
      <link href="/an-zhuang-minio.html"/>
      <url>/an-zhuang-minio.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装Minio"><a href="#安装Minio" class="headerlink" title="安装Minio"></a>安装Minio</h1><p><strong>下载地址</strong>：<a href="https://minio.org.cn/download.shtml#/linux" target="_blank" rel="noopener">https://minio.org.cn/download.shtml#/linux</a></p><p><strong>编辑启动脚本</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/shexport MINIO_ROOT_USER=adminexport MINIO_ROOT_PASSWORD=admin123nohup /hldata/soft/minio/bin/minio server --address=0.0.0.0:32000 --console-address 0.0.0.0:32001 --config-dir /data/soft/minio /data/soft/minio/data >/data/soft/minio/logs/minio.log 2>&1&</code></pre><pre class=" language-shell"><code class="language-shell">## 添加服务./bin/mc config host add minio http://127.0.0.1:32000 admin admin123## 查看服务列表./bin/mc config host list</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> minio </tag>
            
            <tag> 分布式文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgersql主从配置</title>
      <link href="/pg-zhu-cong.html"/>
      <url>/pg-zhu-cong.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><p>pg版本：10.12.1</p><p>主：172.20.0.231</p><p>备：172.20.0.152</p><p>安装目录：PGHOME = /home/nh/pg/pgsql/</p><p>data目录：PGDATA =  /nhdata/busi_db/</p><h2 id="主数据库"><a href="#主数据库" class="headerlink" title="主数据库"></a>主数据库</h2><p>修改<strong>postgresql.conf</strong>文件</p><pre class=" language-shell"><code class="language-shell">wal_level = hot_standby   #WAL日志信息的输出级别，minimal、replica、logical三种模式synchronous_commit = off    #只能为off，否则主库会一直等待备机响应，备机故障时主机也会出问题max_wal_senders = 10            #默认为10，一个流复制备库通常只需要消耗流复制主库一个WAL 发送进程，必须小于max_connectionswal_keep_segments = 512        #越大越好，根据归档存储空间定，默认单个WAL文件大小为16M，此处512×16MB=8GBhot_standby = on                #开启流复制logging_collector = on        #开启日志log_directory = 'pg_log'    #开启日志路径log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'    #开启日志文件名</code></pre><p>创建<strong><em>replication用户</em></strong></p><pre class=" language-shell"><code class="language-shell">./psql -U postgrescreate user repli replication LOGIN password '123456';</code></pre><p>配置<strong>pg_hba.conf</strong>文件</p><p>添加以下配置，考虑到主备角色互换，建议pg_hba.conf主备完全一样</p><pre class=" language-shell"><code class="language-shell">host    replication      repli      172.20.0.231/32            md5host    replication      repli      172.20.0.152/32            md5</code></pre><p><strong>重启数据库</strong></p><pre class=" language-shell"><code class="language-shell">pg_ctl -D $PGDATA restart</code></pre><h2 id="备数据库"><a href="#备数据库" class="headerlink" title="备数据库"></a>备数据库</h2><p><strong>1)</strong> <strong>测试从服务器能否连接主服务器数据库</strong></p><pre class=" language-shell"><code class="language-shell">psql -h 172.20.0.231 -U postgres#连接成功后停掉从库的服务,清空从节点数据rm –rf $PGDATA/*</code></pre><p><strong>2)</strong> <strong>从主节点拷贝数据到从节点</strong></p><pre class=" language-shell"><code class="language-shell">#pg_basebackup -h 10.251.9.39 -U repli -D $PGDATA -X stream –P ./pgsql/bin/pg_basebackup -D $PGDATA -Fp -Xs -v -P -h 172.20.0.231 -U repli</code></pre><p><strong>3)</strong>  修改<strong>recovery.conf</strong>文件</p><p>复制share目录(pgsql/share/postgresql/recovery.conf.sample)下的recovery.conf.sample文件</p><pre class=" language-shell"><code class="language-shell">cp $PGHOME/share/recovery.conf.sample $PGDATA/recovery.conf</code></pre><p>修改以下配置</p><pre class=" language-shell"><code class="language-shell">standby_mode='on'recovery_target_timeline = 'latest'#配置主机的ip、用户、端口等，repli即主库创建的用于流复制的用户primary_conninfo='host=172.20.0.231 port=5432 user=repli password=123456'trigger_file='/nhdata/busi_db/trigger'</code></pre><p><strong>重启备库</strong></p><pre class=" language-shell"><code class="language-shell">pg_ctl -D $PGDATA restart</code></pre><h2 id="查看主备状态"><a href="#查看主备状态" class="headerlink" title="查看主备状态"></a>查看主备状态</h2><ol><li><p>通过进程查看 ps -aux | grep postgres</p><p>主库为wal sender</p><p>备库为wal receiver</p></li><li><p>执行SQL</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  client_addr<span class="token punctuation">,</span>sync_stat  <span class="token keyword">from</span> pg_stat_replication<span class="token punctuation">;</span><span class="token comment" spellcheck="true">--说明client_addr服务器是从节点，在接收流，而且是异步流复制</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> pg_is_in_recovery<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--主库是false 备库是true</span></code></pre></li><li><p>通过建表、插入数据测试即可</p></li></ol><h2 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h2><h3 id="文件触发方式"><a href="#文件触发方式" class="headerlink" title="文件触发方式"></a>文件触发方式</h3><p>1、配置备库recovery.conf文件trigger_file参数</p><p>2、关闭主库</p><pre class=" language-shell"><code class="language-shell">$ pg_ctl stop -m fast</code></pre><p>3、 在备库上创建trigger_file，</p><pre class=" language-shell"><code class="language-shell">$ touch $PGDATA/trigger</code></pre><p>触发器文件名称和路径需和recovery.conf配置文件trigger_file保持一致，再次查看recovery文件时，发现后辍由原来的.conf变成了.done，表示备库切换为主库成功。</p><p>4、老的主库切换成备库</p><p>拷贝老的备库recovery.done(recovery.conf)文件到新备库，修改IP地址为新主库IP</p><pre class=" language-shell"><code class="language-shell">primary_conninfo='host=172.20.0.152 port=5432 user= repli password=123456'</code></pre><p>5、启动新备库</p><pre class=" language-shell"><code class="language-shell">$ pg_ctl -D $PGDATA start</code></pre><h3 id="pg-ctl-promote方式"><a href="#pg-ctl-promote方式" class="headerlink" title="pg_ctl promote方式"></a>pg_ctl promote方式</h3><p>1、关闭主库</p><pre class=" language-shell"><code class="language-shell">$ pg_ctl stop -m fast</code></pre><p>2、在备库上执行pg_ctl prompt命令激活备库，如果recovery.conf变成recovery.done表示备库已切换成为主库。</p><p>3、 老的主库切换成备库</p><p>拷贝老的备库recovery.done(recovery.conf)文件到老主库，修改IP地址为新主库IP</p><pre class=" language-shell"><code class="language-shell">primary_conninfo='host=172.20.0.152 port=5432 user= repli password=123456'</code></pre><p>4、观察主、备库是否正常</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 主从复制 </tag>
            
            <tag> 主从切换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络IO模型</title>
      <link href="/wang-luo-io-mo-xing.html"/>
      <url>/wang-luo-io-mo-xing.html</url>
      
        <content type="html"><![CDATA[<p>同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，我先限定一下本文的上下文。</p><p>  本文讨论的背景是<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I/O Models ”，Stevens在这节中详细说明了各种IO的特点和区别，如果英文够好的话，推荐直接阅读。Stevens的文风是有名的深入浅出，所以不用担心看不懂。本文中的流程图也是截取自参考文献。</p><p>  Stevens在文章中一共比较了五种IO Model：<br>  * blocking IO<br>  * nonblocking IO<br>  * IO multiplexing<br>  * signal driven IO<br>  * asynchronous IO<br>  由signal driven IO在实际中并不常用，所以主要介绍其余四种IO Model。<br>  再说一下IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：<br>  1）等待数据准备 (Waiting for the data to be ready)<br>  2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)<br>  记住这两点很重要，因为这些IO模型的区别就是在两个阶段上各有不同的情况。<br>  1、阻塞IO（blocking IO）</p><p>  在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081339.jpg" alt="img"></p><p>图1 阻塞IO</p><p>  当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>  <strong>所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。</strong></p><p>  几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv() 等接口开始的，这些接口都是阻塞型的。使用这些接口可以很方便的构建服务器/客户机的模型。下面是一个简单地“一问一答”的服务器。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081232.jpg" alt="图 1. 简单的一问一答的服务器 / 客户机模型"></p><p>图2 简单的一问一答的服务器/客户机模型</p><p>  我们注意到，大部分的socket接口都是阻塞型的。所谓阻塞型接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。<br>  实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用send()的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。</p><p>  一个简单的改进方案是在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。具体使用多进程还是多线程，并没有一个特定的模式。<strong>传统意义上，进程的开销要远远大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问，则进程较为安全。</strong>通常，使用pthread_create ()创建新线程，fork()创建新进程。<br>  我们假设对上述的服务器 / 客户机模型，提出更高的要求，即让服务器同时为多个客户机提供一问一答的服务。于是有了如下的模型。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081233.jpg" alt="图 2. 多线程的服务器模型"></p><p>图3 多线程的服务器模型</p><p>  在上述的线程 / 时间图例中，主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。<br>  很多初学者可能不明白为何一个socket可以accept多次。实际上socket的设计者可能特意为多客户机的情况留下了伏笔，让accept()能够返回一个新的socket。下面是 accept 接口的原型：<br>   int accept(int s, struct sockaddr <em>addr, socklen_t <em>addrlen);<br>  输入参数s是从socket()，bind()和listen()中沿用下来的socket句柄值。执行完bind()和listen()后，<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener">操作系统</a>已经开始在指定的端口处监听所有的连接请求，如果有请求，则将该连接请求加入请求队列。调用accept()接口正是从 socket s 的请求队列抽取第一个连接信息，创建一个与s同类的新的socket返回句柄。新的socket句柄即是后续read()和recv()的输入参数。如果请求队列当前没有请求，则accept() 将进入阻塞状态直到有请求进入队列。<br>  上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。<br>  很多程序员可能会考虑使用</em></em>“线程池”或“连接池”<strong>。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">数据库</a>等。但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，</strong>所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。**<br>  对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</p><p>  <strong>2、非阻塞IO（non-blocking IO</strong>）<br>  Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081438.jpg" alt="img"></p><p>图4 非阻塞IO</p><p>  从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br>  <strong>所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。</strong></p><p>  非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。使用如下的函数可以将某句柄fd设为非阻塞状态。<br>  fcntl( fd, F_SETFL, O_NONBLOCK );<br>  下面将给出只用一个线程，但能够同时从多个连接中检测数据是否送达，并且接受数据的模型。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-81234.jpg" alt="图 3. 使用非阻塞的接收数据模型"></p><p>图5 使用非阻塞的接收数据模型</p><p>  在非阻塞状态下，recv() 接口在被调用后立即返回，返回值代表了不同的含义。如在本例中，<br>  * recv() 返回值大于 0，表示接受数据完毕，返回值即是接受到的字节数；<br>  * recv() 返回 0，表示连接已经正常断开；<br>  * recv() 返回 -1，且 errno 等于 EAGAIN，表示 recv 操作还没执行完成；<br>  * recv() 返回 -1，且 errno 不等于 EAGAIN，表示 recv 操作遇到系统错误 errno。<br>  可以看到服务器线程可以通过循环调用recv()接口，可以在单个线程内实现对所有连接的数据接收工作。但是上述模型绝不被推荐。因为，<strong>循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。</strong><br>  <strong>3、多路复用IO（IO multiplexing）</strong><br>  IO multiplexing这个词可能有点陌生，但是如果我说select/epoll，大概就都能明白了。有些地方也称这种IO方式为<strong>事件驱动IO</strong>(event driven IO)。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081518.jpg" alt="img"></p><p>图6 多路复用IO</p><p>  当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>  这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句：所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>  <strong>在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。</strong>只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似。</p><p>  大部分Unix/Linux都支持select函数，该函数用于探测多个文件句柄的状态变化。下面给出select接口的原型：<br>  FD_ZERO(int fd, fd_set* fds)<br>  FD_SET(int fd, fd_set* fds)<br>  FD_ISSET(int fd, fd_set* fds)<br>  FD_CLR(int fd, fd_set* fds)<br>  int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,<br>  struct timeval *timeout)<br>  这里，fd_set 类型可以简单的理解为按 bit 位标记句柄的队列，例如要在某 fd_set 中标记一个值为16的句柄，则该fd_set的第16个bit位被标记为1。具体的置位、验证可使用 FD_SET、FD_ISSET等宏实现。在select()函数中，readfds、writefds和exceptfds同时作为输入参数和输出参数。如果输入的readfds标记了16号句柄，则select()将检测16号句柄是否可读。在select()返回后，可以通过检查readfds有否标记16号句柄，来判断该“可读”事件是否发生。另外，用户可以设置timeout时间。<br>  下面将重新模拟上例中从多个客户端接收数据的模型。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081234.jpg" alt="图 4. 使用 select() 的接收数据模型"></p><p>图7 使用select()的接收数据模型</p><p>  述模型只是描述了使用select()接口同时从多个客户端接收数据的过程；由于select()接口可以同时对多个句柄进行读状态、写状态和错误状态的探测，所以可以很容易构建为多个客户端提供独立问答服务的服务器系统。如下图。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-81237.jpg" alt="图 5. 使用 select() 接口的基于事件驱动的服务器模型"></p><p>图8 使用select()接口的基于事件驱动的服务器模型</p><p>  这里需要指出的是，客户端的一个 connect() 操作，将在服务器端激发一个“可读事件”，所以 select() 也能探测来自客户端的 connect() 行为。<br>  上述模型中，最关键的地方是如何动态维护select()的三个参数readfds、writefds和exceptfds。作为输入参数，readfds应该标记所有的需要探测的“可读事件”的句柄，其中永远包括那个探测 connect() 的那个“母”句柄；同时，writefds 和 exceptfds 应该标记所有需要探测的“可写事件”和“错误事件”的句柄 ( 使用 FD_SET() 标记 )。<br>  作为输出参数，readfds、writefds和exceptfds中的保存了 select() 捕捉到的所有事件的句柄值。程序员需要检查的所有的标记位 ( 使用FD_ISSET()检查 )，以确定到底哪些句柄发生了事件。<br>  上述模型主要模拟的是“一问一答”的服务流程，所以如果select()发现某句柄捕捉到了“可读事件”，服务器程序应及时做recv()操作，并根据接收到的数据准备好待发送数据，并将对应的句柄值加入writefds，准备下一次的“可写事件”的select()探测。同样，如果select()发现某句柄捕捉到“可写事件”，则程序应及时做send()操作，并准备好下一次的“可读事件”探测准备。下图描述的是上述模型中的一个执行周期。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081235.jpg" alt="图 6. 一个执行周期"></p><p>图9 多路复用模型的一个执行周期</p><p>  这种模型的特征在于每一个执行周期都会探测一次或一组事件，一个特定的事件会触发某个特定的响应。我们可以将这种模型归类为“<strong>事件驱动模型</strong>”。<br>  相比其他模型，使用select() 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。<br>  但这个模型依旧有着很多问题。<strong>首先select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。</strong>很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/dev/poll，…。如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难。<br>  <strong>其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。</strong>如下例，庞大的执行体1的将直接导致响应事件2的执行体迟迟得不到执行，并在很大程度上降低了事件探测的及时性。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081236.jpg" alt="图 7. 庞大的执行体对使用 select() 的事件驱动模型的影响"></p><p>图10 庞大的执行体对使用select()的事件驱动模型的影响</p><p>  幸运的是，有很多高效的事件驱动库可以屏蔽上述的困难，常见的事件驱动库有<strong>libevent库</strong>，还有作为libevent替代者的<strong>libev库</strong>。这些库会根据操作系统的特点选择最合适的事件探测接口，并且加入了信号(signal) 等技术以支持异步响应，这使得这些库成为构建事件驱动模型的不二选择。下章将介绍如何使用libev库替换select或epoll接口，实现高效稳定的服务器模型。</p><p>  实际上，Linux内核从2.6开始，也引入了支持异步响应的IO操作，如aio_read, aio_write，这就是异步IO。</p><p>  <strong>4、异步IO（Asynchronous I/O）</strong><br>  Linux下的asynchronous IO其实用得不多，从内核2.6版本才开始引入。先看一下它的流程：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081559.jpg" alt="img"></p><p>图11 异步IO</p><p>  用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>  用异步IO实现的服务器这里就不举例了，以后有时间另开文章来讲述。异步IO是真正非阻塞的，它不会对请求进程产生任何的阻塞，因此对高并发的网络服务器实现至关重要。<br>  到目前为止，已经将四个IO模型都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。<br>先回答最简单的这个：blocking与non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还在准备数据的情况下会立刻返回。<br>  在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：<br>  * A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>  * An asynchronous I/O operation does not cause the requesting process to be blocked;<br>  两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个系统调用。<strong>non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的。</strong>而asynchronous IO则不一样，当进程发起IO操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p>  还有一种不常用的signal driven IO，即信号驱动IO。总的来说，UNP中总结的<strong>IO模型有5种之多：阻塞IO，非阻塞IO，IO复用，信号驱动IO，异步IO</strong>。前四种都属于同步IO。阻塞IO不必说了。非阻塞IO ，IO请求时加上O_NONBLOCK一类的标志位，立刻返回，IO没有就绪会返回错误，需要请求进程主动轮询不断发IO请求直到返回正确。IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。信号驱动IO，调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间，这一步是阻塞的。<br>异步IO，如定义所说，不会因为IO操作阻塞，IO操作全部完成才通知请求进程。<br>  各个IO Model的比较如图所示：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081645.jpg" alt="img"></p><p>图12 各种IO模型的比较</p><p>  经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor模式</title>
      <link href="/reactor-mo-shi.html"/>
      <url>/reactor-mo-shi.html</url>
      
        <content type="html"><![CDATA[<h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><h2 id="什么是-Reactor-模式"><a href="#什么是-Reactor-模式" class="headerlink" title="什么是 Reactor 模式"></a>什么是 Reactor 模式</h2><p>wiki：</p><blockquote><p>“The reactor design pattern is an event handling pattern for handling service requests delivered concurrently by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to associated request handlers.”</p></blockquote><h2 id="为什么会有-Reactor-呢"><a href="#为什么会有-Reactor-呢" class="headerlink" title="为什么会有 Reactor 呢"></a>为什么会有 Reactor 呢</h2><p>对于应用程序而言，CPU 的处理速度是远远快于 IO 的速度的。如果CPU为了IO操作（例如从Socket读取一段数据）而阻塞显然是不划算的。好一点的方法是分为多进程或者线程去进行处理，但是这样会带来一些进程切换的开销，试想一个进程一个数据读了500ms，期间进程切换到它3次，但是CPU却什么都不能干，就这么切换走了，是不是也不划算？</p><p>这时先驱们找到了事件驱动，或者叫回调的方式，来完成这件事情。这种方式就是，应用业务向一个中间人注册一个回调（event handler），当IO就绪后，就这个中间人产生一个事件，并通知此handler进行处理。这种回调的方式，也体现了“好莱坞原则”（Hollywood principle）-“Don’t call us, we’ll call you”，在我们熟悉的IoC中也有用到。看来软件开发真是互通的！</p><h2 id="Reactor-应用场景"><a href="#Reactor-应用场景" class="headerlink" title="Reactor 应用场景"></a>Reactor 应用场景</h2><p>Reactor 核心是解决多请求问题。一般来说，Thread-Per-Connection 的应用场景并发量不是特别大，如果并发量过大，会导致线程资源瞬间耗尽，导致服务陷入阻塞，这个时候就需要 Reactor 模式来解决这个问题。Reactor 通过多路复用的思想大大减少线程资源的使用。</p><h2 id="Reactor-结构"><a href="#Reactor-结构" class="headerlink" title="Reactor 结构"></a>Reactor 结构</h2><p><img src="https://img.iamghf.top/blog/2020-09-16-095816.jpg" alt="结构"></p><p>上图是 Reactor 模型，主要涉及的类：</p><ul><li><code>Initiation Dispatcher</code>：EventHandler 的容器，用来注册、移除 EventHandler 等；另外，它作为 Reactor 模式的入口调用 Synchronous Event Demultiplexer 的 select 方法以阻塞等待事件的返回，当阻塞事件返回时，将事件发生的 Handle 分发到相应的 EvenHandler 处理。</li><li><code>Even Handler</code>：定义了事件处理的方法。</li><li><code>Handle</code>：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。</li><li><code>Synchronous Event Demultiplexer</code>：使用一个事件循环 ，以阻止所有的资源。当可以启动一个同步操作上的资源不会阻塞，多路分解器发送资源到分发器。</li></ul><h2 id="Reactor-时序图"><a href="#Reactor-时序图" class="headerlink" title="Reactor 时序图"></a>Reactor 时序图</h2><p><img src="https://img.iamghf.top/blog/2020-09-16-095916.jpg" alt="时序图"></p><ol><li>初始化 InitationDispatcher，并初始化一个Handle到EventHandler的Map。</li><li>注册 EvenHandler 到 InitationDispatcher，每个 EventHandler 包含对相应 Handle 的引用，从而建立Handle到EventHandler的映射（Map）。</li><li>调用 InitiationDispatcher 的 handle_events() 方法以启动 Event Loop。在 Event Loop 中，调用 select()方法（Synchronous Event Demultiplexer）阻塞等待Event发生。</li><li>当某个或某些 Handle 的 Event 发生后，select() 方法返回，InitiationDispatcher 根据返回的Handle找到注册的 EventHandler ，并回调该 EventHandler 的 handle_events() 方法。</li><li>在 EventHandler 的 handle_events() 方法中还可以向 InitiationDispatcher 中注册新的 Eventhandler，比如对 AcceptorEventHandler 来说，当有新的 client 连接时，它会产生新的 EventHandler 以处理新的连接，并注册到 InitiationDispatcher 中。</li></ol><h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><h3 id="单线程-Reactor-模式"><a href="#单线程-Reactor-模式" class="headerlink" title="单线程 Reactor 模式"></a>单线程 Reactor 模式</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-100001.jpg" alt="reactor单线程"></p><p><strong>简单来说，接收请求和处理请求是同一线程中处理。</strong></p><p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发或大数据量的应用场景却不合适，主要原因如下： ① 一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的读取和发送； ② 当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</p><h3 id="多线程-Reactor-模式"><a href="#多线程-Reactor-模式" class="headerlink" title="多线程 Reactor 模式"></a>多线程 Reactor 模式</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-100045.jpg" alt="reactor多线程"></p><p><strong>简单来说，接收请求和处理请求是不同线程中处理。</strong></p><p>mainReactor 一般只有一个，主要负责接收客户端的连接并将其传递给 subReactor。subReactor  一般会有多个，主要负责处理与客户端的通信。</p><p>注意：上图使用了<code>Thread Pool</code>来处理耗时的业务逻辑，提高Reactor线程的I/O响应，不至于因为一些耗时的业务逻辑而延迟对后面I/O请求的处理。</p><h2 id="Reactor-的优缺点"><a href="#Reactor-的优缺点" class="headerlink" title="Reactor 的优缺点"></a>Reactor 的优缺点</h2><p>优点：</p><ol><li>大多数设计模式的共性：解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制等。</li><li>更为显著的是对性能的提升，即不需要每个 Client 对应一个线程，减少线程的使用。</li></ol><p>缺点：</p><ol><li>相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。</li><li>Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。</li><li>Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。</li></ol><p>【<a href="https://juejin.im/post/6844903688780120078" target="_blank" rel="noopener">原文</a>】</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> reactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn常用命令</title>
      <link href="/svn-chang-yong-ming-ling.html"/>
      <url>/svn-chang-yong-ming-ling.html</url>
      
        <content type="html"><![CDATA[<h1 id="svn常用命令"><a href="#svn常用命令" class="headerlink" title="svn常用命令"></a>svn常用命令</h1><h2 id="checkout代码"><a href="#checkout代码" class="headerlink" title="checkout代码"></a>checkout代码</h2><pre class=" language-shell"><code class="language-shell">svn co svn://svnbucket.com/xxx/xxx</code></pre><h2 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h2><pre class=" language-shell"><code class="language-shell">svn up</code></pre><h2 id="添加新文件到版本库"><a href="#添加新文件到版本库" class="headerlink" title="添加新文件到版本库"></a>添加新文件到版本库</h2><pre class=" language-shell"><code class="language-shell">svn add filename#添加当前目录下所有java文件svn add *.java# 递归添加当前目录下的所有新文件svn add . --no-ignore --force</code></pre><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><pre class=" language-shell"><code class="language-shell">svn commit -m "提交描述"</code></pre><h2 id="查看log"><a href="#查看log" class="headerlink" title="查看log"></a>查看log</h2><pre class=" language-shell"><code class="language-shell"># 查看指定文件的所有logsvn log Test.java# 查看指定版本号的logsvn log -r 100</code></pre><h2 id="撤销本地文件的修改"><a href="#撤销本地文件的修改" class="headerlink" title="撤销本地文件的修改"></a>撤销本地文件的修改</h2><pre class=" language-shell"><code class="language-shell"># 撤销本地文件的修改（还没提交的）svn revert Test.javasvn revert -r 目录名# 撤销目录下所有本地修改svn revert --recursive 目录名</code></pre><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><pre class=" language-shell"><code class="language-shell"># 查看当前工作区的所有改动svn diff# 查看当前工作区文件与最新版本的差异svn diff Test.java# 指定版本号比较差异svn diff -r 200:201 Test.java# 查看当前工作区和版本301中bin目录的差异svn diff -r 301 bin</code></pre><h2 id="查看当前工作区的状态"><a href="#查看当前工作区的状态" class="headerlink" title="查看当前工作区的状态"></a>查看当前工作区的状态</h2><pre class=" language-shell"><code class="language-shell">svn status</code></pre><h2 id="查看svn信息"><a href="#查看svn信息" class="headerlink" title="查看svn信息"></a>查看svn信息</h2><pre class=" language-shell"><code class="language-shell">svn info</code></pre><h2 id="查看文件列表"><a href="#查看文件列表" class="headerlink" title="查看文件列表"></a>查看文件列表</h2><pre class=" language-shell"><code class="language-shell"># 查看文件列表，可以指定-r查看，查看指定版本号的文件列表svn ls svn ls -r 100</code></pre><h2 id="显示文件的每一行最后是谁修改的"><a href="#显示文件的每一行最后是谁修改的" class="headerlink" title="显示文件的每一行最后是谁修改的"></a>显示文件的每一行最后是谁修改的</h2><pre class=" language-shell"><code class="language-shell">svn blame Test.java</code></pre><h2 id="查看指定版本的文件内容"><a href="#查看指定版本的文件内容" class="headerlink" title="查看指定版本的文件内容"></a>查看指定版本的文件内容</h2><pre class=" language-shell"><code class="language-shell"># 查看指定版本的文件内容，不加版本号就是查看最新版本的svn cat Test.java -r 2</code></pre><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><pre class=" language-shell"><code class="language-shell">svn cleanup</code></pre><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><pre class=" language-shell"><code class="language-shell"># 若想创建了一个文件夹，并且把它加入版本控制，但忽略文件夹中的所有文件的内容svn mkdir spool svn propset svn:ignore '*' spool svn ci -m 'Adding "spool" and ignoring its contents.'# 若想创建一个文件夹，但不加入版本控制，即忽略这个文件夹mkdir spool svn propset svn:ignore 'spool' . svn ci -m 'Ignoring a directory called "spool".'</code></pre><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><pre class=" language-shell"><code class="language-shell"># 切换当前项目到指定分支。服务器上更新新版本我们经常就用这个命令来把当前代码切换到新的分支svn switch svn://svnbucket.com/test/branches/online1.0</code></pre><h2 id="重定向仓库地址"><a href="#重定向仓库地址" class="headerlink" title="重定向仓库地址"></a>重定向仓库地址</h2><pre class=" language-shell"><code class="language-shell"># 重定向仓库地址到新地址svn switch --relocate 原svn地址 新svn地址</code></pre><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><pre class=" language-shell"><code class="language-shell"># 创建分支，从主干创建一个分支保存到branches/online1.0svn cp -m "描述内容" http://svnbucket.com/repos/trunk http://svnbucket.com/repos/branches/online1.0</code></pre><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><pre class=" language-shell"><code class="language-shell"># 合并主干上的最新代码到分支上cd branches/online1.0svn merge http://svnbucket.com/repos/trunk # 分支合并到主干svn merge --reintegrate http://svnbucket.com/repos/branches/online1.0# 删除分支svn rm http://svnbucket.com/repos/branches/online1.0</code></pre><h2 id="查看SVN帮助"><a href="#查看SVN帮助" class="headerlink" title="查看SVN帮助"></a>查看SVN帮助</h2><pre class=" language-shell"><code class="language-shell"># 查看SVN帮助svn help# 查看指定命令的帮助信息svn help commit</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac查看jdk实际位置</title>
      <link href="/mac-cha-kan-jdk.html"/>
      <url>/mac-cha-kan-jdk.html</url>
      
        <content type="html"><![CDATA[<h2 id="mac查看jdk位置"><a href="#mac查看jdk位置" class="headerlink" title="mac查看jdk位置"></a>mac查看jdk位置</h2><p>1、打开终端，输入：/usr/libexec/java_home -V</p><p>   注意：输入命令参数区分大小写(-v是不对的，必须是-V)</p><p>如图：3个红框内依次为：输入命令； 当前Mac已安装jdk目录； Mac默认使用的jdk版本；</p><p><img src="https://img.iamghf.top/blog/2020-05-12-101635.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发分布式架构演进之路</title>
      <link href="/jia-gou-yan-jin-zhi-lu.html"/>
      <url>/jia-gou-yan-jin-zhi-lu.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>本文以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。</p><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><p>在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍：</p><ul><li><strong>分布式</strong><br>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上</li><li><strong>高可用</strong><br>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性</li><li><strong>集群</strong><br>一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性</li><li><strong>负载均衡</strong><br>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的</li><li><strong>正向代理和反向代理</strong><br>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。</li></ul><h2 id="3-架构演进"><a href="#3-架构演进" class="headerlink" title="3. 架构演进"></a>3. 架构演进</h2><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070027.png" alt="img"></p><p>以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往<a href="http://www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。" target="_blank" rel="noopener">www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。</a></p><blockquote><p>随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务</p></blockquote><h3 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="第一次演进：Tomcat与数据库分开部署"></a>第一次演进：Tomcat与数据库分开部署</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-70032.png" alt="img"></p><p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。</p><blockquote><p>随着用户数的增长，并发读写数据库成为瓶颈</p></blockquote><h3 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="第二次演进：引入本地缓存和分布式缓存"></a>第二次演进：引入本地缓存和分布式缓存</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070029.png" alt="img"></p><p>在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p><blockquote><p>缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢</p></blockquote><h3 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="第三次演进：引入反向代理实现负载均衡"></a>第三次演进：引入反向代理实现负载均衡</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-70030.png" alt="img"></p><p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。</p><blockquote><p>反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈</p></blockquote><h3 id="第四次演进：数据库读写分离"><a href="#第四次演进：数据库读写分离" class="headerlink" title="第四次演进：数据库读写分离"></a>第四次演进：数据库读写分离</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070030.png" alt="img"></p><p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p><blockquote><p>业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能</p></blockquote><h3 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="第五次演进：数据库按业务分库"></a>第五次演进：数据库按业务分库</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070031.png" alt="img"></p><p>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p><blockquote><p>随着用户数的增长，单机的写库会逐渐会达到性能瓶颈</p></blockquote><h3 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="第六次演进：把大表拆分为小表"></a>第六次演进：把大表拆分为小表</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070038.png" alt="img"></p><p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。</p><p>这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。</p><p>目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p><blockquote><p>数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈</p></blockquote><h3 id="第七次演进：使用LVS或F5来使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5来使多个Nginx负载均衡" class="headerlink" title="第七次演进：使用LVS或F5来使多个Nginx负载均衡"></a>第七次演进：使用LVS或F5来使多个Nginx负载均衡</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070039.png" alt="img"></p><p>由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。</p><p>此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat，在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。</p><blockquote><p>由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同</p></blockquote><h3 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="第八次演进：通过DNS轮询实现机房间的负载均衡"></a>第八次演进：通过DNS轮询实现机房间的负载均衡</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070032.png" alt="img"></p><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。" target="_blank" rel="noopener">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。</a></p><blockquote><p>随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求</p></blockquote><h3 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="第九次演进：引入NoSQL数据库和搜索引擎等技术"></a>第九次演进：引入NoSQL数据库和搜索引擎等技术</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070033.png" alt="img"></p><p>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。</p><p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p><blockquote><p>引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难</p></blockquote><h3 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="第十次演进：大应用拆分为小应用"></a>第十次演进：大应用拆分为小应用</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070034.png" alt="img"></p><p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。</p><blockquote><p>不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级</p></blockquote><h3 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="第十一次演进：复用的功能抽离成微服务"></a>第十一次演进：复用的功能抽离成微服务</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-70035.png" alt="img"></p><p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p><blockquote><p>不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱</p></blockquote><h3 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"></a>第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070035.png" alt="img"></p><p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。</p><blockquote><p>业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难</p></blockquote><h3 id="第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"><a href="#第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理" class="headerlink" title="第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"></a>第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070036.png" alt="img"></p><p>目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。</p><p>在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在3.14节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。</p><blockquote><p>使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低</p></blockquote><h3 id="第十四次演进：以云平台承载系统"><a href="#第十四次演进：以云平台承载系统" class="headerlink" title="第十四次演进：以云平台承载系统"></a>第十四次演进：以云平台承载系统</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070037.png" alt="img"></p><p>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p><p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：</p><ul><li><strong>IaaS</strong>：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；</li><li><strong>PaaS</strong>：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；</li><li><strong>SaaS</strong>：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</li></ul><blockquote><p>至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论</p></blockquote><h2 id="4-架构设计总结"><a href="#4-架构设计总结" class="headerlink" title="4. 架构设计总结"></a>4. 架构设计总结</h2><ul><li><strong>架构的调整是否必须按照上述演变路径进行？</strong><br>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</li><li><strong>对于将要实施的系统，架构应该设计到什么程度？</strong><br>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。</li><li><strong>服务端架构和大数据架构有什么区别？</strong><br>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。</li><li>有没有一些架构设计的原则？<ul><li>N+1设计。系统中的每个组件都应做到没有单点故障；</li><li>回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本；</li><li>禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；</li><li>监控设计。在设计阶段就要考虑监控的手段；</li><li>多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；</li><li>采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难；</li><li>资源隔离设计。应避免单一业务占用全部资源；</li><li>架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题；</li><li>非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；</li><li>使用商用硬件。商用硬件能有效降低硬件故障的机率；</li><li>快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；</li><li>无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</li></ul></li></ul><p>【<a href="https://segmentfault.com/a/1190000018626163" target="_blank" rel="noopener">原文</a>】</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux防火墙</title>
      <link href="/linux-fang-huo-qiang.html"/>
      <url>/linux-fang-huo-qiang.html</url>
      
        <content type="html"><![CDATA[<p>Linux中有两种防火墙软件，CentOS7.0以上使用的是firewall，CentOS7.0以下使用的是iptables</p><h2 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h2><ul><li>开启防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl start firewalld</code></pre><ul><li>关闭防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl stop firewalld</code></pre><ul><li>查看防火墙状态：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl status firewalld</code></pre><ul><li>设置开机启动：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl enable firewalld</code></pre><ul><li>禁用开机启动：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl disable firewalld</code></pre><ul><li>重启防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">firewall-cmd --reload</code></pre><ul><li>开放端口（修改后需要重启防火墙方可生效）：</li></ul><pre class=" language-shell"><code class="language-shell">firewall-cmd --zone=public --add-port=8080/tcp --permanent</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094056.jpg" alt="展示图片"></p><ul><li>查看开放的端口：</li></ul><pre class=" language-shell"><code class="language-shell">firewall-cmd --list-ports</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094329.jpg" alt="展示图片"></p><ul><li>关闭端口：</li></ul><pre class=" language-shell"><code class="language-shell">firewall-cmd --zone=public --remove-port=8080/tcp --permanent</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094414.jpg" alt=""></p><h2 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>由于CenterOS7.0以上版本并没有预装Iptables,我们需要自行装。</p></blockquote><ul><li><p>安装前先关闭firewall防火墙</p><p><img src="https://img.iamghf.top/blog/2020-09-23-094504.jpg" alt=""></p></li><li><p>安装iptables:</p></li></ul><pre class=" language-shell"><code class="language-shell">yum install iptables</code></pre><ul><li>安装iptables-services:</li></ul><pre class=" language-shell"><code class="language-shell">yum install iptables-services</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>开启防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl start iptables.service</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094545.jpg" alt=""></p><ul><li>关闭防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl stop iptables.service</code></pre><ul><li>查看防火墙状态：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl status iptables.service</code></pre><ul><li>设置开机启动：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl enable iptables.service</code></pre><ul><li>禁用开机启动：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl disable iptables.service</code></pre><ul><li>查看filter表的几条链规则(INPUT链可以看出开放了哪些端口)：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -L -n</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094621.jpg" alt=""></p><ul><li>查看NAT表的链规则：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -t nat -L -n</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094653.jpg" alt=""></p><ul><li>清除防火墙所有规则：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -Fiptables -Xiptables -Z</code></pre><ul><li>给INPUT链添加规则（开放8080端口）：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094720.jpg" alt=""></p><ul><li>查找规则所在行号：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -L INPUT --line-numbers -n</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094800.jpg" alt=""></p><ul><li>根据行号删除过滤规则（关闭8080端口）：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -D INPUT 1</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094933.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> firewall </tag>
            
            <tag> iptables </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装oracle</title>
      <link href="/docker-an-zhuang-oracle.html"/>
      <url>/docker-an-zhuang-oracle.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker安装oracle"><a href="#docker安装oracle" class="headerlink" title="docker安装oracle"></a>docker安装oracle</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><pre class=" language-shell"><code class="language-shell">docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</code></pre><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><pre class=" language-shell"><code class="language-shell">docker run -d -p 1521:1521 --name oracle11 registry.cnhangzhou.aliyuncs.com/helowin/oracle_11g</code></pre><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><pre><code>docker start oracle11</code></pre><p>可能会报以下错</p><blockquote><p>docker: Error response from daemon: OCI runtime create failed: container_linux.go:449；container init caused “write /proc/self/attr/keycreate: permission denied””: unknown.</p></blockquote><p>原因：操作系统已启用SELinux，造成“/proc/self/attr/keycreate” 没有写入权限 使用命令:getenfor查看SELinux运行模式</p><pre class=" language-shell"><code class="language-shell">root@localhost ~]# getenforce#查询SELinux的运行模式Enforcing#当前的SELinux是强制模式[root@localhost ~]# sestatusSELinux status:              enabledSELinuxfs mount:             /selinuxCurrent mode:                enforcingMode from config file:       enforcingPolicy version:              24Policy from config file:     targeted</code></pre><p><strong>解决办法：</strong></p><p><strong>1 永久方法 – 需要重启服务器</strong></p><p>修改/etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。</p><p><strong>2 临时方法 – 设置系统参数</strong></p><p>使用命令setenforce 0</p><p><strong>附：</strong><br>setenforce 1   //设置SELinux 成为enforcing模式<br>setenforce 0   //设置SELinux 成为permissive模式</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><pre class=" language-shell"><code class="language-shell">docker exec -it oracle11 bash</code></pre><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><pre><code>sqlplus /nolog</code></pre><p>可能会报 bash: sqlplus: command not found</p><p>解决方法：</p><ol><li><p>切换到root用户 (密码helowin)</p><pre class=" language-shell"><code class="language-shell">su root</code></pre></li><li><p>编辑profile文件配置ORACLE环境变量</p><pre class=" language-shell"><code class="language-shell">vi /etc/profile</code></pre><p>文件最后添加以下内容</p><pre class=" language-shell"><code class="language-shell">export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2export ORACLE_SID=helowinexport PATH=$ORACLE_HOME/bin:$PATH</code></pre></li><li><p>创建软连接</p><pre class=" language-shell"><code class="language-shell">ln -s $ORACLE_HOME/bin/sqlplus /usr/bin</code></pre></li><li><p>切换到oracle 用户</p><pre class=" language-shell"><code class="language-shell">su - oracle</code></pre></li></ol><h2 id="登录sqlplus并修改sys、system用户密码"><a href="#登录sqlplus并修改sys、system用户密码" class="headerlink" title="登录sqlplus并修改sys、system用户密码"></a>登录sqlplus并修改sys、system用户密码</h2><pre class=" language-shell"><code class="language-shell">sqlplus /nologconn /as sysdba</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">user</span> system identified <span class="token keyword">by</span> system<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">user</span> sys identified <span class="token keyword">by</span> sys<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 添加用户</span><span class="token keyword">create</span> <span class="token keyword">user</span> test identified <span class="token keyword">by</span> <span class="token number">123456</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 赋权</span><span class="token keyword">grant</span> <span class="token keyword">connect</span><span class="token punctuation">,</span>resource<span class="token punctuation">,</span><span class="token number">dba</span> <span class="token keyword">to</span> test<span class="token punctuation">;</span></code></pre><p>有可能报：database not open</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">database</span> <span class="token keyword">open</span><span class="token punctuation">;</span></code></pre><p>还可能报： ORA-01507: database not mounted</p><p>解决办法：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">database</span> mount<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">database</span> <span class="token keyword">open</span><span class="token punctuation">;</span></code></pre><p> 成功修改数据库密码后执行</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> PROFILE <span class="token keyword">DEFAULT</span> <span class="token keyword">LIMIT</span> PASSWORD_LIFE_TIME UNLIMITED<span class="token punctuation">;</span></code></pre><h2 id="客户端登陆"><a href="#客户端登陆" class="headerlink" title="客户端登陆"></a>客户端登陆</h2><p>容器内查看oracle 的 lsnrctl 服务</p><pre><code>lsnrctl status</code></pre><p><img src="https://img.iamghf.top/blog/2020-08-17-064402.png" alt="img"></p><p>看到两个Service，任选其一，修改 <strong>tnsnames.ora的 service_name=helowinXDB</strong></p><p>tns样例：</p><pre><code>docker_oracle11 = (DESCRIPTION =   (ADDRESS_LIST =     (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.30.31)(PORT =1521))   )   (CONNECT_DATA =     (SERVICE_NAME = helowinXDB)   ))</code></pre><p><strong><em>附</em></strong></p><p>docker 启动容器报错</p><blockquote><h1 id="iptables-failed-iptables-–wait-t-nat-A-DOCKER-p-tcp-d-0-0-–dport-3000-j-DNAT-–to-destination-172-17-0-3-3000-i-docker0-iptables-No-chain-target-match-by-that-name"><a href="#iptables-failed-iptables-–wait-t-nat-A-DOCKER-p-tcp-d-0-0-–dport-3000-j-DNAT-–to-destination-172-17-0-3-3000-i-docker0-iptables-No-chain-target-match-by-that-name" class="headerlink" title="iptables failed: iptables –wait -t nat -A DOCKER -p tcp -d 0/0 –dport 3000 -j DNAT –to-destination 172.17.0.3:3000 ! -i docker0: iptables: No chain/target/match by that name."></a>iptables failed: iptables –wait -t nat -A DOCKER -p tcp -d 0/0 –dport 3000 -j DNAT –to-destination 172.17.0.3:3000 ! -i docker0: iptables: No chain/target/match by that name.</h1></blockquote><p>解决方法</p><p>重启docker服务</p><pre class=" language-shell"><code class="language-shell">sudo systemctl restart docker</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非root安装docker</title>
      <link href="/fei-root-an-zhuang-docker.html"/>
      <url>/fei-root-an-zhuang-docker.html</url>
      
        <content type="html"><![CDATA[<h1 id="非root安装docker"><a href="#非root安装docker" class="headerlink" title="非root安装docker"></a>非root安装docker</h1><h2 id="添加docker组"><a href="#添加docker组" class="headerlink" title="添加docker组"></a>添加docker组</h2><pre class=" language-shell"><code class="language-shell">cat /etc/group |grep dockersudo groupadd dockersudo gpasswd -a 用户名 docker</code></pre><h2 id="下载docker源码"><a href="#下载docker源码" class="headerlink" title="下载docker源码"></a>下载docker源码</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/static/stable/x86_64/docker-18.09.0.tgz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/static/stable/x86_64/docker-18.09.0.tgz</a></p><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><pre class=" language-shell"><code class="language-shell">tar -zxvf docker-18.09.0.tgzsudo cp docker/* /usr/bin/#docker有关指令的所属用户和所属组(必做,不然非root用户使用docker指令报错:权限不够)sudo chown root:docker /usr/bin/docker*sudo chown root:docker /usr/bin/containerd*sudo chown root:docker /usr/bin/runcsudo chown root:docker /usr/bin/ctr</code></pre><p>查看下</p><p><img src="https://img.iamghf.top/blog/2020-08-17-063405.png" alt="img"></p><h2 id="设置docker服务"><a href="#设置docker服务" class="headerlink" title="设置docker服务"></a>设置docker服务</h2><p>新建</p><pre class=" language-shell"><code class="language-shell">sudo vi /etc/systemd/system/docker.service</code></pre><p>内容如下：</p><pre><code>[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target[Service]Type=notifyExecStart=/usr/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPIDLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityTimeoutStartSec=0Delegate=yesKillMode=processRestart=on-failureStartLimitBurst=3StartLimitInterval=60s[Install]WantedBy=multi-user.target</code></pre><p>添加权限</p><pre class=" language-shell"><code class="language-shell">sudo chmod a+x /etc/systemd/system/docker.servicesudo systemctl daemon-reload</code></pre><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>新建</p><pre class=" language-shell"><code class="language-shell">sudo vi /etc/docker/daemon.json </code></pre><p>添加以下内容</p><pre><code>{&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}</code></pre><h2 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h2><pre class=" language-shell"><code class="language-shell">sudo systemctl start docker</code></pre><p>附</p><pre><code>启/停/重启/查看状态sudo systemctl  start/stop/restart/status</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos安装Postgresql</title>
      <link href="/centos-an-zhuang-postgresql.html"/>
      <url>/centos-an-zhuang-postgresql.html</url>
      
        <content type="html"><![CDATA[<h1 id="centos-离线安装Postgresql"><a href="#centos-离线安装Postgresql" class="headerlink" title="centos 离线安装Postgresql"></a>centos 离线安装Postgresql</h1><h2 id="本机上传压缩包"><a href="#本机上传压缩包" class="headerlink" title="本机上传压缩包"></a>本机上传压缩包</h2><pre class=" language-shell"><code class="language-shell">scp ./postgresql-10.12-1-linux-x64-binaries.tar.gz 用户名@远程主机:/home/dbdev/postgreSql</code></pre><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><pre class=" language-shell"><code class="language-shell">tar -zxvf postgresql-10.12-1-linux-x64-binaries.tar.gz</code></pre><h2 id="创建数据库数据目录"><a href="#创建数据库数据目录" class="headerlink" title="创建数据库数据目录"></a>创建数据库数据目录</h2><pre class=" language-shell"><code class="language-shell">mkdir data</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre class=" language-shell"><code class="language-shell">./pgsql/bin/initdb -U postgres -D pgsql/data</code></pre><p>可能会报以下错误：</p><blockquote><p>initdb: invalid locale settings; check LANG and LC_* environment variables</p></blockquote><pre class=" language-shell"><code class="language-shell">./pgsql/bin/initdb -U postgres -D pgsql/data --locale=zh_CN.UTF-8 -E UTF-8</code></pre><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><pre><code>vi pgsql/data/postgresql.conf</code></pre><p> #listen_addresses = ‘localhost’,去掉注释，改为listen_addresses = ‘*’</p><p> #port = 5432，去掉注释</p><pre class=" language-shell"><code class="language-shell">vi pgsql/data/pg_hba.conf</code></pre><p>将IPv4 的trust改为md5</p><p>并且在下面新增一行</p><p>host  all       all       0.0.0.0/0        md5</p><p><img src="https://img.iamghf.top/blog/2020-08-17-062837.png" alt="image-20200812162036467"></p><h2 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h2><pre class=" language-shell"><code class="language-shell">./pgsql/bin/pg_ctl -D pgsql/data/ start</code></pre><h2 id="设置superuser密码"><a href="#设置superuser密码" class="headerlink" title="设置superuser密码"></a>设置superuser密码</h2><p>./pgsql/bin/psql -U postgres</p><p>postgres#= \password postgres</p><p>修改完\q退出</p><h2 id="重启数据库"><a href="#重启数据库" class="headerlink" title="重启数据库"></a>重启数据库</h2><pre class=" language-shell"><code class="language-shell">./pgsql/bin/pg_ctl -D pgsql/data/ restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
            <tag> centos </tag>
            
            <tag> linux </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非root安装mysql</title>
      <link href="/centos-an-zhuang-mysql.html"/>
      <url>/centos-an-zhuang-mysql.html</url>
      
        <content type="html"><![CDATA[<h1 id="非root安装mysql"><a href="#非root安装mysql" class="headerlink" title="非root安装mysql"></a>非root安装mysql</h1><h2 id="本机上传压缩包"><a href="#本机上传压缩包" class="headerlink" title="本机上传压缩包"></a>本机上传压缩包</h2><pre class=" language-shell"><code class="language-shell">scp mysql-5.7.29-linux-glibc2.12-x86_64.tar.gz 用户名@远程主机:/home/dbdev/mysql</code></pre><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><pre class=" language-shell"><code class="language-shell">tar -zxvf mysql-5.7.29-linux-glibc2.12-x86_64.tar.gzmv mysql-5.7.29-linux-glibc2.12-x86_64 mysql</code></pre><h2 id="创建实例数据目录"><a href="#创建实例数据目录" class="headerlink" title="创建实例数据目录"></a>创建实例数据目录</h2><pre class=" language-shell"><code class="language-shell">mkdir data log</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre class=" language-shell"><code class="language-shell">./mysql/bin/mysqld --initialize --user=dbdev --basedir=/home/dbdev/mysql/mysql --datadir=/home/dbdev/mysql/data</code></pre><p>可能报以下错：</p><pre><code>error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory</code></pre><p>解决方法：</p><ol><li>查看是否安装 rpm -qa|grep libaio  </li><li>yum install  libaio （需要root权限）</li></ol><p>初始化成功后记下这个随机密码，后面要用到</p><p><img src="https://img.iamghf.top/blog/2020-08-14-074754.png" alt="image-20200813093635999"></p><h2 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h2><p>vi ./mysql/mysql.cnf</p><pre><code>[client]port=3306socket=/home/dbdev/mysql/mysql/mysql.sock[mysqld]port=3306#设置mysql的安装目录basedir=/home/dbdev/mysql/mysql# 设置mysql数据库的数据的存放目录datadir=/home/dbdev/mysql/datapid-file=/home/dbdev/mysql/mysql/mysql.pidsocket=/home/dbdev/mysql/mysql/mysql.socklog_error=/home/dbdev/mysql/log/error.logcollation_server=utf8_general_ci# 服务端使用的字符集默认为8比特编码的latin1字符集character_set_server=utf8log-bin=/home/dbdev/mysql/log/mysql-binserver-id=100</code></pre><h2 id="mysqld-safe模式启动数据库"><a href="#mysqld-safe模式启动数据库" class="headerlink" title="mysqld_safe模式启动数据库"></a>mysqld_safe模式启动数据库</h2><pre class=" language-shell"><code class="language-shell">./mysql/bin/mysqld_safe --defaults-file=/home/dbdev/mysql/mysql/mysql.cnf --user=dbdev &</code></pre><h2 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h2><p>登陆mysql</p><pre class=" language-shell"><code class="language-shell">./mysql/bin/mysql -u root -p</code></pre><p>可能会报以下错：</p><pre><code>ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)</code></pre><p><img src="https://img.iamghf.top/blog/2020-08-14-074755.png" alt="image-20200813094110879"></p><p>解决方法：</p><pre><code>ln -s /home/dbdev/mysql/mysql/mysql.sock /tmp/mysql.sock</code></pre><p>或者</p><pre class=" language-shell"><code class="language-shell">./mysql/bin/mysql -u root -p -S /home/dbtest/mysql/mysql/mysql.sock</code></pre><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><pre class=" language-shell"><code class="language-shell">set password for 'root'@'localhost' = password('nh123456');flush privileges;</code></pre><h2 id="开启远程控制"><a href="#开启远程控制" class="headerlink" title="开启远程控制"></a>开启远程控制</h2><pre class=" language-shell"><code class="language-shell">grant all privileges on 数据库名.表名 to 创建的用户名(root)@"%" identified by "密码"; # 数据库名.表名 如果写成*.*代表授权所有的数据库 # grant all privileges on *.* to root@"113.64.243.1" identified by "123456789";# grant all privileges on *.* to 'root'@'%' identified by 'nh123456' with grant option;flush privileges;</code></pre><p>@ 后面是访问mysql的客户端IP地址（或是 主机名） % 代表任意的客户端，如果填写 localhost 为本地访问（那此用户就不能远程访问该mysql数据库了）。</p><p>同时也可以为现有的用户设置是否具有远程访问权限。</p><h2 id="停止mysqld-safe模式改为正常启动"><a href="#停止mysqld-safe模式改为正常启动" class="headerlink" title="停止mysqld_safe模式改为正常启动"></a>停止mysqld_safe模式改为正常启动</h2><pre class=" language-shell"><code class="language-shell">ps -ef|grep mysql kill -9 30379./mysql/bin/mysqld --defaults-file=/home/dbdev/mysql/mysql/mysql.cnf  --user=dbdev &</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下Cornerstone添加外部对比工具Beyond Compare</title>
      <link href="/cornerstone.html"/>
      <url>/cornerstone.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下Cornerstone添加外部对比工具Beyond-Compare"><a href="#Mac下Cornerstone添加外部对比工具Beyond-Compare" class="headerlink" title="Mac下Cornerstone添加外部对比工具Beyond Compare"></a>Mac下Cornerstone添加外部对比工具Beyond Compare</h1><h2 id="Beyond-Compare-安装命令行工具"><a href="#Beyond-Compare-安装命令行工具" class="headerlink" title="Beyond Compare 安装命令行工具"></a>Beyond Compare 安装命令行工具</h2><p>点击 Beyond Compare-》安装命令行工具</p><p><img src="https://img.iamghf.top/blog/2020-06-08-072826.png" alt="image-20200605103951242"></p><h2 id="创建shell脚本"><a href="#创建shell脚本" class="headerlink" title="创建shell脚本"></a>创建shell脚本</h2><pre class=" language-shell"><code class="language-shell">vim bc.sh</code></pre><p>内容如下：</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashoriginal_path="$1"modified_path="$3"/usr/local/bin/bcompare"$original_path" "$modified_path"</code></pre><p>授权可执行 <strong>chmod +x bc.sh</strong></p><h2 id="Cornerstone-添加脚本"><a href="#Cornerstone-添加脚本" class="headerlink" title="Cornerstone 添加脚本"></a>Cornerstone 添加脚本</h2><p>prefrences-&gt;general-&gt;external compare tool-&gt;open script foder</p><p>将bc.sh文件移动到此目录</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
            <tag> Cornerstone </tag>
            
            <tag> byond compare </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeyondCompare</title>
      <link href="/beyondcompare.html"/>
      <url>/beyondcompare.html</url>
      
        <content type="html"><![CDATA[<h1 id="苹果系统白嫖BeyondCompare"><a href="#苹果系统白嫖BeyondCompare" class="headerlink" title="苹果系统白嫖BeyondCompare"></a>苹果系统白嫖BeyondCompare</h1><h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><p><a href="https://www.scootersoftware.com/download.php" target="_blank" rel="noopener">官网下载</a></p><p>解压缩 拖至应用程序目录</p><h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><p>打开终端进入安装好的Beyond Compare目录</p><pre class=" language-shell"><code class="language-shell">cd /Applications/Beyond Compare.app/Contents/MacOS</code></pre><h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><p>修改启动程序文件BCompare为BCompare.real</p><pre><code>mv BCompare BCompare.real</code></pre><h2 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h2><p>当前目录下新建一个文件BCompare</p><pre><code>vim BCompare</code></pre><h2 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h2><p>输入以下内容</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashrm "/Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat""`dirname "$0"`"/BCompare.real $@</code></pre><h2 id="step6"><a href="#step6" class="headerlink" title="step6"></a>step6</h2><p>修改文件权限</p><pre class=" language-shell"><code class="language-shell">chmod a+x /Applications/Beyond\ Compare.app/Contents/MacOS/BCompare</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> beyondcompare </tag>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet 工作原理</title>
      <link href="/servlet-gong-zuo-yuan-li.html"/>
      <url>/servlet-gong-zuo-yuan-li.html</url>
      
        <content type="html"><![CDATA[<h2 id="从-Servlet-容器说起"><a href="#从-Servlet-容器说起" class="headerlink" title="从 Servlet 容器说起"></a>从 Servlet 容器说起</h2><p>要介绍 Servlet 必须要先把 Servlet 容器说清楚，Servlet 与 Servlet 容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。虽然它们是彼此依存的，但是又相互独立发展，这一切都是为了适应工业化生产的结果。从技术角度来说是为了解耦，通过标准化接口来相互协作。既然接口是连接 Servlet 与 Servlet 容器的关键，那我们就从它们的接口说起。</p><p>前面说了 Servlet 容器作为一个独立发展的标准化产品，目前它的种类很多，但是它们都有自己的市场定位，很难说谁优谁劣，各有特点。例如现在比较流行的 Jetty，在定制化和移动领域有不错的发展，我们这里还是以大家最为熟悉 Tomcat 为例来介绍 Servlet 容器如何管理 Servlet。Tomcat 本身也很复杂，我们只从 Servlet 与 Servlet 容器的接口部分开始介绍，关于 Tomcat 的详细介绍可以参考我的另外一篇文章《 Tomcat 系统架构与模式设计分析》。</p><p>Tomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式。</p><h5 id="图-1-Tomcat-容器模型"><a href="#图-1-Tomcat-容器模型" class="headerlink" title="图 1 . Tomcat 容器模型"></a>图 1 . Tomcat 容器模型</h5><p><img src="https://img.iamghf.top/blog/20200421150709.png" alt="Tomcat 容器模型"></p><p>从上图可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程，在 Tomcat 的配置文件中可以很容易发现这一点，如下：</p><h5 id="清单-1-Context-配置参数"><a href="#清单-1-Context-配置参数" class="headerlink" title="清单 1 Context 配置参数"></a>清单 1 Context 配置参数</h5><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Context</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/projectOne <span class="token punctuation">"</span></span> <span class="token attr-name">docBase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>D:\projects\projectOne<span class="token punctuation">"</span></span>         <span class="token attr-name">reloadable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>下面详细介绍一下 Tomcat 解析 Context 容器的过程，包括如何构建 Servlet 的过程。</p><h3 id="Servlet-容器的启动过程"><a href="#Servlet-容器的启动过程" class="headerlink" title="Servlet 容器的启动过程"></a>Servlet 容器的启动过程</h3><p>Tomcat7 也开始支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，我们还可以通过这个对象来增加和修改 Tomcat 的配置参数，如可以动态增加 Context、Servlet 等。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。</p><h5 id="清单-2-给-Tomcat-增加一个-Web-工程"><a href="#清单-2-给-Tomcat-增加一个-Web-工程" class="headerlink" title="清单 2 . 给 Tomcat 增加一个 Web 工程"></a>清单 2 . 给 Tomcat 增加一个 Web 工程</h5><pre class=" language-java"><code class="language-java">Tomcat tomcat <span class="token operator">=</span> <span class="token function">getTomcatInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> File appDir <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token function">getBuildDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"webapps/examples"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tomcat<span class="token punctuation">.</span><span class="token function">addWebapp</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"/examples"</span><span class="token punctuation">,</span> appDir<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tomcat<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ByteChunk res <span class="token operator">=</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token string">"http://localhost:"</span> <span class="token operator">+</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                         <span class="token string">"/examples/servlets/servlet/HelloWorldExample"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">assertTrue</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"&lt;h1>Hello World!&lt;/h1>"</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 1 的代码是创建一个 Tomcat 实例并新增一个 Web 应用，然后启动 Tomcat 并调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。</p><p>Tomcat 的 addWebapp 方法的代码如下：</p><h5 id="清单-3-Tomcat-addWebapp"><a href="#清单-3-Tomcat-addWebapp" class="headerlink" title="清单 3 .Tomcat.addWebapp"></a>清单 3 .Tomcat.addWebapp</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Context <span class="token function">addWebapp</span><span class="token punctuation">(</span>Host host<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> String path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">silence</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        Context ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">setPath</span><span class="token punctuation">(</span> url <span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">setDocBase</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>defaultRealm <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">initSimpleAuth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ctx<span class="token punctuation">.</span><span class="token function">setRealm</span><span class="token punctuation">(</span>defaultRealm<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">addLifecycleListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultWebXmlListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ContextConfig ctxCfg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContextConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">addLifecycleListener</span><span class="token punctuation">(</span>ctxCfg<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctxCfg<span class="token punctuation">.</span><span class="token function">setDefaultWebXml</span><span class="token punctuation">(</span><span class="token string">"org/apache/catalin/startup/NO_DEFAULT_XML"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>host <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            host<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ctx<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>前面已经介绍了一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径，这个两个参数与清单 1 中的两个参数是一致的。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作，后面将会详细介绍。最后将这个 Context 容器加到父容器 Host 中。</p><p>接下去将会调用 Tomcat 的 start 方法启动 Tomcat，如果你清楚 Tomcat 的系统架构，你会容易理解 Tomcat 的启动逻辑，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener），关于这个设计模式可以参考《 Tomcat 的系统架构与设计模式，第二部分：设计模式》。Tomcat 启动的时序图可以用图 2 表示。</p><h5 id="图-2-Tomcat-主要类的启动时序图（查看大图）"><a href="#图-2-Tomcat-主要类的启动时序图（查看大图）" class="headerlink" title="图 2. Tomcat 主要类的启动时序图（查看大图）"></a>图 2. Tomcat 主要类的启动时序图（<a href="https://img.iamghf.top/blog/20200421151241.png" target="_blank" rel="noopener">查看大图</a>）</h5><p><img src="https://img.iamghf.top/blog/20200421151241.png" alt="图 2. Tomcat 主要类的启动时序图"></p><p>上图描述了 Tomcat 启动过程中，主要类之间的时序关系，下面我们将会重点关注添加 examples 应用所对应的 StandardContext 容器的启动过程。</p><p>当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用清单 3 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。</p><p>ContextConfig 的 init 方法将会主要完成以下工作：</p><ol><li>创建用于解析 xml 配置文件的 contextDigester 对象</li><li>读取默认 context.xml 配置文件，如果存在解析它</li><li>读取默认 Host 配置文件，如果存在解析它</li><li>读取默认 Context 自身的配置文件，如果存在解析它</li><li>设置 Context 的 DocBase</li></ol><p>ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：</p><ol><li>创建读取资源文件的对象</li><li>创建 ClassLoader 对象</li><li>设置应用的工作目录</li><li>启动相关的辅助类如：logger、realm、resources 等</li><li>修改启动状态，通知感兴趣的观察者（Web 应用的配置）</li><li>子容器的初始化</li><li>获取 ServletContext 并设置必要的参数</li><li>初始化“load on startup”的 Servlet</li></ol><h3 id="Web-应用的初始化工作"><a href="#Web-应用的初始化工作" class="headerlink" title="Web 应用的初始化工作"></a>Web 应用的初始化工作</h3><p>Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。</p><p>Tomcat 首先会找 globalWebXml 这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。接着会找 hostWebXml 这个文件可能会在 System.getProperty(“catalina.base”)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。如果当前应用支持 Servlet3.0，解析还将完成额外 9 项工作，这个额外的 9 项工作主要是为 Servlet3.0 新增的特性，包括 jar 包中的 META-INF/web-fragment.xml 的解析以及对 annotations 的支持。</p><p>接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。下面是解析 Servlet 的代码片段：</p><h5 id="清单-4-创建-Wrapper-实例"><a href="#清单-4-创建-Wrapper-实例" class="headerlink" title="清单 4. 创建 Wrapper 实例"></a>清单 4. 创建 Wrapper 实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>ServletDef servlet <span class="token operator">:</span> servlets<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Wrapper wrapper <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">createWrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String jspFile <span class="token operator">=</span> servlet<span class="token punctuation">.</span><span class="token function">getJspFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>jspFile <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">setJspFile</span><span class="token punctuation">(</span>jspFile<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getLoadOnStartup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getLoadOnStartup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">setEnabled</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">booleanValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            wrapper<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getServletName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> params <span class="token operator">=</span> servlet<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> params<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">addInitParameter</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            wrapper<span class="token punctuation">.</span><span class="token function">setRunAs</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getRunAs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>SecurityRoleRef<span class="token operator">></span> roleRefs <span class="token operator">=</span> servlet<span class="token punctuation">.</span><span class="token function">getSecurityRoleRefs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>SecurityRoleRef roleRef <span class="token operator">:</span> roleRefs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">addSecurityReference</span><span class="token punctuation">(</span> roleRef<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> roleRef<span class="token punctuation">.</span><span class="token function">getLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            wrapper<span class="token punctuation">.</span><span class="token function">setServletClass</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getServletClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            MultipartDef multipartdef <span class="token operator">=</span> servlet<span class="token punctuation">.</span><span class="token function">getMultipartDef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>multipartdef <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>multipartdef<span class="token punctuation">.</span><span class="token function">getMaxFileSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                        multipartdef<span class="token punctuation">.</span><span class="token function">getMaxRequestSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                        multipartdef<span class="token punctuation">.</span><span class="token function">getFileSizeThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    wrapper<span class="token punctuation">.</span><span class="token function">setMultipartConfigElement</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MultipartConfigElement</span><span class="token punctuation">(</span>                            multipartdef<span class="token punctuation">.</span><span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Long<span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>multipartdef<span class="token punctuation">.</span><span class="token function">getMaxFileSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Long<span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>multipartdef<span class="token punctuation">.</span><span class="token function">getMaxRequestSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span> multipartdef<span class="token punctuation">.</span><span class="token function">getFileSizeThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    wrapper<span class="token punctuation">.</span><span class="token function">setMultipartConfigElement</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MultipartConfigElement</span><span class="token punctuation">(</span>                            multipartdef<span class="token punctuation">.</span><span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getAsyncSupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">setAsyncSupported</span><span class="token punctuation">(</span>                        servlet<span class="token punctuation">.</span><span class="token function">getAsyncSupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">booleanValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            context<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>这段代码清楚的描述了如何将 Servlet 包装成 Context 容器中的 StandardWrapper，这里有个疑问，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象。这里 StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。</p><p>除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。</p><h2 id="创建-Servlet-实例"><a href="#创建-Servlet-实例" class="headerlink" title="创建 Servlet 实例"></a>创建 Servlet 实例</h2><p>前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。</p><h3 id="创建-Servlet-对象"><a href="#创建-Servlet-对象" class="headerlink" title="创建 Servlet 对象"></a>创建 Servlet 对象</h3><p>如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。</p><p>创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。</p><p>创建 Servlet 对象的相关类结构图如下：</p><h5 id="图-3-创建-Servlet-对象的相关类结构"><a href="#图-3-创建-Servlet-对象的相关类结构" class="headerlink" title="图 3. 创建 Servlet 对象的相关类结构"></a>图 3. 创建 Servlet 对象的相关类结构</h5><p><img src="https://img.iamghf.top/blog/20200421151712.png" alt="图 3. 创建 Servlet 对象的相关类结构"></p><h3 id="初始化-Servlet"><a href="#初始化-Servlet" class="headerlink" title="初始化 Servlet"></a>初始化 Servlet</h3><p>初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。</p><p>如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。</p><p>这样 Servlet 对象就初始化完成了，事实上 Servlet 从被 web.xml 中解析到完成初始化，这个过程非常复杂，中间有很多过程，包括各种容器状态的转化引起的监听事件的触发、各种访问权限的控制和一些不可预料的错误发生的判断行为等等。我们这里只抓了一些关键环节进行阐述，试图让大家有个总体脉络。</p><p>下面是这个过程的一个完整的时序图，其中也省略了一些细节。</p><h5 id="图-4-初始化-Servlet-的时序图（查看大图）"><a href="#图-4-初始化-Servlet-的时序图（查看大图）" class="headerlink" title="图 4. 初始化 Servlet 的时序图（查看大图）"></a>图 4. 初始化 Servlet 的时序图（<a href="https://img.iamghf.top/blog/20200421151808.png" target="_blank" rel="noopener">查看大图</a>）</h5><p><img src="https://img.iamghf.top/blog/20200421151808.png" alt="图 4. 初始化 Servlet 的时序图"></p><h2 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h2><p>我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。</p><h5 id="图-5-Servlet-顶层类关联图"><a href="#图-5-Servlet-顶层类关联图" class="headerlink" title="图 5.Servlet 顶层类关联图"></a>图 5.Servlet 顶层类关联图</h5><p><img src="https://img.iamghf.top/blog/20200421151900.png" alt="图 5.Servlet 顶层类关联图"></p><p>从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。</p><p>ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？</p><p>下图是 ServletConfig 和 ServletContext 在 Tomcat 容器中的类关系图。</p><h5 id="图-6-ServletConfig-在容器中的类关联图"><a href="#图-6-ServletConfig-在容器中的类关联图" class="headerlink" title="图 6. ServletConfig 在容器中的类关联图"></a>图 6. ServletConfig 在容器中的类关联图</h5><p><img src="https://img.iamghf.top/blog/20200421151937.png" alt="图 6. ServletConfig 在容器中的类关联图"></p><p>上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类。所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。</p><p>同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。</p><p>通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。</p><p>Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？</p><h5 id="图-7-Request-相关类结构图"><a href="#图-7-Request-相关类结构图" class="headerlink" title="图 7.Request 相关类结构图"></a>图 7.Request 相关类结构图</h5><p><img src="https://img.iamghf.top/blog/20200421152021.png" alt="图 7.Request 相关类结构图"></p><p>上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示：</p><h5 id="图-8-Request-和-Response-的转变过程"><a href="#图-8-Request-和-Response-的转变过程" class="headerlink" title="图 8.Request 和 Response 的转变过程"></a>图 8.Request 和 Response 的转变过程</h5><p><img src="https://img.iamghf.top/blog/20200421152101.png" alt="图 8.Request 和 Response 的转变过程"></p><h2 id="Servlet-如何工作"><a href="#Servlet-如何工作" class="headerlink" title="Servlet 如何工作"></a>Servlet 如何工作</h2><p>我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。</p><p>当用户从浏览器向服务器发起一个请求，通常会包含如下信息：<a href="http://hostname" target="_blank" rel="noopener">http://hostname</a>: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？</p><p>Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。</p><h5 id="图-9-Request-的-Mapper-类关系图"><a href="#图-9-Request-的-Mapper-类关系图" class="headerlink" title="图 9.Request 的 Mapper 类关系图"></a>图 9.Request 的 Mapper 类关系图</h5><p><img src="https://img.iamghf.top/blog/20200421152145.png" alt="图 9.Request 的 Mapper 类关系图"></p><p>可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 :</p><h5 id="清单-5-MapperListener-init"><a href="#清单-5-MapperListener-init" class="headerlink" title="清单 5. MapperListener.init"></a>清单 5. MapperListener.init</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">findDefaultHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Engine engine <span class="token operator">=</span> <span class="token punctuation">(</span>Engine<span class="token punctuation">)</span> connector<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        engine<span class="token punctuation">.</span><span class="token function">addContainerListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Container<span class="token punctuation">[</span><span class="token punctuation">]</span> conHosts <span class="token operator">=</span> engine<span class="token punctuation">.</span><span class="token function">findChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Container conHost <span class="token operator">:</span> conHosts<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Host host <span class="token operator">=</span> <span class="token punctuation">(</span>Host<span class="token punctuation">)</span> conHost<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>LifecycleState<span class="token punctuation">.</span>NEW<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                host<span class="token punctuation">.</span><span class="token function">addLifecycleListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">registerHost</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。</p><h5 id="图-10-Request-在容器中的路由图"><a href="#图-10-Request-在容器中的路由图" class="headerlink" title="图 10.Request 在容器中的路由图"></a>图 10.Request 在容器中的路由图</h5><p><img src="https://img.iamghf.top/blog/20200421152255.png" alt="图 10.Request 在容器中的路由图"></p><p>上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。</p><p>接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。</p><p>Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。</p><p>当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。</p><h2 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h2><p>前面我们已经说明了 Servlet 如何被调用，我们基于 Servlet 来构建应用程序，那么我们能从 Servlet 获得哪些数据信息呢？</p><p>Servlet 能够给我们提供两部分数据，一个是在 Servlet 初始化时调用 init 方法时设置的 ServletConfig，这个类基本上含有了 Servlet 本身和 Servlet 所运行的 Servlet 容器中的基本信息。根据前面的介绍 ServletConfig 的实际对象是 StandardWrapperFacade，到底能获得哪些容器信息可以看看这类提供了哪些接口。还有一部分数据是由 ServletRequest 类提供，它的实际对象是 RequestFacade，从提供的方法中发现主要是描述这次请求的 HTTP 协议的信息。所以要掌握 Servlet 的工作方式必须要很清楚 HTTP 协议，如果你还不清楚赶紧去找一些参考资料。关于这一块还有一个让很多人迷惑的 Session 与 Cookie。</p><p>Session 与 Cookie 不管是对 Java Web 的熟练使用者还是初学者来说都是一个令人头疼的东西。Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态。它们有各自的优点也有各自的缺陷。然而具有讽刺意味的是它们优点和它们的使用场景又是矛盾的，例如使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如 Cookie 占用 200 个字节，如果一天的 PV 有几亿的时候，它要占用多少带宽。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用。</p><p>不管 Session 和 Cookie 有什么不足，我们还是要用它们。下面详细讲一下，Session 如何基于 Cookie 来工作。实际上有三种方式能可以让 Session 正常工作：</p><ol><li>基于 URL Path Parameter，默认就支持</li><li>基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的</li><li>基于 SSL，默认不支持，只有 connector.getAttribute(“SSLEnabled”) 为 TRUE 时才支持</li></ol><p>第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 SessionCookieName 重写到用户请求的 URL 参数中，它的传递格式如 /path/Servlet;name=value;name2=value2? Name3=value3，其中“Servlet；”后面的 K-V 对就是要传递的 Path Parameters，服务器会从这个 Path Parameters 中拿到用户配置的 SessionCookieName。关于这个 SessionCookieName，如果你在 web.xml 中配置 session-config 配置项的话，其 cookie-config 下的 name 属性就是这个 SessionCookieName 值，如果你没有配置 session-config 配置项，默认的 SessionCookieName 就是大家熟悉的“JSESSIONID”。接着 Request 根据这个 SessionCookieName 到 Parameters 拿到 Session ID 并设置到 request.setRequestedSessionId 中。</p><p>请注意如果客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。</p><p>如果是第三种情况的话将会根据 javax.servlet.request.ssl_session 属性值设置 Session ID。</p><p>有了 Session ID 服务器端就可以创建 HttpSession 对象了，第一次触发是通过 request. getSession() 方法，如果当前的 Session ID 还没有对应的 HttpSession 对象那么就创建一个新的，并将这个对象加到 org.apache.catalina. Manager 的 sessions 容器中保存，Manager 类将管理所有 Session 的生命周期，Session 过期将被回收，服务器关闭，Session 将被序列化到磁盘等。只要这个 HttpSession 对象存在，用户就可以根据 Session ID 来获取到这个对象，也就达到了状态的保持。</p><h5 id="图-11-Session-相关类图"><a href="#图-11-Session-相关类图" class="headerlink" title="图 11.Session 相关类图"></a>图 11.Session 相关类图</h5><p><img src="https://img.iamghf.top/blog/20200421152346.png" alt="图 11.Session 相关类图"></p><p>上从图中可以看出从 request.getSession 中获取的 HttpSession 对象实际上是 StandardSession 对象的门面对象，这与前面的 Request 和 Servlet 是一样的原理。下图是 Session 工作的时序图：</p><h5 id="图-12-Session-工作的时序图（查看大图）"><a href="#图-12-Session-工作的时序图（查看大图）" class="headerlink" title="图 12.Session 工作的时序图（查看大图）"></a>图 12.Session 工作的时序图（<a href="https://img.iamghf.top/blog/20200421152357.png" target="_blank" rel="noopener">查看大图</a>）</h5><p><img src="https://img.iamghf.top/blog/20200421152357.png" alt="图 12.Session 工作的时序图"></p><p>还有一点与 Session 关联的 Cookie 与其它 Cookie 没有什么不同，这个配置的配置可以通过 web.xml 中的 session-config 配置项来指定。</p><h2 id="Servlet-中的-Listener"><a href="#Servlet-中的-Listener" class="headerlink" title="Servlet 中的 Listener"></a>Servlet 中的 Listener</h2><p>整个 Tomcat 服务器中 Listener 使用的非常广泛，它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。如下图所示：</p><h5 id="图-13-Servlet-中的-Listener"><a href="#图-13-Servlet-中的-Listener" class="headerlink" title="图 13.Servlet 中的 Listener"></a>图 13.Servlet 中的 Listener</h5><p><img src="https://img.iamghf.top/blog/20200421152411.png" alt="图 13.Servlet 中的 Listener"></p><p>它们基本上涵盖了整个 Servlet 生命周期中，你感兴趣的每种事件。这些 Listener 的实现类可以配置在 web.xml 中的 <listener> 标签中。当然也可以在应用程序中动态添加 Listener，需要注意的是 ServletContextListener 在容器启动之后就不能再添加新的，因为它所监听的事件已经不会再出现。掌握这些 Listener 的使用，能够让我们的程序设计的更加灵活。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文涉及到内容有点多，要把每个细节都说清楚，似乎不可能，本文试着从 Servlet 容器的启动到 Servlet 的初始化，以及 Servlet 的体系结构等这些环节中找出一些重点来讲述，目的是能读者有一个总体的完整的结构图，同时也详细分析了其中的一些难点问题，希望对大家有所帮助。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启用https</title>
      <link href="/qi-yong-https.html"/>
      <url>/qi-yong-https.html</url>
      
        <content type="html"><![CDATA[<p>基于 acme.sh从Let’s Encrypt生成免费的泛域名证书</p><h2 id="安装acme-sh"><a href="#安装acme-sh" class="headerlink" title="安装acme.sh"></a>安装acme.sh</h2><pre class=" language-shell"><code class="language-shell"># 安装依赖环境 yum -y install curl cron socat# 下载并安装acme.sh curl  https://get.acme.sh | shsource ~/.bashrc</code></pre><h2 id="申请域名解析服务商API-token-，完成DNS验证"><a href="#申请域名解析服务商API-token-，完成DNS验证" class="headerlink" title="申请域名解析服务商API token ，完成DNS验证"></a>申请域名解析服务商API token ，完成DNS验证</h2><p>DNS验证的意义在于证明域名的所有人是你，而不是别人。acme.sh不是随随便便就就能操作当前域名的DNS解析记录的，必须通过当前域名的<strong>域名注册服务商</strong>授权才可以。这就需要用到了<code>API token</code></p><ul><li><table><thead><tr><th align="left">服务商名称</th><th align="left">服务商简称</th><th align="left">所需API参数</th><th align="left">获取API参数地址</th></tr></thead><tbody><tr><td align="left">cloudxns</td><td align="left">cx</td><td align="left">export CX_Key=”123456” export CX_Secret=”abcdef”</td><td align="left"><a href="https://www.cloudxns.net/AccountManage/apimanage.html" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">dnspod (cn大陆版)</td><td align="left">dp</td><td align="left">export DP_Id=”123456” export DP_Key=”abcdef”</td><td align="left"><a href="https://www.dnspod.cn/console/user/security" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left"><a href="https://www.vpser.net/go/aliyun" target="_blank" rel="noopener">aliyun</a></td><td align="left">ali</td><td align="left">export Ali_Key=”123456” export Ali_Secret=”abcdef”</td><td align="left"><a href="https://ak-console.aliyun.com/#/accesskey" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">cloudflare</td><td align="left">cf</td><td align="left">export CF_Key=”123456” export CF_Email=”<a href="mailto:abc@example.com">abc@example.com</a>“</td><td align="left"><a href="https://dash.cloudflare.com/profile/api-tokens" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left"><a href="https://www.vpser.net/go/linode" target="_blank" rel="noopener">linode</a></td><td align="left">linode</td><td align="left">export LINODE_API_KEY=”123456”</td><td align="left"><a href="https://manager.linode.com/profile/api" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">he</td><td align="left">he</td><td align="left">export HE_Username=”username” export HE_Password=”password”</td><td align="left"><a href="https://dns.he.net/" target="_blank" rel="noopener">he</a>的用户名密码</td></tr><tr><td align="left"><a href="https://www.vpser.net/go/digitalocean" target="_blank" rel="noopener">digitalocean</a></td><td align="left">dgon</td><td align="left">export DO_API_KEY=”123456”</td><td align="left"><a href="https://cloud.digitalocean.com/settings/applications" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left"><a href="https://www.vpser.net/go/namesilo" target="_blank" rel="noopener">namesilo</a></td><td align="left">namesilo</td><td align="left">export Namesilo_Key=”123456”</td><td align="left"><a href="https://www.namesilo.com/account_api.php" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">aws</td><td align="left">aws</td><td align="left">export AWS_ACCESS_KEY_ID=123456 export AWS_SECRET_ACCESS_KEY=abcdef</td><td align="left"><a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left"><a href="https://www.vpser.net/go/name" target="_blank" rel="noopener">namecom</a></td><td align="left">namecom</td><td align="left">export Namecom_Username=”username” export Namecom_Token=”123456”</td><td align="left"><a href="https://www.name.com/reseller/apply" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">freedns</td><td align="left">freedns</td><td align="left">export FREEDNS_User=”username” export FREEDNS_Password=”password”</td><td align="left"><a href="https://freedns.afraid.org/" target="_blank" rel="noopener">freedns</a>的用户名密码</td></tr><tr><td align="left">godaddy</td><td align="left">gd</td><td align="left">export GD_Key=”123456” export GD_Secret=”abcdef”</td><td align="left"><a href="https://developer.godaddy.com/keys/" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">yandex</td><td align="left">yandex</td><td align="left">export PDD_Token=”abcdef”</td><td align="left"><a href="https://tech.yandex.com/domain/doc/concepts/access-docpage/" target="_blank" rel="noopener">点击访问</a></td></tr></tbody></table></li></ul><p>我使用的是阿里云，对应的命令为：</p><pre class=" language-shell"><code class="language-shell">export Ali_Key="xxxxxx"export Ali_Secret="xxxxxxxxxxxxxxxxxxxxxxxxxx"</code></pre><h2 id="生成泛域名证书"><a href="#生成泛域名证书" class="headerlink" title="生成泛域名证书"></a>生成泛域名证书</h2><p>多域名，可以使用 -d 参数添加</p><p><code>--keylength ec-256</code> 是签发 ECC 类型的证书，它的安全性更高，删除则使用默认的 RSA 证书</p><pre class=" language-shell"><code class="language-shell">acme.sh --issue --dns dns_ali -d iamghf.top  --keylength ec-256 --standalone</code></pre><h2 id="复制证书"><a href="#复制证书" class="headerlink" title="复制证书"></a>复制证书</h2><p>证书已经签发了，不过默认是保存在 <code>~/.acme.sh/</code> 里</p><pre class=" language-shell"><code class="language-shell">acme.sh --ecc --installcert -d iamghf.top         --key-file /etc/nginx/cert/iamghf.top.key         --fullchain-file /etc/nginx/cert/iamghf.top.cer         --reloadcmd "/usr/sbin/nginx -s reload"</code></pre><p>指定域名，指定证书保存目录，我这里设置在 <code>/etc/nginx/cert/</code>，指定 Nginx 重载命令，如果签发的不是 ECC 证书，把 <code>--ecc</code> 参数去掉</p><p>这样使用 acme.sh 就完成了证书的签发，如果证书快要过期了，脚本会自动更新证书</p><p>脚本自动更新，可以使用以下命令</p><pre class=" language-shell"><code class="language-shell">acme.sh --upgrade --auto-upgrade</code></pre><h2 id="未解决的问题"><a href="#未解决的问题" class="headerlink" title="未解决的问题"></a>未解决的问题</h2><p>启用https后 发现chrome浏览网站时并不是全绿</p><p><img src="https://img.iamghf.top/blog/20200414152144.png" alt=""></p><p>查了下是因为页面还有其他 http 资源，也就是所谓的 <strong>Mixed Content</strong>，开启调试模式看了下是用的图床没启用https，懒得折腾了有空再修复吧。</p><p><img src="https://img.iamghf.top/blog/20200414152649.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acme.sh </tag>
            
            <tag> ssl </tag>
            
            <tag> Let’s Encrypt </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫威宇宙其实也就讲了一件事</title>
      <link href="/man-wei-yu-zhou-qi-shi-ye-jiu-jiang-liao-yi-jian-shi.html"/>
      <url>/man-wei-yu-zhou-qi-shi-ye-jiu-jiang-liao-yi-jian-shi.html</url>
      
        <content type="html"><![CDATA[<p>整个宇宙就好比一个git项目，其中有一群叫做美国队长，钢铁侠，惊奇队长，浩克，索尔等人在维护这个项目，兢兢业业的修理bug。</p><p>某一天出现了一个天才程序员，叫灭霸，也在这个项目中开发，他意识到，这个项目已经很庞大了，光是编译都要几个小时，运行起来负重累累，而服务器资源就这么有限，老板又不给买机器，如果一直继续这么开发下去，这个项目迟早要出现网P0事故的，于是下定决定要把这个项目用面向对象，提取重复代码，业务拆分，算法优化等手段，彻底优化，目标是代码量减少50%。</p><p>美国队长的项目组叫复仇者联盟，发现了灭霸程序员的想法后，阻止并警告灭霸说，：不要轻易去改老代码！！，很容易出bug的，代码能跑就行！！！</p><p>然而，这名叫灭霸的程序员兢兢业业，取得了公司6位大股东（对应6颗宝石）的支持，带领团队996加班1个月，实现代码量减少50%，项目运行起来身轻如燕。</p><p>因为代码量减少了很多，万恶的资本主义也开始了大裁员，星爵项目组，蜘蛛侠，猩红女巫，就连拥有博士学位的奇异博士也被裁员了。</p><p>大裁员之后，美国队长为首的项目组，强忍悲伤，面对生活，继续开发修理bug，但是像雷神索尔，因为不满意公司的做法，开始磨洋工，上班就打游戏喝饮料，等着被公司裁拿补偿金。</p><p>有一天一个叫蚁人的码农，找到了美国队长说，回退是不可能回退的了，但是我们可以把以前的老代码重新merge到master上来呀。</p><p>美国队长作为项目组的组长，想到以前的同事失业，内心很愧疚，于是偷偷摸摸兵分五路请6位大股东喝酒吃饭，威逼利诱，拿到了现网服务器账号！</p><p>代码成功回退，很多之前失业的员工被返聘，像童工蜘蛛侠，外包团队瓦坎达等。</p><p>灭霸发现之后，大怒道，你们这群沉迷老技术的稳定派，我要把整个项目用scala重构，让你们这群渣渣程序员都失业！</p><p>最后，灭霸由于太过激进，在项目中屡次采用新技术，现网屡出事故，项目灭霸的重构项目组被董事会辞退。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漫威 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网线单线复用</title>
      <link href="/wang-xian-dan-xian-fu-yong.html"/>
      <url>/wang-xian-dan-xian-fu-yong.html</url>
      
        <content type="html"><![CDATA[<h1 id="网线单线复用"><a href="#网线单线复用" class="headerlink" title="网线单线复用"></a>网线单线复用</h1><p>家里装修时从弱电箱到客厅只埋了一根网线，家里宽带只有100M的带宽，采取的是将网线一分为二的廉价方式来满足同时使用宽带和IPTV服务。最近电信推出了宽带免费提速的政策，可以提速至200M。本着物尽其用的原则，将家里的线路进行升级改造，实现千兆局域网。</p><p>网络拓扑图如下：</p><p><img src="https://img.iamghf.top/blog/20200325144858.png" alt=""></p><p>vlan交换机设置：</p><p>vlan交换机我用的是网件的GS105E</p><table><thead><tr><th>vlan</th><th>端口1</th><th>端口2</th><th>端口3</th><th>端口4</th><th>端口5</th></tr></thead><tbody><tr><td>1</td><td>U</td><td>U</td><td>U</td><td>U</td><td>U</td></tr><tr><td>45</td><td>T</td><td>U</td><td></td><td></td><td></td></tr><tr><td>12</td><td>T</td><td></td><td>U</td><td>U</td><td>U</td></tr></tbody></table><p>PVID</p><table><thead><tr><th>端口</th><th>PVID值</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>45</td></tr><tr><td>3</td><td>12</td></tr><tr><td>4</td><td>12</td></tr><tr><td>5</td><td>12</td></tr></tbody></table><p>升级后效果：</p><p><img src="https://img.iamghf.top/blog/20200325150715.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VLAN </tag>
            
            <tag> 交换机 </tag>
            
            <tag> 宽带 </tag>
            
            <tag> 电信 </tag>
            
            <tag> 单线复用 </tag>
            
            <tag> 满速带宽 </tag>
            
            <tag> 千兆 </tag>
            
            <tag> 提速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派开箱</title>
      <link href="/shu-mei-pai-kai-xiang.html"/>
      <url>/shu-mei-pai-kai-xiang.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派开箱"><a href="#树莓派开箱" class="headerlink" title="树莓派开箱"></a>树莓派开箱</h1><p>默认密码： pi/raspberry</p><p>sudo apt-get update — 更新软件源</p><p>sudo apt-get upgrade — 根据新的软件源来自动更新本地的包</p><p>sudo reboot</p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>sudo passwd pi</p><h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><p>树莓派自带的vi编辑器用不习惯，so</p><p>sudo apt-get install vim</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>官方一键安装脚本</p><pre class=" language-shell"><code class="language-shell">sudo` `curl -sSL https://get.docker.com | sh</code></pre><p><img src="https://img.iamghf.top/blog/20200318133751.png" alt=""></p><h3 id="无需sudo执行docker"><a href="#无需sudo执行docker" class="headerlink" title="无需sudo执行docker"></a>无需sudo执行docker</h3><pre class=" language-shell"><code class="language-shell"># 创建docker用户组sudo groupadd docker# 把当前用户加入到docker用户组sudo gpasswd -a $USER docker# 更新当前用户组变动（就不用退出并重新登录了）newgrp docker</code></pre><h3 id="安装可视工具portainer"><a href="#安装可视工具portainer" class="headerlink" title="安装可视工具portainer"></a>安装可视工具portainer</h3><pre class=" language-shell"><code class="language-shell">#下载镜像docker pull portainer/portainer</code></pre><pre class=" language-shell"><code class="language-shell">#运行docker run -d -p 9000:9000     --restart=always     -v /var/run/docker.sock:/var/run/docker.sock     -v /data/portainer:/data    --name prtainer    portainer/portainer</code></pre><p>访问页面 <a href="http://ip:9000" target="_blank" rel="noopener">http://ip:9000</a> 设置用户名和密码  选择local模式</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>安装frp</p><p>已有公网服务器 配置如下：</p><p><img src="https://img.iamghf.top/blog/20200324105756.png" alt=""></p><p>下载frp  <a href="https://github.com/fatedier/frp/releases/" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases/</a></p><p>树莓派为arm64版本</p><p>sudo wget frp地址</p><p>解压</p><p>sudo tar xzvf frp_0.16.1_linux_arm.tar.gz</p><p>编辑frpc.ini</p><pre><code>[common]server_addr = 公网frps地址server_port = 7000auth_token = frps设置的token[docker]type = httplocal_port = 9000subdomain = docker</code></pre><p>运行 </p><p>sudo ./frpc -c ./frpc.ini</p><h3 id="配置systemctl来控制frpc"><a href="#配置systemctl来控制frpc" class="headerlink" title="配置systemctl来控制frpc"></a>配置systemctl来控制frpc</h3><p>创建frpc服务</p><p>sudo nano /lib/systemd/system/frpc.service</p><p>往frpc.service里添加以下内容</p><pre><code>[Unit]Description=frpc serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleRestart=on-failureRestartSec=5sExecStart=/etc/frp/frpc -c /etc/frp/frpc.ini[Install]WantedBy=multi-user.target</code></pre><pre class=" language-shell"><code class="language-shell">#启动frpcsudo systemctl start frpc#服务器开机自动启动frpcsudo systemctl enable frpc#查看状态sudo systemctl status frpc#重启frpcsudo systemctl restart frpc#停止frpcsudo systemctl stop frpc</code></pre><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>sudo apt-get install nginx</p><p>sudo /etc/init.d/nginx start</p><p>nginx -v </p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> frp </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> portainer </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装OpenWrt</title>
      <link href="/shu-mei-pai-an-zhuang-openwrt.html"/>
      <url>/shu-mei-pai-an-zhuang-openwrt.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派安装OpenWrt"><a href="#树莓派安装OpenWrt" class="headerlink" title="树莓派安装OpenWrt"></a>树莓派安装OpenWrt</h1><p>开启网卡混杂模式</p><pre class=" language-shell"><code class="language-shell">sudo ip link set eth0 promisc on</code></pre><h2 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h2><pre class=" language-shell"><code class="language-shell">docker network create -d macvlan --subnet=192.168.198.0/24 --gateway=192.168.198.1 -o parent=eth0 macnet</code></pre><p>macvlan 是一种虚拟网卡的解决方案：</p><ul><li><p>macvlan并不创建网络，只创建虚拟网卡。</p></li><li><p>macvlan会<code>共享物理网卡</code>所链接的<code>外部网络</code>，实现的效果跟桥接模式是一样的。</p></li></ul><p>使用 <code>docker network ls</code>命令可以看到网络<code>macnet</code>已建立成功</p><p><img src="https://img.iamghf.top/blog/2020-03-19-031440.jpg" alt=""></p><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>docker pull sulinggg/openwrt:latest</p><h2 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h2><pre class=" language-shell"><code class="language-shell">docker run --restart always --name openwrt -d --network macnet --privileged sulinggg/openwrt:latest /sbin/init</code></pre><p>其中：</p><p><code>--restart always</code>参数表示容器退出时始终重启，使服务尽量保持始终可用；</p><p><code>--name openwrt</code>参数定义了容器的名称；</p><p><code>-d</code>参数定义使容器运行在 Daemon 模式；</p><p><code>--network macnet</code>参数定义将容器加入 <code>maxnet</code>网络；</p><p><code>--privileged</code>参数定义容器运行在特权模式下；</p><p><code>/sbin/init</code>定义容器启动后执行的命令。</p><h2 id="进入容器修改参数"><a href="#进入容器修改参数" class="headerlink" title="进入容器修改参数"></a>进入容器修改参数</h2><p>docker exec -it openwrt bash</p><pre class=" language-shell"><code class="language-shell">vim /etc/config/network</code></pre><pre><code>config interface &#39;loopback&#39;        option ifname &#39;lo&#39;        option proto &#39;static&#39;        option ipaddr &#39;127.0.0.1&#39;        option netmask &#39;255.0.0.0&#39;config interface &#39;lan&#39;        option type &#39;bridge&#39;        option ifname &#39;eth0&#39;        option proto &#39;static&#39;        option ipaddr &#39;192.168.123.100&#39;        option netmask &#39;255.255.255.0&#39;        option ip6assign &#39;60&#39;        option gateway &#39;192.168.123.1&#39;        option broadcast &#39;192.168.123.255&#39;        option dns &#39;192.168.123.1&#39;config interface &#39;vpn0&#39;        option ifname &#39;tun0&#39;        option proto &#39;none&#39;</code></pre><p>所有的 <code>192.168.123.x</code> 需要根据树莓派所处网段修改，<code>option gateway</code>和<code>option dns</code>填写路由器的 IP，若树莓派获得的 IP 为 <code>192.168.2.154</code>，路由器 IP 为<code>192.168.2.1</code>，则需要这样</p><pre><code>config interface &#39;lan&#39;        option type &#39;bridge&#39;        option ifname &#39;eth0&#39;        option proto &#39;static&#39;        option ipaddr &#39;192.168.2.100&#39;        option netmask &#39;255.255.255.0&#39;        option ip6assign &#39;60&#39;        option gateway &#39;192.168.2.1&#39;        option broadcast &#39;192.168.2.255&#39;        option dns &#39;192.168.2.1&#39;</code></pre><p><code>option ipaddr</code>项目定义了 OpenWrt 的 IP 地址，在完成网段设置后，IP最后一段可根据自己的爱好修改（前提是符合规则且不和现有已分配 IP 冲突）。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> raspberry </tag>
            
            <tag> 软路由 </tag>
            
            <tag> openwrt </tag>
            
            <tag> lede </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐私泄露下的数据暗网：大数据广告精准推送原理</title>
      <link href="/da-shu-ju-guang-gao-jing-zhun-tui-song-yuan-li.html"/>
      <url>/da-shu-ju-guang-gao-jing-zhun-tui-song-yuan-li.html</url>
      
        <content type="html"><![CDATA[<p>自打人类进化中出现了商业的那一刻起，营销，就成为了人类钻研的核心。交易的本质是价值交换，但世界上不存在永远对等的价值，所以交换中存在套利空间，这些套利空间，成就了商业的价值。逐利是人的本性，这是刻在基因里的。</p><p>如何把一件产品附加上额外的价值，卖给自己的同类，换回更多的金钱，成了最打动人心的事情，比世界和平还要打动人。毕竟和平是所有人的，而金钱是少数人的。越少越珍贵。纵观人类历史的每一个时代，最先进的技术往往都是最先应用于军事和贸易，而军事，很多时候也都是为贸易所服务的。从古至今皆是如此，大数据年代也不例外。</p><p>在这个人人标签化的数字年代，广告业前所未有的深入到了我们生活的方方面面，影响了我们的各种决策。你以为你做出的购买决策是基于自身的意愿，但现实并不一定如此。作为一个整日与数据标签打交道的风控，反商业作弊也是我的日常工作，如果不懂商业广告的底层逻辑，那么是做不好风控的。</p><p>这篇文章将给大家科普大数据广告的精准推送原理，我想为大家展示一下数据在合理的策略里可以完成多么恐怖的事情，这是真正的改变世界，或者说是掌控世界。这里面有谣言，也有真相，更多的是真相与谣言参半。甚至有时候真相比谣言更加魔幻。</p><p><img src="https://img.iamghf.top/blog/20200320144054.png" alt=""></p><p>让人掏钱，不是一件简单的事情，哪怕是有技术的支持。数据广告推送，本身是一个极为复杂的工程，这里面涉及数据采集，数据清洗，口径对齐，数据关联，模型训练，策略迭代，场景验证，流量分配，成本控制，渠道管理等一系列工作。</p><p>每家合格的数据驱动的营销公司，都会有一只数百到上千人的团队专门做相关的工作，数百个聪明的脑袋996只为做一件事。让你在不知不觉中心甘情愿的掏钱。</p><p>靠一篇文章写全这些，既不太现实，也没必要，所以我决定围绕一个关于大数据广告非常经典的谣言，从辟谣开始，来一步步拆解数据广告推送的基础知识以及对我们生活的影响。</p><p>很多人在网上说自己的的手机被人监听了，原因是自己刚和别人讨论了某个话题，没过多久，手机上就出现了类似信息的广告。例如自己口述了想喝奶茶，打开外卖软件就出现了奶茶推送。自己说想去欧洲旅游，打开网页就出现了旅游广告。自己谈到了某种商品，打开购物APP就出现了类似商品的推送。</p><p>所以很多人觉得自己在被自己手上的APP所监听，然后这些监听依据相关的关键词拆解讲话的意思，然后就推送给自己各种各样的广告，精准不精准不说，着实是吓人一跳。有段时间，整个互联网都在盛传某某APP拿录音权限就是为了实时监控用户，甚至某些APP还在偷偷录像用户云云。</p><p>我得承认大家的想象力是很丰富的，在不懂网络广告推送机制的前提下，提出这些猜想某种程度上也是合理的，但这都是谣言。互联网公司不会用这种方式来做所谓的精准推送。不是他们良心发现，而是这么做没有性价比。商人逐利。</p><p>为什么不用录音做推送？从用户角度思考方案，可能只考虑这件事是否能实现，监听录音从技术上可以实现；但是作为商业公司评估方案，除了需要考虑能不能实现这一点之外，还要综合考虑成本，效率以及风险，马虎不得。商场如战场。</p><p>利用录音做信息收集，然后做广告推送，在当下，是一件成本极高，效率极低，风险极高的事情。不仅要投入大量成本，连毛都赚不回来，还要面临侵犯用户隐私的指控，脑子没冒烟的公司都不会做这件事，即使是冒烟的公司，做到一半就会发现划不来，然后不做了。</p><p>录音牵涉的主要问题如下：</p><ol><li>录音功能会让APP消耗海量手机资源。</li></ol><p>当一个APP在后台持续录音的时候，不仅是APP本身运转会变得迟缓，更多的是会造成手机本身的耗电量和发热大幅增加，一来二去，用户直接就不使用了，因为一用你的APP手机就不好，市场上可选择替代品又太多。</p><p>当年滴滴和快的大战的时候，滴滴在关键时刻胜出靠的就是腾讯支持的1000台服务器以及数百名顶尖工程师，比快的早半个月实现了用户体验的质的飞跃，后面的故事大家都知道了。</p><ol start="2"><li>录音文件本身是占用手机存储空间的，并且占用极大。</li></ol><p>大家可以自己录一段30分钟的录音看看，这个音频文件会有多大，一个APP如果持续录音，在用户重度使用的情况下，可能几天就把手机彻底塞满了。这会造成非常荒谬的后果。</p><ol start="3"><li>录音录下来之后，无法及时处理这些录音数据。</li></ol><p>如果把录音处理模型放在本地APP里，那么一个是APP安装包臃肿，一个是会被竞争对手反编译，商业机密直接透明，把核心能力包在APP本地，是很愚蠢的事情，吃鸡为什么外挂屡禁不止，就是因为运算整体在本地文件，无法抵挡本地篡改，所以本地存储方案不靠谱；</p><p>如果走实时上传，那么传输过程中需要流量，这造成用户的流量损耗极为恐怖，并且很容易就被识别出来上传用户信息；这些数据属于无用数据。</p><ol start="4"><li>录音分析来的数据价值低，且不准确。</li></ol><p>如果手机APP监听录音，那么首先得保障他监听到的是你本人讲的话，因为推荐是要对你本人进行操作的，但是在现实生活中，录音没法保证只录某个人的声音，要录就是一起录音，这就导致录下来的声音也不知道是谁的。</p><p>想想看，我在你身边走过，冲着隔壁的人大喊一声“杜蕾斯”。然后你打开手机给你推荐杜蕾斯，这种沙雕推荐是不是非常魔幻？这就是无差别录音带来的问题。</p><ol start="5"><li>语义分析在目前依然面临无法解决的语言本身的问题。</li></ol><p>人类的语言是一门艺术，汉语更是高阶艺术，而机器尚未破解这一艺术。如果大家试过录音转文字，或者语音输入法，就会发现，机器没有办法完整的识别有效的语言场景。</p><p>我们来做一个语义识别题：</p><p>领导：“你这是什么意思？” 小明：“没什么意思，意思意思。” 领导：“你这就不够意思了。” 小明：“小意思，小意思。” 领导：“你这人真有意思。” 小明：“其实也没有别的意思。” 领导：“那我就不好意思了。” 小明：“是我不好意思。”</p><p>这里面的每一个意思，都是什么意思？机器根本做不到识别这些内容。甚至很多时候你只要讲方言或者讲话一快，机器就根本不知道你在说什么了。精准推送的前提是数据可靠且精准，录音绝不在这种数据中。</p><ol start="6"><li>录音带来的风险，要远远超过收益。</li></ol><p>录音这件事情，本身是非常敏感的，要是哪个APP能被明确抓出来在偷偷录音（目前所有的质疑都只是质疑，没有明确的数据和代码证据），第一个搞他们的不是网民，而是工信部。这种侵犯隐私的行为，正是抓紧去教育的好时机。</p><p>而公司只为求财，不想求进监狱里。</p><p>看到这里，我想很多人对于录音这种谣言已经足够了解了，但是还是有疑惑自己身上发生的神奇的事情，没关系，我们继续讲下去，看看真正的数据推送是怎么做的。我们如何通过巧妙的技术把我们自己困在广告里。</p><p>数据推送是如何实现的？</p><pre><code>    一套最最基础解法是，X+N=Y，这是最简单的公式。X是指的用户特征变量（用户画像），N是指变量应用（算法，策略），Y是指推送效果（用户是否购买）。所有收集来的用户数据，经过标准化ETL（数据处理），再经过特征工程，形成有效的X。有了X之后，N就是如何使用X，让最终结果更接近于Y。</code></pre><p>这里可以利用算法，也可以使用策略包，目前的主流是使用策略包，因为算法的效果随机性比较大。所谓的精准推送，本质上其实就是一个用X和N寻找接近Y的过程，所谓的训练模型，只不过是在已知X和Y的情况下，找寻可以让X更接近Y的算法，找出更好用的N。</p><p>单纯这么说比较抽象，我举一个例子大家就明白了。小A是一个18岁的美少年，曾经在淘宝上买了很多XX品牌的跑鞋，并且经常搜索大体重跑鞋。从广告推送的角度，针对美少年小A的推送会这么做。首先拆解小A身上的标签，做成X。男性，18岁，XX省人，学历XX，跑鞋，大体重，常用购物平台，手机型号，APP来源，手机入网时长，话费消费记录等等，这些标签都是X，来自于各种各样的数据源。</p><p>然后通过过去的购买记录，找到半佛曾经购买过的商品，就是各类跑鞋，做成Y。一个简单的用户画像就出来了：年轻男性，热爱跑步，胖，乐意花钱，有品牌倾向性，喜欢在淘宝购物，多数购物来自于主动搜索。</p><p>那么这时候就可以通过一定的策略，给半佛推荐大量的符合他历史购买习惯的跑鞋（从品牌到型号到价格），如果成交了，就代表算法有效，进一步强化推送；如果没有成交，就弱化部分特征，推送新一批跑鞋，只要成交，就依据成交结果修正算法。最终小A只是无聊刷淘宝，但是最终买了1000双跑鞋回家，然后又挂到了闲鱼上，创造了好几次GMV。</p><p>当然实际应用中会比这个公式要复杂很多，各种变量间的衍生变量，不同用户间的关系网络变量，同一个用户在不同场景中要匹配不同的Y，X作为Y，Y作为X，用户消费心理勾画，产品要素设计等等等等，广告推送可以说是互联网最复杂的应用，可能都没有之一。因为人的购买欲是不稳定的。</p><p>上面举的例子仅仅是复杂度为1的情况，实际在应用中，数据和公式的复杂度基本是10086起。考虑到本文是科普性质，所以我只拿最基本的东西来讲，大家了解这个数据推送的逻辑就可以了，算法本身不是重点。真正的重点在于精准数据的获取，这才是对我们生活影响最大的。数据时代的我们，一切都可以量化。</p><p>很多人所谓的自己偶尔说了什么，然后就收到了相关的广告，所以怀疑自己被录音。我理解这种想法，但我要说实现这样的效果，根本不需要录音这么麻烦，有的是更精准的方法来获取你的X。</p><ol><li>最基础的就是你的主动搜索记录。</li></ol><p>包括你在搜索引擎上的搜索，你在购物网站的搜索，你在各种APP（不一定要是购物）中的搜索，这些你主动搜索的信息，都是高权重的X。</p><p>如果是网页端的搜索，那么浏览器和搜索引擎都会留存你的cookie，即使你有定期清除浏览记录的习惯或者知道每次上完网清cookie也没用，现在云计算的发展已经可以做到实时上传，你清除也没用。</p><ol start="2"><li>除开搜索记录和购物记录外，最精准的数据之一就是你的手机App List以及注册APP列表。</li></ol><p>就是你的手机曾经安装过哪些APP，当前手机安装了什么什么APP，以及每一个APP的打开率，使用时长等等。</p><p>这个通过用户授权直接读取APP列表以及通过短信验证码反推安装注册可以实现，即使是号称IOS，也可以通过APP跳转撞库的方式来撞出至少48个APP。</p><p>每一个APP都是代表了一大串的X，毕竟每个APP都有自己的属性和目标用户，这些特征都是很显著的。你安装了拼多多，可能代表你是一个价格敏感型用户，可以给你推送便宜货；你安装了Bilibili，可能代表你是一个喜欢二次元的用户，可以给你推荐动漫周边；你每天大量时间沉迷在抖音，可能代表你是一个热衷于Kill Time的人，当然头条还会用你在抖音中的浏览记录来更精细化的推荐各种二类电商产品；</p><p>你用什么APP，某种程度上在机器眼中你就是什么人。</p><ol start="3"><li>LBS地理位置是一个非常有用，但是很多人都会忽略的内容。</li></ol><p>很多所谓的谈到奶茶后，打开外卖APP会弹出奶茶店铺广告的案例，其实都是因为使用了LBS推送。大家都知道APP会实时获取用户的地理位置，生成与之相关的X，而外卖店铺，本身也有自己的业务辐射范围。</p><p>当你走入到这个外卖店铺的辐射圈子的地理位置时，就给你推送相关的信息，让你不得不看。</p><p>某著名网红插，就经常喜欢对自己门店2公里内的外卖APP用户进行无差别推送，别管你喝不喝，来了就先看个广告吧。获取LBS的途径有很多，很多时候通过WIFI的固定连接点，也可以识别你是不是在那幢楼办公或者生活，然后围绕这一变量给你进行推送。你在哪里，你就是谁。</p><ol start="4"><li>聊天记录读取，短信读取，这种东西都太寻常了，我要说的是，输入法。</li></ol><p>只要你打字，你的输入法是知道你键入了什么内容的，这部分内容，都会被留存下来，然后作为你特征变量的一部分，这可比录音要好多了，因为百分百是你本人打的字，而且文字表达的含义也更加清晰。</p><p>某些输入法，就在做着这样的事情。输入法既然可以监控你的录入，当然也可以直接读取你的剪贴板，看到你曾经读取过什么。甚至技术厉害一点的，可以直接监控你的键盘轨迹，连你曾经打出来但是又删除掉的内容都拿到。</p><p>哦对了，关于录音，有一点是真的，就是当你用输入法的语音录入功能的时候，他们确实是知道你的录音的，只不过不是读声音，而是通过录音转录文字后的关键词，是读文字。输入法对于用户隐私的监控与泄露，是非常严重的，而且大多数人都无从感知。你忘记的，输入法都记得呢。</p><ol start="5"><li>当然，手机本身，就是一个最大的隐私收集器，在系统厂商和硬件厂商眼中，大家其实都是裸奔的。</li></ol><p>再讲一个恐怖故事，这些从各种APP，各类输入法，各种手机中收集来的用户数据，都是可以交易的，各家公司都在利用这些数据。</p><p>随便举一个例子。用户在今日头条APP中用百度输入法输入【尿不湿】，百度和今日头条都知道用户在今日头条输入了这个【尿不湿】，他们有了这个数据，这个数据并且是直接关联用户手机号的，就是说，大家知道是谁，在什么时间，在哪个APP里，输入了什么。</p><p>而这条精准的用户信息，是可以卖给淘宝或者京东的，淘宝获取了这个信息后，就可以对这个手机号关联的用户去进行相关的推送。这个市场的体量和交易额远远超出所有人的想象，但是知道的人却寥寥无几。</p><p>如果要穷举各种APP各种手机收集和利用用户隐私的案例，可能讲几天几夜也讲不完。我来给大家讲一个基于数据采集的用户画像案例吧，看看我们的一生是如何被数据拆解的。下面的文字部分为正常生活描述，括号内为获取这些数据的途径。</p><p>小明，在广告公司上班（通过短信读取公积金信息，或者支付宝绑定公积金）。28岁，男性（身份证号拆解）。本科学历（学信网接口通过身份证号调用），外地人（身份证号前6位对比工作所在地）。租房（租房APP或者代缴水电费账户名字与本人不同）。贷款买了一辆小车（贷款APP数据，支付宝绑定行驶证，每月短信还款提醒）。平时的消费爱好是买书和拼多多（支付类APP付款记录），以及打手游（游戏类APP以及账号体系）。经常去XX网吧通宵（外卖收货地址，网吧管理软件用户体系）。住在XX小区（快递收货地址，手机LBS活跃圈，WIFI连接热点）。偶尔也去旅游（车票酒店购买记录，异地网红店消费记录）。甚至喜欢看点小电影（浏览器记录，购买付费记录，转发记录）。朋友很多（好友数，日常活跃好友数，通话记录与通讯录的交集），朋友们的消费水平也一般般。收入一般般（短信读取银行到账短信，手机话费余额消费账单）。有一个女朋友小红（聊天记录，通讯录，通话详单），已经同居（购买大量女性生活用品）。女朋友公司在XXX（基于小明除家里以外的收货地址，关联一些女性物品交易记录）。快要结婚了（网上搜索大量与结婚有关的信息，下载了婚礼类APP）。最近可能要当父亲了（查看婴儿用品，网上搜索很多育儿经）。最近手头有点紧（下载了很多借款APP，读取短信可以知道有些下款了，外部可以采购到他的多头负债情况）。等等等等等等等（10086个等等）。</p><p>如果你是广告商，你拿到了这些数据，你可以非常精准的在小明人生的每一个阶段，都恰恰好推送一些恰恰好的广告，很多人可能光看描述就已经在构思营销方案了。</p><p>而且，这还只是小明一个人的数据，如果再加上小红的数据，小明朋友的数据，小明父母的数据，最终就会成为一张关系网。例如当小红在搜索孕妇装的时候，其实就可以给小明推荐奶粉和婴幼儿保险了。例如小明在搜索各种片子的时候，其实就可以给小红推荐一些情趣用品了。</p><p>这种关联多如漫天繁星。星空下是我们平凡的人生。如戏一般的人生，剧本不在我们手中。我们只是一颗棋子。</p><p>斯诺登的棱镜事件大家都还记得吧，美国政府在全世界范围搞监听。但要我说，棱镜那个东西，在大数据多维交叉验证面前，只是上个世纪的玩具。通过数据挖掘和收集，我知道你的爱好，知道你的活动范围，知道你的详细信息，知道你的社交圈，知道你可能要做的事情，知道你的一切。我比你还要懂你。</p><p>为什么我国政府近几年特别重视个人隐私，对于各种滥用隐私行为都是严厉的打击，每年都有大量数据从业者被送进去？因为当企业知道用户的一切的时候，某种程度上，就可以通过推送，来影响用户的一切。</p><p>这个影响可以是精准推送赚钱，也可以是做的更多。</p><p>还记得美国大选的时候，FaceBook直接倒卖用户数据来监控舆情，甚至通过精准推送来影响大选的结果？这是一种超越国界的能力。不仅仅是改变世界，甚至是掌控世界。</p><p>而回到我们自己。我们的一切，在公司眼中，只是一个个数据标签，是达到他们目的的必要生产资料而已。他们做的就是把我们做成数据，然后向我们灌输数据，从我们身上得到他们想要的东西。</p><p>我们一生的欢笑与泪水，开心与难过，认真的思考，谨慎的决策，最终都不过是一组数据，都是可以被拿来利用的。他们甚至都不屑于支配我们，你会去冲着一堆数据使劲儿吗？他们只需要调整参数就可以达到目的。</p><p>现在巨头们已经完成了数据的合围，然后通过交易来垄断这些数据。我们的一切都透明了，再技术飞速进步的年代，钱和权力都无法阻止这一切发生，除了死亡外，人类在大数据面前也是平等的。</p><p>这一切都不是秘密，完全是公开的事情，甚至那些卖数据的公司都恨不得自己去打广告找到更多的买家来买，因为卖的人太多了，市场竞争过于激烈，数据量过于饱和。这魔幻又现实。</p><p>我们的一生的故事都在里面，爱也在，恨也在。</p><p>大数据的发展确实给生活增加了便利，这无可否认。但如何掌握数据采集和数据应用的度？这是一个很大的问题。更大的问题在于，这种被设计好的生活，真的是我们想要的吗？我还没有答案，你呢？</p><p>【<a href="https://www.you85.com/thread-1000049-1-1.html" target="_blank" rel="noopener">原文地址</a>】</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 隐私泄露 </tag>
            
            <tag> 精准推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有哪些大家不说，但需要知道的社会规则？</title>
      <link href="/she-hui-gui-ze.html"/>
      <url>/she-hui-gui-ze.html</url>
      
        <content type="html"><![CDATA[<h1 id="有哪些大家不说，但需要知道的社会规则？"><a href="#有哪些大家不说，但需要知道的社会规则？" class="headerlink" title="有哪些大家不说，但需要知道的社会规则？"></a>有哪些大家不说，但需要知道的社会规则？</h1><p><img src="https://img.iamghf.top/blog/20200410140845.png" alt="img"></p><p>1、女人都以为男人说的“我养你”，是可以让她在家看看书、练练瑜伽、养养花、遛遛狗，下午再出去和姐妹逛逛街、喝个下午茶、做个美甲、敷个脸的那种“我养你”；</p><p>而男人所理解的“我养你”，是让你在家洗衣、做饭、带孩子、孝敬父母。</p><p><strong>2、没有详细询问你的需求，就拒绝你请求的人，其实是一开始就预设了立场，压根就不想帮你。</strong></p><p>比如你想问他借钱，他还没问你具体要借多少，就说自己最近手头紧；比如你想请他帮你写个材料，他还没问什么材料多少字，就说现在这两天很忙。</p><p>3、和别人聊天的时候，不要一直说那些只有你自己感兴趣的事情，对方可能既不关心也不了解。</p><p>比如你对着一个女生大谈意大利足球的悲情印记，你滔滔不绝的说了半天，自己痛快的很，可是对方就会很尴尬，因为人家可能连一支足球队几个人都不知道。</p><p><strong>4、借别人的钱，要告诉对方什么时候能把钱还人家，最好是一个明确的时间节点。</strong></p><p>如果你自己都不知道什么时候能攒够这些钱，那你还是不要借别人的钱了。</p><p>5、不要不打招呼的站到别人身后，还偷着看别人的电脑屏幕和手机屏幕！</p><p>大家都有隐私好么！</p><p>另外，别人给你看手机里某张照片的时候，不代表你可以左滑右滑。</p><p>6、微信和邮件都没有消息已读的提示，所以对方给你发消息以后，尽量回复一下。</p><p>哪怕不知道应该回复什么，也回一个“OK”、“收到”、“好的”。</p><p>至少可以让对方知道你看到了。</p><p>7、单身的时候，你可以和异性好朋友保持任何关系，暧昧不暧昧的都无所谓，但是对方谈恋爱以后，请你自觉与ta保持距离。</p><p>你可以做到问心无愧，但是对方的那个ta做不到不在意。</p><p>8、别人帮了你一个忙，只要对方付出了劳动，就不要只是在嘴上说谢谢，能表示的要表示。</p><p><strong>不是因为对方图你那点东西，是大家都愿意帮那些懂得感激的人。</strong></p><p>9、如果不打算与人分享，就不要主动向别人炫耀你的好东西。</p><p>10、不太交底的朋友请你吃饭，让你挑地方的时候，要慎重选择，尤其不要选贵的地方，可能超出了对方的预算。</p><p>最好的方法是让对方选地方。</p><p>11、如果小便池还有空着的，就不要去紧挨着一个人小便，<strong>图个啥？比大小？</strong></p><p>12、想让大家都喜欢你，你可以靠自己的能力给大家提供很多帮助。</p><p>但是最好的方式还是你可以为他们提供一些资源或者赚钱的机会。</p><p>最省事儿的方式，是你颜值抗打，别人看了自然会心情舒畅。</p><p>当然，实在不行的话就做个逗比，也算给大家带来快乐了。</p><p><strong>什么都提供不了，还想让别人都喜欢你，有点难。</strong></p><p>13、对方向你哭诉的时候，并不是想通过<strong>你指出他的错误</strong>来解决问题，大多只是需要你的认同。</p><p>14、见利忘义自古以来为人所不耻，但现实是钱的的确确可以解决大多数问题，剩下的那些问题，也可以通过钱来间接解决。</p><p>可能有人告诉你钱很重要，但是你总会慢慢发现，你好像还是低估了钱的重要性。</p><p>15、善良，其实是一种个人选择。</p><p>这种选择并不一定会让你赚到多大便宜，但是会让人的生活充满阳光，积极向上，有幸福感和获得感。</p><p>就比如这个回答，有的人看完觉得对自己有帮助，就点了个赞。从纯功利的角度来说，这个赞并不会给他本人带来什么好处，但是这种善良的行为做多了，你就会慢慢发现，自己越来越幸福了。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些改写历史的古代饭局</title>
      <link href="/na-xie-gai-xie-li-shi-de-gu-dai-fan-ju.html"/>
      <url>/na-xie-gai-xie-li-shi-de-gu-dai-fan-ju.html</url>
      
        <content type="html"><![CDATA[<h1 id="那些改写历史的古代饭局"><a href="#那些改写历史的古代饭局" class="headerlink" title="那些改写历史的古代饭局"></a>那些改写历史的古代饭局</h1><p>吃饭就是吃饭，一天吃三顿饭，目的是为了吃饱。吃饭一但成了“局”，解饿便成了次要的，里面就充满了故事性、目的性乃至阴谋性。中国历史上有许多著名的饭局，有的饭局甚至改写了历史。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093543.png" alt="image-20200111173543183"></p><p>古代宴会场景 </p><h2 id="宴会买心，得忠心"><a href="#宴会买心，得忠心" class="headerlink" title="宴会买心，得忠心"></a>宴会买心，得忠心</h2><p>俗话说酒越喝越厚，说起利用宴会收买人心的事，最著名的当属春秋时期楚庄王组织的一次宴会。 </p><p>当时楚庄王刚刚平息了一次暴乱，开庆功会。让他最宠爱的妃子给众臣敬酒，突然一阵风吹来，将灯吹灭了，一位将军喝多了酒，趁着黑暗吃楚王妃子的“豆腐”。而楚妃恼羞成怒之时，将这位“好色之徒”的帽顶之樱顺手摘了下来献给楚庄王。楚庄王得知实情之后，命令不要点灯，所有大臣都把帽子摘下来继续饮酒，并没有追查戏耍楚妃之人。这位“好色”的大将为了报楚王的宽容之恩，在后来的一次战役中奋勇当先立下大功，楚王因宽容得一誓死效忠他的猛将，此会在史上被称为绝樱会。 </p><h2 id="宴会杀人，几人亡"><a href="#宴会杀人，几人亡" class="headerlink" title="宴会杀人，几人亡"></a>宴会杀人，几人亡</h2><p>但宴会也会成为杀人的场所，人们常常将有阴谋的宴会称为鸿门宴。 </p><p>鸿门宴是历史上最著名的杀人宴会，项羽的谋士范曾想利用这次宴会杀死刘邦，让项庄舞剑。没想到项羽的叔叔项伯早已私下与刘邦结交，舞剑保护刘邦。最重要的是，耳软心活有妇人之仁的项羽并没有想杀死刘邦，所以这次宴会，刘邦逃出生天。鸿门宴有杀人的动机，但并没有完成杀人的使命。后来刘邦在战争中击败项羽，没有妇人之仁，项羽被逼自尽。  </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093347.jpg" alt="img"><br>鸿门宴 </p><p>跟鸿门宴刘邦的幸运比起来，春秋战国时期公子光请吴王僚吃饭的宴会就成了杀人的战场，吴王僚没有刘邦幸运，公子光是势在必得，一心想杀死吴王僚的。他事先请专诸在鱼肚子藏好的鱼肠剑，借上菜之机猛然从鱼肚子取出鱼藏剑，一击即中，刺杀了王僚。这就是专诸刺王僚的故事，鱼藏剑也因此成为一代名剑。专诸命丧当场，公子光成功夺取王位，就是吴王阖闾。 </p><p>齐国国相晏婴更狠，他杀人不用刀子，借宴会的两个桃子就杀了他想的人，借刀杀人的本事可谓天下无双。公孙接、田开疆、古冶子是侍卫齐景公的三个能力搏猛虎的勇士，但同时又是恃功自傲威胁国君统治的人。晏婴动了杀机，想除掉“三杰”，于是在一次宴会上，设了一个局，盘中只有两个桃子，请国君下旨谁功劳最大谁吃桃子。这“三杰”果然上了当，公孙接先吃了一个，古冶子吃了一个，田开疆无桃可吃，觉得功劳很大没桃吃当众受辱，挥剑自杀，公孙接看田开疆自杀，觉得自己功劳小而吃桃，无颜活在世上，也挥剑自杀了。古冶子看二人自杀，觉得三人结为兄弟誓同生死，二位兄弟因桃而死，自己也不能苟活，所以也自杀了。这就是二桃杀三士的故事。 </p><h2 id="宴会谋略，巧施计"><a href="#宴会谋略，巧施计" class="headerlink" title="宴会谋略，巧施计"></a>宴会谋略，巧施计</h2><p>许多宴会，其实是巧施谋略成大事的饭局。三国里面这样的宴会非常多。比如曹操设的饭局，青梅煮酒论英雄，其实是曹操怀疑刘备，考察刘备呢。而刘备在这个宴会上装傻非常成功，最后曹操点破了他，刘备还以怕雷掩饰瞒过了曹操。曹操何等的雄才大略，被刘备借兵五万去打袁术，不但跑了，还骗走了五万兵，杀了曹操一员大将。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093345.jpg" alt="img"><br>二桃杀三士 </p><p>另一场宴会是吕布设的饭局，他请刘备三兄弟与袁术的大将纪灵赴宴，为的是解除双方的刀兵相见。但纪灵并不同意与刘备和平解决争端，于是吕布说和平与战争，全靠“天意”，而这所谓的“天意”，便是他箭射一百五十步以外的方天画戟小枝，射中双方罢兵和平，射不中双方开战。吕布的谋略在于，他心中有数，天意就是人意。肯定能射中。而纪灵同意这个建议的原因是，他并不知道吕布有这么高的射技。结果吕布如期射中，辕门射戟的故事流传至今。 </p><p>最有名的谋略宴会，是三国赤壁大战前夕的“群英会”，曹操派蒋干过江说服他的老同学周瑜投降，周瑜早已看出蒋干的心思，假装喝醉，让蒋干偷走了假情报。曹操依据蒋干偷回的假情报，错杀了水军都督蔡瑁、张允。这为赤壁大战周瑜的胜利奠定了基础。 </p><h2 id="宴会夺权，一杯无"><a href="#宴会夺权，一杯无" class="headerlink" title="宴会夺权，一杯无"></a>宴会夺权，一杯无</h2><p>利用一场宴会不动一刀一枪就收回兵权，是宋朝开国皇帝赵匡胤干的最聪明睿智的事，史书命名“杯酒释兵权”。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093346.jpg" alt="img"><br>杯酒释兵权 </p><p>赵匡胤是靠陈桥兵变取得的江山，他怕其他将军也象他一样夺权，日日担忧，所以他设了一个饭局，请开国元勋们去赴宴，请他心中真实的想法说了出来。开国元勋们听到皇帝心中的想法很害怕，担心遭受杀身之祸，第二天全部请辞，主动交出了兵权。赵匡胤倒也没有为难他们，赏给他们大量的金钱，还与他们很多人结成了儿女亲家，和平解决了骄兵悍将问题。 </p><p>同赵匡胤相比，刘邦与朱元璋就没这么聪明了，这二位皇帝不得不大杀开国功臣，解除开国元勋对朝廷的威胁。尤其是朱元璋，几乎杀尽了开国功臣，到朱棣靖难之役时，建文帝无将可派，这可能也是朱元璋没想到的。传说中的“火烧庆功楼”，是与赵匡胤“杯酒释兵权”完全相反的一个酒宴，但这个事只是传说，历史中是没有的。 </p><h2 id="宴会鼓气，河山壮"><a href="#宴会鼓气，河山壮" class="headerlink" title="宴会鼓气，河山壮"></a>宴会鼓气，河山壮</h2><p>利用宴会壮行鼓气，最著名的是晋朝的“新亭会”。 </p><p>晋朝经过八王之乱，进行五胡乱华时期，北方大片国土被胡人占据，史称十六国。而大量的汉人“衣冠南渡”，在新亭会宴会上，众人纷纷哀叹世事难料，“风景不殊，举目有江河之异”，唯有名士王导挺身而出，说道“当共戮力王室，克服神州，何至作楚囚相对泣邪”。王导的话激励了众人，众人戮力同心，东晋王朝在这次宴会之后建立起来。而王导被后人称为“江左自有管夷吾”。 </p><h2 id="宴会庆功，千叟忙"><a href="#宴会庆功，千叟忙" class="headerlink" title="宴会庆功，千叟忙"></a>宴会庆功，千叟忙</h2><p>历史上的宴会，庆功大会有很多。但最盛大的，当属乾隆皇帝摆的满汉全席，参加者都是老人，最大的一百四十一岁了，因为人数众多，有几千人，所以名叫“千叟宴”。其实千叟宴是从康熙皇帝开始摆的，共举行的四次，乾隆皇帝摆的宴，规模最为宏大。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093348.jpg" alt="img"><br>千叟宴 </p><p>据史料记载，康熙皇帝举行的第一次千叟宴参加人数不下七千人，而乾隆皇帝第二次千叟宴，参加人数又起过了他的爷爷，列名参席者3056人，列名邀赏者尚5000人，加起来八千多人。岁数最大的郭钟岳据说141岁了，乾隆皇帝与纪晓岚送他一副对联：花甲重开，外加三七岁月；古稀双庆，内多一个春秋。堪称绝对。 </p><p>清朝以孝治国，千叟宴是皇帝以孝治国、尊老敬老最成功的一个案例。 </p><h2 id="宴会文友，有诗赋"><a href="#宴会文友，有诗赋" class="headerlink" title="宴会文友，有诗赋"></a>宴会文友，有诗赋</h2><p>文中饮酒，最盛大的一次宴会，当属唐朝长安城中的“饮中八仙”聚会。 </p><p>这八仙是：诗仙李白、诗人贺知章、书法家张旭、汝阳王李琎、左相李适之、美少年崔宗之、素食主义者苏晋、辩论高手焦遂。当然喝酒的可能还有其他人，但有名的是这八人，被后世称为饮中八仙。其中最有名的是李白、贺知章与张旭。杜甫为这次聚会专门做了一首诗，因此饮中八仙名闻天下。大家最熟知的李白，其诗曰：李白斗酒诗百篇，长安市上酒家眠。天子呼来不上船，自言臣是酒中仙。而草圣张旭，也有“张旭三杯草圣传，脱帽露顶王公前，挥毫落纸如云烟”流传后世。 </p><p>对酒饮愁，情谊长<br>美人饮酒，最有名的杨贵妃。史称“贵妃醉酒”。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-93349.jpg" alt="img"><br>饮中八仙 </p><p>杨贵妃为什么喝醉了呢？她本是寿王妃，被公公李隆基召进宫当了贵妃，三千宠幸于一身。但有一天，正当她摆酒迎接李隆基打算侍寝时，李隆基却到了梅妃的宫中去睡觉了。于是杨贵妃独自饮酒，这酒是吃醋的酒，嫉妒的酒，嗔怒的酒。杨贵妃的醉态更加美丽，更加风騒，旁边伺候的高力士及其他宫女都看呆了。喝完酒的杨贵妃没有等来李隆基，只得在太监的搀扶下独自睡觉去了。估计第二天李隆基知道杨贵妃因为等他喝醉了酒，会更加疼爱杨贵妃了吧。<br>历史上还有许多有名的饭局故事，比如“秦国和赵国的渑池会”，蔺相如为赵国争了光；关羽与鲁肃的“单刀赴会”，至今还有争议，到底是关羽还是鲁肃持着单刀赴那个英雄会；比如唐朝的郭子仪过个生日，引出了“打金枝”的故事；比如刘伶去杜康家喝了三碗酒，一醉醉了三年还活着，至今有款名酒叫刘伶醉……</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 饭局 </tag>
            
            <tag> 历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>所有优秀背后，都是苦行僧般的自律！</title>
      <link href="/zi-lu.html"/>
      <url>/zi-lu.html</url>
      
        <content type="html"><![CDATA[<h1 id="所有优秀背后，都是苦行僧般的自律！"><a href="#所有优秀背后，都是苦行僧般的自律！" class="headerlink" title="所有优秀背后，都是苦行僧般的自律！"></a>所有优秀背后，都是苦行僧般的自律！</h1><p> <img src="https://img.iamghf.top/blog/2020-01-11-092359.jpg" alt="img"><br> <strong>所有优秀背后，都是苦行僧般的自律。</strong><br>   胸中藏有大志的人，往往是一个很自律的人。 重庆谈判中，蒋介石曾对秘书陈布雷说：“毛不可轻视。他嗜烟如命，但他知道我不吸烟后，在同我谈话期间，竟绝不抽一支。对他的决心和精神，不可小视！” 自律的人，既可怕，又可敬。如果是伙伴，你要跟他学会律己；如果是对手，你要做好足够的心理准备。 以前总觉得，人生苦短，应及时行乐。今朝有酒今朝醉，人不风流枉少年。直到后来，我渐渐发现：每一个不自律的行为，都会给你带来更大的痛苦。不要做欲望的奴隶，自律可以令我们活得更高级。 自由的本质不是放纵自己，不是无所不为，而是自律之后的舒畅，是有所为，有所不为！</p><h2 id="——（壹）——"><a href="#——（壹）——" class="headerlink" title="——（壹）——"></a><strong>——（壹）——</strong></h2><p>   人为什么要自律？ 人为什么要自律？ 很多时候，我们只看到了别人优秀的样子，却往往忽略了他们为此付出了近乎自虐般的努力。 一个自律到骨子里的人，看上去大多是无趣的。 在别人出去玩乐的时候，一个人窝在那里看书；在别人享用着美食的时候，在健身房里挥汗如雨；周末的时光，很多人慵懒地睡到中午，他依旧雷打不动的早起、跑步、看书、工作… 这样的人，不仅看起来无趣，甚至感觉有自虐倾向，活得一点都不洒脱和自由。 但真实情况是，自律的人比不自律的人要自由得多。 如果你总是随心所欲，讲究及时行乐，不知道努力，别人玩你也玩，别人努力你还在玩，依旧放纵自己。 那么如此不自律的你，现在看似是自由的，但你会发现自己越活越没有自由，没有选择的资本。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092408.jpg" alt="img"><br>   康德说，所谓自由，不是随心所欲，而是自我主宰。 越自律，越有话语权，身体和人生都是如此。 一天两天看不出来，一个月两个月也许还是看不出来，但是一年两年，甚至十年二十年，自律的人和不自律的人，终将走上截然不同的道路。 付出和回报是成正比的，量变足够了才可能促成质变。 这就是一个人为什么要自律的原因，和梦想沾不上边，就是简简单单地为自己以后能真正自由一点，身体和人生都自由一点。 是啊。 越是自律的人越明白自己真正想要的是什么，所以才不会把时间和精力白白浪费在无意义的事情上，而是真的把碎片化时间都利用起来成长自己。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092415.jpg" alt="img">  </p><h2 id="——（贰）——"><a href="#——（贰）——" class="headerlink" title="——（贰）——"></a><strong>——（贰）——</strong></h2><p>   所有优秀 背后都有苦行僧般的自律 说要自律的人很多，可坚持自律的人很少，就像爬一座险峻的高山，越临近山顶，能够咬牙坚持往前走的人越少。 好的坚持，本身就是一种自律。 还记得去年的时候，一位名叫沈华的96岁老爷爷走红网络，健身26年的他体格健壮，完全不向一个近百岁的老人，大家都喊他“华仔”、“华叔”。 沈老每天的作息时间非常规律，从不超过晚上十点睡觉，早晨四点多就起床活动身体，每天下午到健身房报到。 他的同龄人很多都已经不在了，沈老说：“现在健身和运动是我最好的朋友”。 七十多岁的沈华最初进健身房，总遭遇很多白眼，很多人都觉得他一把年纪，肯定坚持不了多久，可现实是，很多年轻人只是健身房的过客，沈华却用二十年变成了为人熟知的“肌肉爷爷”。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092420.jpg" alt="img"><br>   日本作家村上春树从30岁开始写作，至今已快有40个年头，创作出了大量的作品，经典又高产。 村上春树写作有个习惯，他每天只写4000字，400字一页的纸，每天写到10页就停下来。 另外，他每天都会拿出一个小时出来跑步，雷打不动，正是这种高度自律，让他有精力能够持续产出优秀的作品出来。 商业大佬们的自律性更是可怕，李嘉诚那么成功的人士，依旧坚持每天晚饭后看英文电视，不仅看，还跟着大声说出来，怕自己落伍；每天临睡前坚持看书阅读。 同李嘉诚一样自律的商界大佬很多，世界首富比尔盖茨几十年来坚持每周至少看两本书。 很多时候，不是优秀才自律，而是你自律了，才会变得优秀。而那些自律的人，往往连老天爷都不忍心辜负他们。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092425.jpg" alt="img">   </p><h2 id="——（叁）——"><a href="#——（叁）——" class="headerlink" title="——（叁）——"></a><strong>——（叁）——</strong></h2><p>   越自律，越优秀 《认知突围》中有句话说：所有的懒惰、放纵、自制力不足，根源都在于认知能力受限。 越自律，认知能力越强，人和人的差距，就是这样逐渐拉开的。 一个人的自律中，藏着无限的可能性，你自律的程度，决定着你人生的高度。 每个人都有权利选择怎样活着，有人认为人生苦短，要及时行乐，没有问题，但我想告诉你，自律的人生其实更加美好，因为当你知道自己想要去哪儿并且全力以赴奔跑的时候，全世界都会为你让路。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092432.jpg" alt="img"><br>   真正能够登顶远眺的人，永远是那些心无旁骛，坚持着往前走的人。 愿我们真正成为自律的自己，活成自己喜欢的样子，过上自己想要的生活。 人生没有近路可走，但你走的每一步，都算数。 越勤奋，越努力；越自律，越优秀。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习十大算法</title>
      <link href="/ji-qi-xue-xi-shi-da-suan-fa.html"/>
      <url>/ji-qi-xue-xi-shi-da-suan-fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习十大算法"><a href="#机器学习十大算法" class="headerlink" title="机器学习十大算法"></a>机器学习十大算法</h1><p>机器学习是该行业的一个创新且重要的领域。我们为机器学习程序选择的算法类型，取决于我们想要实现的目标。</p><p>现在，机器学习有很多算法。因此，如此多的算法，可能对于初学者来说，是相当不堪重负的。今天，我们将简要介绍 10 种最流行的机器学习算法，这样你就可以适应这个激动人心的机器学习世界了！</p><p>让我们言归正传！</p><p>\1. 线性回归</p><p>线性回归（Linear Regression）可能是最流行的机器学习算法。线性回归就是要找一条直线，并且让这条直线尽可能地拟合散点图中的数据点。它试图通过将直线方程与该数据拟合来表示自变量（x 值）和数值结果（y 值）。然后就可以用这条线来预测未来的值！</p><p>这种算法最常用的技术是最小二乘法（Least of squares）。这个方法计算出最佳拟合线，以使得与直线上每个数据点的垂直距离最小。总距离是所有数据点的垂直距离（绿线）的平方和。其思想是通过最小化这个平方误差或距离来拟合模型。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025140.jpg" alt="img"></p><p>例如，简单线性回归，它有一个自变量（x 轴）和一个因变量（y 轴）</p><p>\2. 逻辑回归</p><p>逻辑回归（Logistic regression）与线性回归类似，但它是用于输出为二进制的情况（即，当结果只能有两个可能的值）。对最终输出的预测是一个非线性的 S 型函数，称为 logistic function, g()。</p><p>这个逻辑函数将中间结果值映射到结果变量 Y，其值范围从 0 到 1。然后，这些值可以解释为 Y 出现的概率。S 型逻辑函数的性质使得逻辑回归更适合用于分类任务。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025237.jpg" alt="img"></p><p>逻辑回归曲线图，显示了通过考试的概率与学习时间的关系。</p><p>\3. 决策树</p><p>决策树（Decision Trees）可用于回归和分类任务。</p><p>在这一算法中，训练模型通过学习树表示（Tree representation）的决策规则来学习预测目标变量的值。树是由具有相应属性的节点组成的。</p><p>在每个节点上，我们根据可用的特征询问有关数据的问题。左右分支代表可能的答案。最终节点（即叶节点）对应于一个预测值。</p><p>每个特征的重要性是通过自顶向下方法确定的。节点越高，其属性就越重要。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025313.jpg" alt="img"></p><p>决定是否在餐厅等候的决策树示例。</p><p>\4. 朴素贝叶斯</p><p>朴素贝叶斯（Naive Bayes）是基于贝叶斯定理。它测量每个类的概率，每个类的条件概率给出 x 的值。这个算法用于分类问题，得到一个二进制“是 / 非”的结果。看看下面的方程式。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025354.jpg" alt="img"></p><p>朴素贝叶斯分类器是一种流行的统计技术，可用于过滤垃圾邮件！</p><p>\5. 支持向量机（SVM）</p><p>支持向量机（Support Vector Machine，SVM）是一种用于分类问题的监督算法。支持向量机试图在数据点之间绘制两条线，它们之间的边距最大。为此，我们将数据项绘制为 n 维空间中的点，其中，n 是输入特征的数量。在此基础上，支持向量机找到一个最优边界，称为超平面（Hyperplane），它通过类标签将可能的输出进行最佳分离。</p><p>超平面与最近的类点之间的距离称为边距。最优超平面具有最大的边界，可以对点进行分类，从而使最近的数据点与这两个类之间的距离最大化。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025425.jpg" alt="img"></p><p>例如，H1 没有将这两个类分开。但 H2 有，不过只有很小的边距。而 H3 以最大的边距将它们分开了。</p><p>\6. K- 最近邻算法（KNN）</p><p>K- 最近邻算法（K-Nearest Neighbors，KNN）非常简单。KNN 通过在整个训练集中搜索 K 个最相似的实例，即 K 个邻居，并为所有这些 K 个实例分配一个公共输出变量，来对对象进行分类。</p><p>K 的选择很关键：较小的值可能会得到大量的噪声和不准确的结果，而较大的值是不可行的。它最常用于分类，但也适用于回归问题。</p><p>用于评估实例之间相似性的距离可以是欧几里得距离（Euclidean distance）、曼哈顿距离（Manhattan distance）或明氏距离（Minkowski distance）。欧几里得距离是两点之间的普通直线距离。它实际上是点坐标之差平方和的平方根。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025452.jpg" alt="img"></p><p>KNN 分类示例</p><p>\7. K- 均值</p><p>K- 均值（K-means）是通过对数据集进行分类来聚类的。例如，这个算法可用于根据购买历史将用户分组。它在数据集中找到 K 个聚类。K- 均值用于无监督学习，因此，我们只需使用训练数据 X，以及我们想要识别的聚类数量 K。</p><p>该算法根据每个数据点的特征，将每个数据点迭代地分配给 K 个组中的一个组。它为每个 K- 聚类（称为质心）选择 K 个点。基于相似度，将新的数据点添加到具有最近质心的聚类中。这个过程一直持续到质心停止变化为止。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025524.jpg" alt="img"></p><p>\8. 随机森林</p><p>随机森林（Random Forest）是一种非常流行的集成机器学习算法。这个算法的基本思想是，许多人的意见要比个人的意见更准确。在随机森林中，我们使用决策树集成（参见决策树）。</p><p>为了对新对象进行分类，我们从每个决策树中进行投票，并结合结果，然后根据多数投票做出最终决定。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025601.jpg" alt="img"></p><p>（a）在训练过程中，每个决策树都是基于训练集的引导样本来构建的。</p><p>（b）在分类过程中，输入实例的决定是根据多数投票做出的。</p><p>\9. 降维</p><p>由于我们今天能够捕获的数据量之大，机器学习问题变得更加复杂。这就意味着训练极其缓慢，而且很难找到一个好的解决方案。这一问题，通常被称为“维数灾难”（Curse of dimensionality）。</p><p>降维（Dimensionality reduction）试图在不丢失最重要信息的情况下，通过将特定的特征组合成更高层次的特征来解决这个问题。主成分分析（Principal Component Analysis，PCA）是最流行的降维技术。</p><p>主成分分析通过将数据集压缩到低维线或超平面 / 子空间来降低数据集的维数。这尽可能地保留了原始数据的显著特征。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025634.jpg" alt="img"></p><p>可以通过将所有数据点近似到一条直线来实现降维的示例。</p><p>\10. 人工神经网络（ANN）</p><p>人工神经网络（Artificial Neural Networks，ANN）可以处理大型复杂的机器学习任务。神经网络本质上是一组带有权值的边和节点组成的相互连接的层，称为神经元。在输入层和输出层之间，我们可以插入多个隐藏层。人工神经网络使用了两个隐藏层。除此之外，还需要处理深度学习。</p><p>人工神经网络的工作原理与大脑的结构类似。一组神经元被赋予一个随机权重，以确定神经元如何处理输入数据。通过对输入数据训练神经网络来学习输入和输出之间的关系。在训练阶段，系统可以访问正确的答案。</p><p>如果网络不能准确识别输入，系统就会调整权重。经过充分的训练后，它将始终如一地识别出正确的模式。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025701.jpg" alt="img"></p><p>每个圆形节点表示一个人工神经元，箭头表示从一个人工神经元的输出到另一个人工神经元的输入的连接。</p><p>接下来是什么？现在，你已经了解了最流行的机器学习算法的基础介绍。你已经准备好学习更为复杂的概念，甚至可以通过深入的动手实践来实现它们。如果你想了解如何实现这些算法，可以参考 Educative 出品的 Grokking Data Science 课程，该课程将这些激动人心的理论应用于清晰、真实的应用程序。</p><p>祝你学习愉快！</p><p><strong>作者介绍：</strong></p><p>Fahim ul Haq，曾在 Facebook、Microsoft 工作。Educative.io 联合创始人。Educative 旨在帮助学生使用交互式课程来学习编程知识。</p><p><strong>原文链接：</strong></p><p><a href="https://towardsdatascience.com/the-top-10-ml-algorithms-for-data-science-in-5-minutes-4ffbed9c8672" target="_blank" rel="noopener">https://towardsdatascience.com/the-top-10-ml-algorithms-for-data-science-in-5-minutes-4ffbed9c8672</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议详解</title>
      <link href="/http-xie-yi-xiang-jie.html"/>
      <url>/http-xie-yi-xiang-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h1><p>当今web程序的开发技术真是百家争鸣，ASP.NET, PHP, JSP，Perl, AJAX 等等。 无论Web技术在未来如何发展，理解Web程序之间通信的基本协议相当重要, 因为它让我们理解了Web应用程序的内部工作. 本文将对HTTP协议进行详细的实例讲解，内容较多，希望大家耐心看。也希望对大家的开发工作或者测试工作有所帮助。</p><h1 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h1><p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器</p><p>目前我们使用的是HTTP/1.1 版本</p><h1 id="Web服务器，浏览器-代理服务器"><a href="#Web服务器，浏览器-代理服务器" class="headerlink" title="Web服务器，浏览器,代理服务器"></a>Web服务器，浏览器,代理服务器</h1><p>当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？</p><p>实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022114.png" alt="img"></p><p>我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。</p><p>过程如下图所示</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022125.png" alt="img"></p><p>代理服务器就是网络信息的中转站，有什么功能呢？</p><p>\1. 提高访问速度， 大多数的代理服务器都有缓存功能。</p><p>\2. 突破限制， 也就是翻墙了</p><p>\3. 隐藏身份。</p><h1 id="URL详解"><a href="#URL详解" class="headerlink" title="URL详解"></a>URL详解</h1><p> URL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下</p><pre><code>schema://host[:port#]/path/.../[?query-string][#anchor]</code></pre><p>scheme        指定低层使用的协议(例如：http, https, ftp)</p><p>host          HTTP服务器的IP地址或者域名</p><p>port#         HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/" target="_blank" rel="noopener">http://www.cnblogs.com:8080/</a></p><p>path          访问资源的路径</p><p>query-string    发送给http服务器的数据</p><p>anchor-       锚</p><p>URL 的一个例子</p><p><a href="javascript:void(0);"><img src="https://img.iamghf.top/blog/2020-01-04-022115.gif" alt="复制代码"></a></p><pre><code>http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuffSchema:                 httphost:                   www.mywebsite.compath:                   /sj/test/test.aspxQuery String:           name=sviergn&amp;x=trueAnchor:                 stuff</code></pre><p><a href="javascript:void(0);"><img src="https://img.iamghf.top/blog/2020-01-04-022115.gif" alt="复制代码"></a></p><h1 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a>HTTP协议是无状态的</h1><p>http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</p><h1 id="打开一个网页需要浏览器发送很多次Request"><a href="#打开一个网页需要浏览器发送很多次Request" class="headerlink" title="打开一个网页需要浏览器发送很多次Request"></a>打开一个网页需要浏览器发送很多次Request</h1><p>\1. 当你在浏览器输入URL <a href="http://www.cnblogs.com" target="_blank" rel="noopener">http://www.cnblogs.com</a> 的时候，浏览器发送一个Request去获取 <a href="http://www.cnblogs.com" target="_blank" rel="noopener">http://www.cnblogs.com</a> 的html. 服务器把Response发送回给浏览器.</p><p>\2. 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。</p><p>\3. 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</p><p>\4. 等所有的文件都下载成功后。 网页就被显示出来了。</p><h1 id="HTTP消息的结构"><a href="#HTTP消息的结构" class="headerlink" title="HTTP消息的结构"></a>HTTP消息的结构</h1><p>先看Request 消息的结构,  Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-22117.png" alt="img"></p><p>第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号</p><p>当使用的是”GET” 方法的时候， body是为空的</p><p>比如我们打开博客园首页的request 如下</p><pre><code>GET http://www.cnblogs.com/ HTTP/1.1Host: www.cnblogs.com</code></pre><p>抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response.</p><p>下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息，  如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022118.png" alt="img"></p><p>我们再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行, 结构如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022119.png" alt="img"></p><p>HTTP/version-number表示HTTP协议的版本号， status-code 和message 请看下节[<a href="https://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html#statecode" target="_blank" rel="noopener">状态代码</a>]的详细解释.</p><p>我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Response的消息，  如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-22123.png" alt="img"></p><h1 id="Get和Post方法的区别"><a href="#Get和Post方法的区别" class="headerlink" title="Get和Post方法的区别"></a>Get和Post方法的区别</h1><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p><p>我们看看GET和POST的区别</p><p>\1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p><p>\2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p><p>\3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p><p>\4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p><p>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.</p><p>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p><p>1XX 提示信息 - 表示请求已被成功接收，继续处理</p><p>2XX 成功 - 表示请求已被成功接收，理解，接受</p><p>3XX 重定向 - 要完成请求必须进行更进一步的处理</p><p>4XX 客户端错误 - 请求有语法错误或请求无法实现</p><p>5XX 服务器端错误 -  服务器未能实现合法的请求</p><p>看看一些常见的状态码</p><p>200 OK</p><p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端</p><p>如下图， 打开博客园首页</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022123.png" alt="img"></p><p>302 Found</p><p>重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request</p><p>例如在IE中输入， <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022117.png" alt="img"></p><p>304 Not Modified</p><p>代表上次的文档已经被缓存了， 还可以继续使用，</p><p>例如打开博客园首页, 发现很多Response 的status code 都是304</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022124.png" alt="img"></p><p>提示：　如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面</p><p>400 Bad Request 客户端请求与语法错误，不能被服务器所理解</p><p>403 Forbidden 服务器收到请求，但是拒绝提供服务</p><p>404 Not Found</p><p>请求资源不存在（输错了URL）</p><p>比如在IE中输入一个错误的URL， <a href="http://www.cnblogs.com/tesdf.aspx" target="_blank" rel="noopener">http://www.cnblogs.com/tesdf.aspx</a></p><p><img src="https://img.iamghf.top/blog/2020-01-04-022116.png" alt="img"></p><p>500 Internal Server Error 服务器发生了不可预期的错误</p><p>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><h1 id="HTTP-Request-header"><a href="#HTTP-Request-header" class="headerlink" title="HTTP Request header"></a>HTTP Request header</h1><p>使用Fiddler 能很方便的查看Reques header, 点击Inspectors tab -&gt;Request tab-&gt; headers 如下图所示.</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022126.png" alt="img"></p><p>header 有很多，比较难以记忆，我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p><h2 id="Cache-头域"><a href="#Cache-头域" class="headerlink" title="Cache 头域"></a>Cache 头域</h2><p>If-Modified-Since</p><p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p><p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</p><p>实例如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022120.png" alt="img"></p><p>If-None-Match</p><p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能</p><p>例如: If-None-Match: “03f2b33c0bfcc1:0”</p><p>实例如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022121.png" alt="img"></p><p>Pragma</p><p>作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样</p><p>Pargma只有一个用法， 例如： Pragma: no-cache</p><p>注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p><p>Cache-Control</p><p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</p><p>Cache-Control:Public  可以被任何缓存所缓存（）</p><p>Cache-Control:Private   内容只缓存到私有缓存中</p><p>Cache-Control:no-cache 所有内容都不会被缓存</p><p>还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料</p><h2 id="Client-头域"><a href="#Client-头域" class="headerlink" title="Client 头域"></a>Client 头域</h2><p>Accept</p><p>作用： 浏览器端可以接受的媒体类型,</p><p>例如： Accept: text/html  代表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档,</p><p>如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)</p><p>通配符 * 代表任意类型</p><p>例如  Accept: <em>/</em>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)</p><p>Accept-Encoding：</p><p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;</p><p>例如： Accept-Encoding: gzip, deflate</p><p>Accept-Language</p><p>作用： 浏览器申明自己接收的语言。 </p><p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p><p>例如： Accept-Language: en-us</p><p>User-Agent</p><p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p><p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p><p>例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p><p>Accept-Charset</p><p>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；</p><p>例如：</p><h2 id="Cookie-Login-头域"><a href="#Cookie-Login-头域" class="headerlink" title="Cookie/Login 头域"></a>Cookie/Login 头域</h2><p>Cookie:</p><p>作用： 最重要的header, 将cookie的值发送给HTTP 服务器</p><h2 id="Entity头域"><a href="#Entity头域" class="headerlink" title="Entity头域"></a>Entity头域</h2><p>Content-Length</p><p>作用：发送给HTTP服务器数据的长度。</p><p>例如： Content-Length: 38</p><p>Content-Type</p><p>作用：</p><p>例如：Content-Type: application/x-www-form-urlencoded</p><h2 id="Miscellaneous-头域"><a href="#Miscellaneous-头域" class="headerlink" title="Miscellaneous 头域"></a>Miscellaneous 头域</h2><p>Referer:</p><p>作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p><p>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT" target="_blank" rel="noopener">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p><h2 id="Transport-头域"><a href="#Transport-头域" class="headerlink" title="Transport 头域"></a>Transport 头域</h2><p>Connection</p><p>例如：　Connection: keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p><p>例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p><p>Host（发送请求时，该报头域是必需的）</p><p>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p><p>例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html" target="_blank" rel="noopener">http://www.guet.edu.cn/index.html</a></p><p>浏览器发送的请求消息中，就会包含Host请求报头域，如下：</p><p>Host：<a href="http://www.guet.edu.cn" target="_blank" rel="noopener">http://www.guet.edu.cn</a></p><p>此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p><h1 id="HTTP-Response-header"><a href="#HTTP-Response-header" class="headerlink" title="HTTP Response header"></a>HTTP Response header</h1><p>同样使用Fiddler 查看Response header, 点击Inspectors tab -&gt;Response tab-&gt; headers 如下图所示</p><p><img src="https://img.iamghf.top/blog/2020-01-04-22120.png" alt="img"></p><p> 我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p><h2 id="Cache头域"><a href="#Cache头域" class="headerlink" title="Cache头域"></a>Cache头域</h2><p>Date</p><p>作用: 生成消息的具体时间和日期</p><p>例如：　Date: Sat, 11 Feb 2012 11:35:14 GMT </p><p>Expires</p><p>作用: 浏览器会在指定过期时间内使用本地缓存</p><p>例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT</p><p>Vary</p><p>作用：</p><p>例如: Vary: Accept-Encoding</p><h2 id="Cookie-Login-头域-1"><a href="#Cookie-Login-头域-1" class="headerlink" title="Cookie/Login 头域"></a>Cookie/Login 头域</h2><p>P3P</p><p>作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</p><p>例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</p><p>Set-Cookie</p><p>作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p><p>例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022122.png" alt="img"></p><h2 id="Entity头域-1"><a href="#Entity头域-1" class="headerlink" title="Entity头域"></a>Entity头域</h2><p>ETag</p><p>作用: 和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）</p><p>例如: ETag: “03f2b33c0bfcc1:0”</p><p>Last-Modified:</p><p>作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）</p><p>例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p><p>Content-Type</p><p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p><p>例如:</p><p>Content-Type: text/html; charset=utf-8</p><p>Content-Type:text/html;charset=GB2312</p><p>Content-Type: image/jpeg</p><p>Content-Length</p><p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p><p>例如: Content-Length: 19847</p><p>Content-Encoding</p><p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p><p>例如：Content-Encoding：gzip</p><p>Content-Language</p><p>作用： WEB服务器告诉浏览器自己响应的对象的语言者</p><p>例如： Content-Language:da</p><h2 id="Miscellaneous-头域-1"><a href="#Miscellaneous-头域-1" class="headerlink" title="Miscellaneous 头域"></a>Miscellaneous 头域</h2><p>Server:</p><p>作用：指明HTTP服务器的软件信息</p><p>例如:Server: Microsoft-IIS/7.5</p><p>X-AspNet-Version:</p><p>作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本</p><p>例如: X-AspNet-Version: 4.0.30319</p><p>X-Powered-By:</p><p>作用：表示网站是用什么技术开发的</p><p>例如： X-Powered-By: ASP.NET</p><h2 id="Transport头域"><a href="#Transport头域" class="headerlink" title="Transport头域"></a>Transport头域</h2><p>Connection</p><p>例如：　Connection: keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p><p>例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p><h2 id="Location头域"><a href="#Location头域" class="headerlink" title="Location头域"></a>Location头域</h2><p>Location</p><p>作用： 用于重定向一个新的位置, 包含新的URL地址</p><p> 实例请看304状态实例</p><h1 id="HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="HTTP协议是无状态的和Connection: keep-alive的区别"></a>HTTP协议是无状态的和Connection: keep-alive的区别</h1><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p><p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p><p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p><p> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript闭包</title>
      <link href="/javascript-bi-bao.html"/>
      <url>/javascript-bi-bao.html</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-闭包"><a href="#JavaScript-闭包" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h1><p>　Peter Mortensen问：</p><blockquote><p>就像老Albert所说的，“如果你不能向一个六岁的孩子解释清楚，那么其实你自己根本就没弄懂。”好吧，我试着向一个27岁的朋友就是JS闭包（JavaScript closure）却彻底失败了。</p><p>你们会怎么把它解释给一个充满好奇心的六岁孩子听呢？</p><p>注：我看过StackOverflow上给出的示例，但根本没用。</p></blockquote><p>　　Ali的回答：</p><p>　　当function里嵌套function时，内部的function可以访问外部function里的变量。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">++</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><p>　　不管执行多少次，都会alert 16，因为bar能访问foo的参数x，也能访问foo的变量tmp。</p><p>　　但，这还不是闭包。当你return的是内部function时，就是一个闭包。内部function会close-over外部function的变量直到内部function结束。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">++</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// bar 现在是一个闭包</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>　　上面的脚本最终也会alert 16，因为虽然bar不直接处于foo的内部作用域，但bar还是能访问x和tmp。</p><p>　　但是，由于tmp仍存在于bar闭包的内部，所以它还是会自加1，而且你每次调用bar时它都会自加1.</p><p>　　（考虑到六岁这个限制：我们其实可以建立不止一个闭包方法，比如return它们的数组，也可以把它们设置为全局变量。它们全都指向相同的x和相同的tmp，而不是各自有一份副本。）</p><p>　　注：现在来整点儿七岁的内容。</p><p>　　上面的x是一个字面值（值传递），和JS里其他的字面值一样，当调用foo时，实参x的值被复制了一份，复制的那一份作为了foo的参数x。</p><p>　　那么问题来了，JS里处理object时是用到引用传递的，那么，你调用foo时传递一个object，foo函数return的闭包也会引用最初那个object！</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>  x<span class="token punctuation">.</span>memb <span class="token operator">=</span> x<span class="token punctuation">.</span>memb <span class="token operator">?</span> x<span class="token punctuation">.</span>memb <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">alert</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>memb<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// bar 现在是一个引用了age的闭包</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>　　不出我们意料，每次运行bar(10)，x.memb都会自加1。但需要注意的是x每次都指向同一个object变量——age，运行两次bar(10)后，age.memb会变成2.</p><p>　　这和HTML对象的内存泄漏有关，呃，不过貌似超出了答题的范围。</p><p>　　JohnMerlino 对Ali说：</p><p>　　这里有一个不用return关键字的闭包例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">closureExample</span><span class="token punctuation">(</span>objID<span class="token punctuation">,</span> text<span class="token punctuation">,</span> timedelay<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>objID<span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> text<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span> timedelay<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">closureExample</span><span class="token punctuation">(</span>‘myDiv’<span class="token punctuation">,</span> ‘Closure is created’<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>　　深夜1:37 John Pick这样回答：</p><p>　　JS里的function能访问它们的：</p><p>　　1. 参数</p><p>　　2. 局部变量或函数</p><p>　　3. 外部变量（环境变量？），包括</p><blockquote><p>3.1 全局变量，包括DOM。</p><p>3.2 外部函数的变量或函数。</p></blockquote><p>　　如果一个函数访问了它的外部变量，那么它就是一个闭包。</p><p>　　注意，外部函数不是必需的。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出；但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据。</p><p>　　一个典型的例子就是全局变量的使用。</p><p>　　mykhal这样回答：</p><p>　　Wikipedia对闭包的定义是这样的：</p><blockquote><p>In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.</p></blockquote><p>　　从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。</p><p>　　Since <strong>scope-defining construction in Javascript is a function</strong>, not a code block like in many other languages, <strong>what we usually mean by *closure* in Javascript</strong> is a <strong>fuction working with nonlocal variables defined in already executed surrounding function</strong>.</p><p>　　闭包经常用于创建含有隐藏数据的函数（但并不总是这样）。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> db <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 创建一个隐藏的object, 这个object持有一些数据</span><span class="token comment" spellcheck="true">// 从外部是不能访问这个object的</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个函数, 这个函数提供一些访问data的数据的方法</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// get</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// set</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 我们可以调用这个匿名方法</span><span class="token comment" spellcheck="true">// 返回这个内部函数，它是一个闭包</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">db</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 undefined</span><span class="token function">db</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置data['x']为1</span><span class="token function">db</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 1</span><span class="token comment" spellcheck="true">// 我们不可能访问data这个object本身</span><span class="token comment" spellcheck="true">// 但是我们可以设置它的成员</span></code></pre><p>　　看了这么多外国大牛的解答，不知道你懂还是不懂，反正我是懂了。</p><p>　　P.S. 发布文章之后看到@xiaotie的<a href="http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html" target="_blank" rel="noopener">一篇文章</a>，觉得有必要推荐一下，因为其剖析得更为深入。有人说应该在文章结尾对闭包进行总结，可惜小弟才疏学浅，不能给出一个精辟的总结。</p><p>　　@xiaotie对闭包的总结如下：</p><blockquote><p>（1）闭包是一种设计原则，它通过分析上下文，来简化用户的调用，让用户在不知晓的情况下，达到他的目的；</p><p>（2）网上主流的对闭包剖析的文章实际上是和闭包原则反向而驰的，如果需要知道闭包细节才能用好的话，这个闭包是设计失败的；</p><p>（3）尽量少学习。</p></blockquote><p>　　大家学习学习。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个公司即将要倒闭的征兆是什么？</title>
      <link href="/gong-si-dao-bi.html"/>
      <url>/gong-si-dao-bi.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.iamghf.top/blog/2020-01-03-092331.jpg" alt="img"></p><p>我就经历过一个p2p公司荣辱兴衰。到现在为止，还欠我3个月工资加上杂七杂八的费用，也有6万左右。期间去劳动仲裁不管用，再去法院控告，对方不到庭，虽然胜了。但执行又是好大一笔费用，最后，心力人力憔悴，这事认个吃亏倒霉。</p><p>总结下，这家公司倒闭前的征兆，知友们可以补充。</p><p><strong>1.拼命不计成本的搞活动</strong></p><p>了解运营的小伙伴应该知道，拉新留存转化率，严盯获客成本。这个行业获客在8块左右很正常，做的活动很好，获客就低点。</p><p>到了后来，总监亲自下令只要拉来人就行，多搞活动，要搞大活动。没事，老板不差钱。底下员工各种线上线下活动搞起来，填写申请财务的单子一厚沓。我算了算当月的获客成本，足足有20元。大家知道借贷宝吧，那时候扫码就给25，只因人家背靠大树好乘凉，九鼎资本在后面能赔的起。</p><p>你一个小公司能跟人家比吗？不知道的员工还以为老板出手阔当，其实这是在跑路前的狂热，在圈钱。</p><p><strong>2.压缩人力资源成本</strong></p><p>人力资源成本是一个公司最不应该压缩的。别画饼，别梦想，就坐下来好好谈谈钱。谈好钱了，再谈梦想也不迟。员工出来工作的目的就是赚钱。</p><p>假如公司把人力资源成本压缩了，为了开源节流，那么，说明这个公司的变现能力很差。已经不能靠足够盈利来对冲掉内部员工的开支。</p><p>这种情况下，就要小心了。</p><p><strong>3.不把客户当成首位，爱答不理半死不活</strong></p><p>一个最明显的特征就是对新客户的后续服务已经漠不关心，老客户可能还有点人情味，新客户只要收到了钱，后续服务已经不再关心，甚至没收到钱，也不想努力去说服客户，这也代表这些市场人员想离开这家公司了。</p><p>尤其是和公司的盈利挂钩的直接部门，比如：线下的市场人员，线上的运营人员，是很多公司活下去的根本。假如他们都已经吊儿郎当，在公司摸鱼打卡混日子，多半公司已经没有前途了。他们都已经对公司没有了信心，某种程度上可以反应公司竞争力不行了。</p><p><strong>4.老板开始四处借钱</strong></p><p>这个也是后期我才知道的，距离老板消失没几天了。那时候抱得幻想才破灭了。知道在不主动出击就一分钱要不到了，结果还真是一分钱没要到。</p><p>资金链断裂很难修复，不管是民间借贷，还是发动公司员工集资，一旦出现这样的情况，都说明公司的财务状况不乐观。运气好能撑过去，运气不好就会很快倒闭。</p><p><strong>5.开始发不出工资或延后发工资时间</strong></p><p><strong>这条大家一定要记（加黑）</strong></p><p><strong>延后发工资时间，你可以再观望到实际发工资那天，假如没有直接辞职，这叫止损。</strong></p><p><strong>开始发不出工资了，这种情况下，不要听领导糊弄你的鬼话，其实他也是被老板糊弄的。开始发不出工资了，一定程度上解析为老板没钱了，你以为谁会给一个没钱的老板融资？</strong></p><p><strong>别抱有和公司风雨同舟的准备，那你就要有血本无归的觉悟。我当时是因为，不懂这方面，另外，那个领导对我一直不错。本着人情的关系傻乎乎的待住了。</strong></p><p><strong>出现这种情况及时辞职，一定一定！</strong></p><p><strong>6.核心领导频繁更换</strong></p><p>最早公司的模式很符合一个p2p的架构。等破产时候，接二连三，天天都有空降领导。这个总，那个总，这个背景牛逼，那个背景深。其实都是来救火的，代表这个公司已经存在很大的问题了。</p><p>管核心领导频繁更换不说，理层上也混乱起来，下属之间也是扯皮。公司的良性循环被打破，只剩下杂乱无章的发展。有了这种标志，也预示着公司有点穷途末路了。</p><p><strong>7.老板很长时间没有露脸</strong></p><p>开公司的不来公司，就对底下员工这么放心吗？</p><p>几回重大的会议，老板没有参加，这很不符合常理。</p><p>有一种可能是老板没法参加。</p><p>个中理由，自己猜测。但老板假如有问题了，那公司也岌岌可危。</p><p><strong>8.财务人员开始请辞</strong></p><p>这是我事后总结的一个征兆。财务是能碰到钱的，知道账面上有没有钱，公司的欠款什么的。他们这个部门就像去留的风向标，多注意。</p><p>来源：<a href="https://www.zhihu.com/question/283190849/answer/881415960" target="_blank" rel="noopener">知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 危机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我战胜了所有对手，却输给了时代！</title>
      <link href="/shu-gei-shi-dai.html"/>
      <url>/shu-gei-shi-dai.html</url>
      
        <content type="html"><![CDATA[<h1 id="大润发创始人挥泪离场：我战胜了所有对手，却输给了时代！"><a href="#大润发创始人挥泪离场：我战胜了所有对手，却输给了时代！" class="headerlink" title="大润发创始人挥泪离场：我战胜了所有对手，却输给了时代！"></a>大润发创始人挥泪离场：我战胜了所有对手，却输给了时代！</h1><p>历史的车轮滚滚向前，它不会因任何人的消极缓慢而停止。</p><p>时代抛弃你时，连一声再见都不会说。</p><p>大润发创始人离职时说：<strong>战胜了所有对手，却输给了时代。</strong></p><p>确实是这样，大润发在零售行业是一个号称19年不关一家店的传奇商场。在商场这个领域里，没有任何人能打败它，包括沃尔玛/家乐福，但是<strong>很可惜他败给了这个时代，被阿里巴巴收购，高层集体走人。</strong></p><p><img src="https://img.iamghf.top/blog/2020-01-03-023510.jpg" alt="img"></p><p><strong>1</strong></p><p>现在的竞争是怎么样的呢？</p><p>就像乌鸦喝水，一只老乌鸦经过长年累月的摸索，终于琢磨出了丢石子的方法，从此它就顺畅的喝到了水。并且它经常被人夸赞，方法还被写到教科书里！</p><p>然而忽然有一天，飞来了另外一群乌鸦。<strong>这群乌鸦人家根本不会衔石子，但个个嘴里都带着一根吸管：</strong></p><p><img src="https://img.iamghf.top/blog/2020-01-03-23608.jpg" alt="img"></p><p>这叫什么事嘛！</p><p>金庸小说里，金轮法王练了16年的武功，被杨过一招打败！</p><p>完全不按套路出牌。</p><p>的确，这个世界接下来就是不按套路出牌！</p><p><strong>2</strong></p><p>去年，著名数码相机品牌——尼康，关闭了它在中国的工厂。给出的理由是：<strong>智能手机的崛起侵占了原本属于数码相机的市场。</strong></p><p>按照传统的商业逻辑，尼康最多被索尼/佳能等等同行打败，没想到打败它的居然是另一个行业——<strong>智能手机。</strong></p><p>还是以数码相机行业为例，世界上曾经有一家世界500强的企业，名叫“柯达”，在1991年的时候，他的技术领先世界同行10年，但是2012年1月破产了，被做数码的干掉了。</p><p>当“索尼”还沉浸在数码领先的喜悦中时，突然发现，原来全世界卖照相机卖的最好的不是他，而是做手机的“诺基亚”，因为每部手机都是一部照相机，于是“索尼”业绩大幅亏损。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-023610.jpg" alt="img"></p><p>然后呢？</p><p>然后原来做电脑的“苹果”出来了，做出了触屏的智能手机，把手机世界老大的“诺基亚”给干掉了，而且没有还手之力：2013年9月，“诺基亚”被微软收购了……</p><p>事情还没完！</p><p>10年之后的今天，当苹果手机还在如日中天时，中国的华为异军突起，又发布了全球首款AI手机，将手机带入了人工智能时代</p><p><strong>3</strong></p><p>我之前曾写过一篇文章，讲的是方便面行业的衰败原因，当时也用过这句话。</p><p>方便面现在每年的销量以几十亿包的速度在减少，遭遇如此断崖式的危机，难道是产品出问题了吗？</p><p>不是的，反而是越做越精致，越来越全面，大的小的，干拌的，开水泡的，各种口味层出不穷，还请了一些口碑极好的明星代言宣传，但仍旧挽回不了衰败的颓势。</p><p>为什么这个曾连续18年销量保持增长的国民美食，在越做越用心的情况下，反而销量严重下滑呢？</p><p>因为有了外卖，自从外卖行业的横空出世，各种可口的美食半小时左右就能送到手上，这时候基本就没方便面什么事了。</p><p>打败康师傅的不是统一，不是今麦郎，更不是白象，不是任何一个平日里厮杀惨烈的竞争对手，而是美团、饿了么这些新兴公司，是散布在城市里大大小小的外卖美食小作坊。</p><p>就好像大润发超市，没有被沃尔玛干掉，没有被家乐福给抢走地盘，但仍被阿里巴巴收购，高层集体走人。</p><p>慢着，故事到这里还只是一个开始！</p><p>我们都知道：美团是做外卖的，滴滴是做打车的，两者井水不犯河水。</p><p>然而忽然有一天，一则“滴滴骑手招募令”在网上曝光，也就是说，打车起家的滴滴，竟然要和美团抢送餐的业务了！</p><p>这下可好，美团也宣布要进军打车业务了！为了抢夺司机资源，美团给前2万报名的司机（北京是前5万）将享受3个月0抽成的优惠。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-023607.jpg" alt="img"></p><p>下面是一张网上流传的图片，有人透露这是美团外卖渠道部的年会：最显眼的是这四个字：”灭饿除滴”。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-023609.jpg" alt="img"></p><p>乱了，乱了，全乱了！</p><p>以前，市场虽然很残酷，但我们最起码知道谁是敌人、谁是朋友。</p><p>现在呢？<strong>我们完全分辨不出来孰敌孰友了！</strong></p><p><strong>4</strong></p><p>再看几个例子：</p><p>对于80、90年代的人来说，儿时最珍贵的记忆莫过于一卷胶片，那个印在黑白时代的画面，——是整整一代人的情怀，也是那一年生人最美的芳华。</p><p>关于胶卷的记忆，大多数人脑海中第一个就会想到柯达(Kodak)，就是那个曾经闻名于世的“胶卷王国”，曾拥有将近8000多家的柯达冲印店。那些遍布大小城市街区里醒目的黄黑标识，就是孩子们最向往的地方。</p><p>可就在2012年1月19日，曾经的胶卷帝国一下子突然崩塌。柯达公司正式提出破产保护申请，市值一落千丈。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-023606.jpg" alt="img"></p><p>关于柯达衰落的原因，其实看一下数码相机在大众中掀起的潮流就知道了。而在当时，柯达却是十分抗拒新时代和新技术的来临。<strong>与其说柯达公司没有意识到，还不如说柯达是不愿意参与、推动数码技术的更新迭代，它步伐沉重地缓慢转身，然而，驻足时却发现时代的鸿沟已经清晰地将自己与前行者远远隔开。</strong>在数字化浪潮面前，曾带给无数人以美好记忆的柯达就这样被席卷着被带到了众人看不见的地方。</p><p><strong>讽刺的是，推倒柯达的数码影像技术，最早的发明者其实就是柯达。</strong>世界第一款数码相机由柯达的相机工程师Steve Sasson在1975年发明，并投入10亿美元进行相关研发，但是在当时数码业务并没有得到柯达高管们的重视，出于担心核心业务胶卷的地位受到影响，他们选择了放弃这次机会。</p><p>Steve Sasson曾告诉《纽约时报》，他发明出数码相机之后，管理层的反应是：<strong>“这很可爱，但千万别告诉任何人。”</strong></p><p>2000年以后，数码技术促使了很多行业变革，数码相机也得到了普及，佳能、尼康等日产照相机品牌抓住了这一时机，大规模地开发一系列的新机型。可是柯达依然一意孤行，执意投入在胶卷生产上，错过了数码技术这个风口。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-23611.jpg" alt="img"></p><p>一个时代以前，提起“Kodak Moment”(“柯达时刻”)，人们想到的是值得留存与回味的记忆。如今，再提到柯达，却成了企业高管的警钟：在颠覆性技术侵入市场的时候，必须要及时回应。</p><p>历史的车轮滚滚向前，它不会因任何人的消极缓慢而停止。庞大如诺基亚、记忆如柯达，它们的倒下显然不是个例。如今诺基亚贱卖，柯达败落，蝴蝶效应煽动的翅膀已经遍及几乎所有行业。整个世界都陷入一种焦虑。</p><p>正如达尔文所讲，<strong>在丛林里，最终能存活下来的，往往不是最高大、最强壮的，而是对变化能做出最快反应的物种。</strong></p><p><img src="https://img.iamghf.top/blog/2020-01-03-023608.jpg" alt="img"></p><p>《三体》里有一个名词，就是：<strong>降维打击。</strong>一个无意中路过了人类文明的歌者文明，发现了人类，于是就像捏死一直蚂蚁一样，顺手灭掉了太阳系。</p><p><strong>这就叫：我消灭你，但与你无关。</strong></p><p>这个时代的残酷在于，往往你被抛弃了还一头雾水，事先不会和你打一声招呼。</p><p>那些干掉你的，通常是你从未谋面过的陌生人，或是一些你从未放在心上的人和事，同你无冤无仇，但却来势凶猛，如同洪水猛兽般令人招架不住。</p><p><strong>5</strong></p><p>在如今这个时代，如果你隐居三年，彻底与世隔绝，当再次回归红尘之中，你会感到恍如隔了一个世纪。</p><p>一切都变化地太快，快到很多人的观念还停留在上一个时代，快到很多人还没来得及做出反应，就已经被打倒在地。</p><p>在我大学即将毕业的时候，有一次去奶奶家吃饭，奶奶就问我，毕业以后学校工作分配在哪里，是我们镇上的学校还是银行啊。</p><p>我告诉她，现在学校不包分配了，全都要自己找。</p><p>她感到很奇怪，然后就唠叨说家里哪个亲戚人家大学毕业后进了什么单位，现在日子有多好…</p><p><strong>很多父母辈们对于子女的工作，期望最多的一点就是：稳定。</strong></p><p>在他们的观念里，只要你进了一家大的单位，这辈子都不用愁了，能一直干到退休，每月拿着稳定的工资，就是最大的幸福。</p><p>但现实的情况是，无论是体制内还是体制外，都没有绝对稳定的工作，谁都无法保证手上的饭碗明天还能不能端上。</p><p>那个唐山收费站的大姐没想到，那些被机器人取代了岗位的富士康员工也没想到…</p><p>在这个时代的车轮碾压下，没有人是可以逃离的，如果不做好准备，如果没有这方面的危机意识，那么当噩运来得时候，往往会招架不住，犹如天塌。</p><p>温水煮青蛙的故事我们都知道，那只青蛙一直陶醉在稳定的舒适区，幻想着岁月静好，却从来没有想过有一天，这水会热到发烫，而自己却无力跳出。</p><p><strong>未来没有稳定的工作，只有稳定的能力。</strong></p><p><strong>未来只有一种稳定：是你到哪里都有饭吃！</strong></p><p>有本事的人到哪都有饭吃，即使身背巨债，依旧可以东山再起。</p><p>而大多数人目前却处于排斥学习的状态，自然也就难以摆脱迷茫，更难以挣到钱，这才是焦虑最主要的原因。</p><p>认清这个时代，拥抱这个时代，然后活好余生。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大润发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50张2019年度最美照片，每一张都是大自然的奇迹</title>
      <link href="/2019-nian-du-zhao-pian.html"/>
      <url>/2019-nian-du-zhao-pian.html</url>
      
        <content type="html"><![CDATA[<h1 id="50张2019年度最美照片，每一张都是大自然的奇迹"><a href="#50张2019年度最美照片，每一张都是大自然的奇迹" class="headerlink" title="50张2019年度最美照片，每一张都是大自然的奇迹"></a>50张2019年度最美照片，每一张都是大自然的奇迹</h1><p>  【2019年AGORA大奖 50张入围摄影作品】<br> 经过几个月的激烈角逐，2019年AGORA大奖揭晓了入围的50张摄影作品。<br> 下面这些精美的图片从13万张作品中脱颖而出。每一张都风格独特，充满震撼力。请看大屏幕：</p><p>#1 蚂蚁扛起地球<br><img src="https://img.iamghf.top/blog/2019-12-29-130544.jpg" alt="img"><br>一只蚂蚁举起落在线上的水滴，摄影师花了4个小时才拍下这张照片。<br>@anadgphotography(菲律宾)，Analiza De Guzman/AGORA images<br>#2 最好的朋友<br><img src="https://img.iamghf.top/blog/2019-12-29-130556.jpg" alt="img"><br>蜥蜴和蜗牛的超萌瞬间。<br>@andihalil(印度尼西亚)，Andi Halil / AGORA images<br>#3 收获香料<br><img src="https://img.iamghf.top/blog/2019-12-29-130606.jpg" alt="img"><br>在越南，香料被认为可以让活人与祖先以神灵相通。<br>@ptkhanhhvnh(越南)，Khanh Phan/AGORA images<br>#4 触碰天堂<br><img src="https://img.iamghf.top/blog/2019-12-29-130612.jpg" alt="img"><br>法国的圣米歇尔山隐身于云雾之中。<br>@thedronelad(英国)，Konrad Paruch/AGORA images<br>#5 自由之歌<br><img src="https://img.iamghf.top/blog/2019-12-29-130624.jpg" alt="img"><br>这不仅仅是一张照片——更是一场自由与归属的无声斗争，灵感来自Bob Marley的《救赎之歌》。<br>@eighthman(加纳)，Michael Aboya/AGORA images<br>#6 雨天<br><img src="https://img.iamghf.top/blog/2019-12-29-130632.jpg" alt="img"><br>西爪哇的红眼树蛙。<br>@hendymp(印度尼西亚)，Hendy MP/AGORA images<br>#7 沙海孤旅<br><img src="https://img.iamghf.top/blog/2019-12-29-130639.jpg" alt="img"><br>这张照片摄于摩洛哥梅如卡的沙丘上，在那里你可以看到游牧民族穿越撒哈拉沙漠。<br>@carlesalonsophotography(西班牙)，Carles Alonso/AGORA images<br>#8 母亲的温柔<br><img src="https://img.iamghf.top/blog/2019-12-29-130645.jpg" alt="img"><br>抓拍到戴胜鸟喂孩子的完美瞬间。<br>@phyomoe(缅甸)，Phyo Moe/AGORA images<br>#9 未知的回声<br><img src="https://img.iamghf.top/blog/2019-12-29-130651.jpg" alt="img"><br>摄影师想要表现的是人与动物间的亲密关系。@theeastwoodexperience(加纳)，Clement Eastwood/AGORA images<br>#10 奔跑，嬉闹<br><img src="https://img.iamghf.top/blog/2019-12-29-130658.jpg" alt="img"><br>小僧侣们在欣毕梅佛塔玩得很开心。<br>@lingling25(缅甸)，Ling Ling/AGORA images<br>#11 生活的色彩<br><img src="https://img.iamghf.top/blog/2019-12-29-130704.jpg" alt="img"><br>在去市场前，女性们在西孟加拉邦捕鱼。<br>@pranab_basak(印度)，Pranab Basak/AGORA images<br>#12 地球的血脉<br><img src="https://img.iamghf.top/blog/2019-12-29-130710.jpg" alt="img"><br>这张神似亚马逊河的照片摄于东苏塞克斯郡，那里的卡克米尔河将草原隔开。<br>@hugohealy(英国)，Hugo Healy/AGORA images<br>#13 在光影下制作蜡染工艺品<br><img src="https://img.iamghf.top/blog/2019-12-29-130715.jpg" alt="img"><br>这是印度尼西亚日惹的蜡染。蜡染是一门古老的技艺，摄影师希望通过这张照片让它传承下去。<br>@<em>bimo</em>(印度尼西亚)，Bimo Pradityo/AGORA images<br>#14 沙蜂与猎物<br><img src="https://img.iamghf.top/blog/2019-12-29-130721.jpg" alt="img"><br>这只沙蜂正要把猎物带回家!<br>@pokokemoto(印度尼西亚)，Imam Primahardy/AGORA images<br>#15 野性的凝视<br><img src="https://img.iamghf.top/blog/2019-12-29-130726.jpg" alt="img"><br>卡巴塞诺自然公园拍到的猞猁。<br>@saavedraphotography(西班牙)，Sergio Saavedra/AGORA images<br>#16 雷讷之虹<br><img src="https://img.iamghf.top/blog/2019-12-29-130732.jpg" alt="img"><br>在挪威罗浮敦群岛的一座桥上，摄影师看到了双彩虹。<br>@uglefisk(挪威)，Paal Lund/AGORA images<br>#17 彩色屋<br><img src="https://img.iamghf.top/blog/2019-12-29-130737.jpg" alt="img"><br>荷兰格罗宁根市的长曝光日落。<br>@anskar(德国)，Anskar Lenzen/AGORA images<br>#18 母性之爱<br><img src="https://img.iamghf.top/blog/2019-12-29-130742.jpg" alt="img"><br>在西班牙的特内里费动物园，摄影师等了两个多小时才捕捉到黑猩猩和幼崽间的温馨时刻。<br>@santiagolopezfotografia, Santiago Lopez /AGORA images<br>#19 未知<br><img src="https://img.iamghf.top/blog/2019-12-29-130749.jpg" alt="img"><br>照片摄于东爪哇的赛武瀑布，想要镜头不湿，这对摄影师来说很不容易。<br>@jprphotos（英国），Jonathan Rogers/AGORA images<br>#20 撒网<br><img src="https://img.iamghf.top/blog/2019-12-29-130755.jpg" alt="img"><br>渔夫在万隆巴登岗湖捕鱼。<br>@g13nnn(印度尼西亚), Glenn Valentino/AGORA images<br>#21 神情<br><img src="https://img.iamghf.top/blog/2019-12-29-130802.jpg" alt="img"><br>巴基斯坦神庙的圣僧。<br>@asimijaz(巴基斯坦)，Asim Ijaz/AGORA images<br>#22 白伞之间<br><img src="https://img.iamghf.top/blog/2019-12-29-130808.jpg" alt="img"><br>缅甸曼德勒的传统制伞厂。传统雨伞的制作一个人无法完成，也不可能在一天之内完成。制作一把雨伞需要分工，每个人的分工都不同。<br>@aungthuya(缅甸)，Aung ThuYa/AGORA images<br>#23 暗黑迪士尼<br><img src="https://img.iamghf.top/blog/2019-12-29-130815.jpg" alt="img"><br>新天鹅城堡的俯瞰，据说这是迪士尼城堡的原型。<br>@tommimatz(德国)，Tommi Matz/AGORA images<br>#24 天意难违<br><img src="https://img.iamghf.top/blog/2019-12-29-130820.jpg" alt="img"><br>法国布列塔尼的沉船墓地。有些船在那里已有100多年的历史了。<br>@charliieb(摩纳哥)，Charlie Berthaume/AGORA images<br>#25 海洋之心<br><img src="https://img.iamghf.top/blog/2019-12-29-130827.jpg" alt="img"><br>越南渔网的航拍照片。<br>@phannguyen5285(越南)，Nguyen Phan Xuan/AGORA images<br>#26 世上最美的环形路口<br><img src="https://img.iamghf.top/blog/2019-12-29-130832.jpg" alt="img"><br>巴黎凯旋门的俯瞰全景，12条大街汇集在一起。<br>@henrydo(美国)，Henry Do/AGORA images<br>#27 冰之海<br><img src="https://img.iamghf.top/blog/2019-12-29-130838.jpg" alt="img"><br>专业野生动物摄影师在南极拍下了这张照片。捕食蟹类的海豹喜欢在冰块上小憩。<br>@florianledoux(法国)，Florian Ledoux/AGORA images<br>#28 雪中牧马人<br><img src="https://img.iamghf.top/blog/2019-12-29-130844.jpg" alt="img"><br>蒙古的冬天。<br>@zayyarlin(缅甸)，Zay Yar Lin/AGORA images<br>#29 舞者<br><img src="https://img.iamghf.top/blog/2019-12-29-130849.jpg" alt="img"><br>摄于雅典和平友谊体育场。<br>@markellos(希腊)，Markellos Plakitsis/AGORA images<br>#30 斑马之眼<br><img src="https://img.iamghf.top/blog/2019-12-29-130854.jpg" alt="img"><br>这张照片拍摄于马德里野生动物园。<br>@s.p。marin(西班牙)，Sara Pinto marin /AGORA images<br>#31 悬而未定<br><img src="https://img.iamghf.top/blog/2019-12-29-130859.jpg" alt="img"><br>这张照片摄于加州托多斯桑托斯的公路旅行。摄影师很幸运，后来他还与这些动物们一起潜水了!<br>@jordisark(西班牙)，Jordi Sark/AGORA images<br>#32 水牛回栏<br><img src="https://img.iamghf.top/blog/2019-12-29-130906.jpg" alt="img"><br>在越南中部的波来古洗澡的水牛。<br>@hoangquocvinh, Hoang Quocvinh/AGORA images<br>#33 日食钻石环<br><img src="https://img.iamghf.top/blog/2019-12-29-130913.jpg" alt="img"><br>2017年的日全食，摄于内布拉斯加州。<br>@edoindo(美国)，Edward Panjaitan/AGORA images<br>#34 等待的女人<br><img src="https://img.iamghf.top/blog/2019-12-29-130918.jpg" alt="img"><br>在罗马的罗通达广场，女人在香肠店等着买东西。<br>@paulaaranoa(阿根廷)，Paula Aranoa /AGORA images<br>#35 水即生命<br><img src="https://img.iamghf.top/blog/2019-12-29-130924.jpg" alt="img"><br>虽然台风在菲律宾很常见，但菲律宾人仍然崇拜水这种赋予生命的元素。<br>@froirivera(菲律宾)，Froi Rivera/AGORA images<br>#36 忆往昔<br><img src="https://img.iamghf.top/blog/2019-12-29-130930.jpg" alt="img"><br>孤独的男人望着日本神户的地平线。<br>@patriciasoon(马来西亚)，Patricia Soon/AGORA images<br>#37 草莓的温室<br><img src="https://img.iamghf.top/blog/2019-12-29-130934.jpg" alt="img"><br>在土耳其爱琴海地区草莓田里工作的年轻女子。<br>@leylaemektar(土耳其)，Leyla Emektar/AGORA images<br>#38 开斋节的祈祷<br><img src="https://img.iamghf.top/blog/2019-12-29-130939.jpg" alt="img"><br>斋月的斋戒之后，在伊斯兰猎月第一天进行开斋节祈祷。<br>@azimronnie(孟加拉国)，Azim Ronnie/AGORA images<br>#39 耕作<br><img src="https://img.iamghf.top/blog/2019-12-29-130944.jpg" alt="img"><br>这张照片摄于越南北部的稻田。农夫们正为下一季的丰收在插秧。<br>@diepvan(越南)，Diep Van/AGORA images<br>#40 六尺之下<br><img src="https://img.iamghf.top/blog/2019-12-29-130948.jpg" alt="img"><br>乌克兰一个雾蒙蒙的早晨，摄影师看到一个男人在墓地里徒手挖坟。<br>@davidedziegler(西班牙)，David Carbonell/AGORA images<br>#41 大雨滂沱<br><img src="https://img.iamghf.top/blog/2019-12-29-130953.jpg" alt="img"><br>摄影师为父亲拍下在雨中极具张力的肖像。<br>@wunderbilder(德国)，Perry Wunderlich/AGORA images<br>#42 蓝色之眼<br><img src="https://img.iamghf.top/blog/2019-12-29-130958.jpg" alt="img"><br>摄影师拍下了他儿子在巴伦西亚的艺术科学城奔跑的瞬间。<br>@ajuriaguerra(西班牙)，Pedro Luis Ajuriaguerra Saiz/AGORA images<br>#43 生命之光<br><img src="https://img.iamghf.top/blog/2019-12-29-131003.jpg" alt="img"><br>这是清晨中的西拉洪大桥，它位于打横和尖米士的交界处，1893年由荷兰殖民者建造。<br>@dikyedarling(印度尼西亚)，Dikye Ariani/AGORA images<br>#43 开启一切的火花<br><img src="https://img.iamghf.top/blog/2019-12-29-131007.jpg" alt="img"><br>在加泰罗尼亚的传统节日期间，装扮成恶魔的人们在人群中燃放烟花。<br>@xopet1969(西班牙)，Albert Castane /AGORA images<br>#45 奋勇向前<br><img src="https://img.iamghf.top/blog/2019-12-29-131012.jpg" alt="img"><br>这张照片是在尼亚斯岛附近拍摄的，该地是著名的冲浪胜地。<br>@bastian_as(印度尼西亚)，Bastian AS/AGORA images<br>#46 准备开斋节的食物<br><img src="https://img.iamghf.top/blog/2019-12-29-131019.jpg" alt="img"><br>这三个人在准备1000盘鸡肉和米饭，为开斋做准备。<br>@dharmaku(印度尼西亚)，Dharma Kurniawan/AGORA images<br>#47 消防员<br><img src="https://img.iamghf.top/blog/2019-12-29-131024.jpg" alt="img"><br>孟加拉国发生了一起电路起火事故，当地居民和消防员组团灭火。<br>@tanveer.rohan(孟加拉国)，Tanveer rohan /AGORA images<br>#48 出海的”地中海邮轮管乐号“<br><img src="https://img.iamghf.top/blog/2019-12-29-131029.jpg" alt="img"><br>来自泽西海峡群岛的18岁摄影师是本届大赛最年轻的入围者。邮轮正在他家乡附近的港口航行。<br>@above_and_beyond_visuals(英国)，Cameron Aird/AGORA images<br>#49 农场和道路被洪水淹没<br><img src="https://img.iamghf.top/blog/2019-12-29-131035.jpg" alt="img"><br>伊朗北部的戈尔甘市发生了洪灾。<br>@mohammadmoheimany(伊朗)，Mohammad Moheimani/AGORA images<br>#50 男孩们<br><img src="https://img.iamghf.top/blog/2019-12-29-131044.jpg" alt="img"><br>通过这张照片，摄影师想要表现两个人类之间的平等。<br>@diegocampomar(乌拉圭)，Diego Campomar/AGORA images</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 照片 </tag>
            
            <tag> AGORA大奖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变</title>
      <link href="/xia-wen-hua.html"/>
      <url>/xia-wen-hua.html</url>
      
        <content type="html"><![CDATA[<h1 id="从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变"><a href="#从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变" class="headerlink" title="从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变"></a>从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变</h1><p>提起侠客一词，大部分人的第一印象便是金庸武侠小说中武功高强行侠仗义的英雄人物，他们或放荡不羁，或洒脱高洁，引得人深深向往。诚然，历史上的侠客如影视文学作品中的不在少数，但其实，他们也是在随时间经历了数代演变之后，才形成此类特征。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132536.jpg" alt="img"> </p><p>侠客产生的社会背景</p><p>古代生产工具的落后注定了社会资源生产效率的低下，这导致平民百姓的生活只能在温饱线上挣扎。若是遇到政治黑暗的年代，基本生存亦会更加困难。</p><p>因此，在精神上，这种对上天的无奈和对社会不公现象的愤懑，使得平民百姓渴望有一位“取予然诺，千里诵义，为死不顾世”的侠客来帮助自己摆脱困苦，侠客精神也顺应这种希望而产生。</p><p>由于周王朝初期便定下的以礼教人、以德服人的社会管理方针，当时人们的思想道德水平也普遍拔高，这使得侠客之行有了实施者与承担者。同时，这些侠客不为自己谋私利的行为出发目的，也为他们积累的大量的声望，成为时人钦佩与敬仰的对象。在这样的社会影响下，侠客自然也层出不穷。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132545.jpg" alt="img"> </p><p>以身触法，江湖留名</p><p>早期侠客的行为准则与行为规范全凭自己的道德底线与个人喜好，他们既不受朝廷管理，也不为法律约束。虽然他们人数不多，但大都由于继承了先秦时期的良好风范与高尚情操，所以道德水平与目光远见方面，也远超常人。</p><p>也正由于这类人的存在，才形成了侠客精神在历史发展中的第一阶段：游侠。他们的行为绝非是为了功名利禄与显赫名声，相反，由于他们所解救的人中大多与政治有所瓜葛，这导致他们时常与官府为敌，甚至连累自己遭到通缉也是家常便饭。</p><p>但是，与莫大危险相对应的，却是在江湖上极高的威望与名声。如汉朝时期的朱家与郭解，便是在冒着生命危险的情况下，在解救了成千上百人的性命之后，才得到了“自关以东,莫不延颈愿交焉。”的社会地位。又如《水浒传》中的宋江，也是在这样的情况下才能稳坐后期梁山泊的第一把交椅。</p><p>也许这种社会地位并非他们主观上所故意造成的，但作为他们付出的代价，这种回报却是他们应该得到的。由此可见，游侠人士在当时江湖中的影响力与声望是极为强大的。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132552.jpg" alt="img"> </p><p>时代更迭，思想挣扎</p><p>由于唐朝国力的鼎盛，莫说王公贵族，即便是普通百姓，在社会生活上也处于一种较为奢侈的状态。而西域与唐朝之间的频繁贸易往来，更使得当时的文化在杂糅百家之后，显得多姿多彩。</p><p>繁华的生活，灿烂的文化，再加上文人墨客的渲染，都令尚有春秋遗留之风的游侠不再将自己限制于所谓的儒家君子道德之中，保持着一颗淡泊明志的心，而是开始向朝廷靠拢，想要追求自己的一片荣华富贵。</p><p>也因此，侠客也产生了在历史发展中的第二个阶段：豪侠。“红线夜盗魏博节度使田承嗣床头金盒;聂隐娘为陈许节度使刘昌裔屡退刺客 ; 虬髯客更是有图王之志。”，这些虽只是文学作品的片段，但也在一定程度反映了当时试图改变的侠客们的真实影像。</p><p>但千年传承下来的游侠之风，却仍深深影响着豪侠们的思想与行为。李白诗中所言“事了拂衣去，深藏功与名”实际反映了在当时人们的心中，侠客依旧应该是那种不谋私利不问世事的人。</p><p>而这也使得依托平民百姓而存在的豪侠们，在此种思想的影响下不敢完全投身于功名利禄的追求之中，甚至即便在被官府重用之后，也要尽快脱身，不愿沉陷其中。由此可见，夹在官府与江湖中间的豪侠们，其思想上相比于充满江湖气息的游侠和其后充满官宦气息的官侠相比，具有更多的复杂性与可变性。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132559.jpg" alt="img"> </p><p>官府招安，江湖渐远</p><p>宋朝后，社会经济的快速发展与市民阶层地位的提升，使统治者不得不在某些方面对广大百姓做出政策上的让步。大量从社会底层脱颖而出的士人进入官场，虽然他们政见不同，想法不一，但却大都为官清廉，品格正直。在这种社会良好风气的更正下，普通百姓对清官的依赖，渐渐高于相比之下更加虚无缥缈的侠人义士。</p><p>再加上深受儒家“为官入仕”思想的影响，人们的希望已普遍不在所谓的侠客身上，而是更希望自己进入朝廷，为民造福，侠的思想也因此开始体现在官的身上。当平民百姓的思想改变之后，摇摆于江湖与官府之间的豪侠们，也渐渐转投于官府的怀抱，不再犹犹豫豫。</p><p>作为中国武侠小说中的代表，《三侠五义》通过对几位侠客的故事叙述。描绘出了一副江湖气息十足的画卷。但需要注意的是，在这部小说中，不同侠客们行为动机的背后却都指向同一个目标：功名利禄。</p><p>也许他们的除暴安良行为确实满足了普通百姓的需要与愿望，但其本质目的，却是将此作为自己拜见朝廷的投名状，以获取更高的政治地位。官侠作为豪侠的接替形式，也借此登上历史的舞台，并最终成为侠客在中国历史发展中的最后一个阶段。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132606.jpg" alt="img"> </p><p>侠客们自游至官的背后原因</p><p>在中国社会的千年发展中，由于封建统治者自身的统治需要，一系列禁锢大众百姓思想的措施被运用。无论是宋朝的“存天理，灭人欲”思想，还是明清时期靠八股文取士的政策，都使得人们的思维愈发僵化，甘当侠客的人渐渐消失。而有关侠客的事迹，也在《汉书》过后，不再记录于书本之中。</p><p>与此同时，随着社会秩序的愈发严格与管理系统的愈发完善，原始侠客们的社会生存空间愈发受限，他们也不得不另谋出路以作资。在这种循环下，侠客行为变得愈发具有功利性而逐渐丧失原有的自发性，也属历史发展的必然。</p><p>同时，科举制度在隋唐之后的盛行，也对下层平民百姓的生活造成了巨大的影响。不管是两汉察举制还是魏晋九品中正制，都使得贵家大族垄断了为官之路，普通人难有出头之日。</p><p>然而，在科举制度施行后，下层群众的拔擢机会显而易见地扩大，当读书与做官紧密结合在一起后，百姓们的入仕积极性也显著提高，这一中国古代发展史的大变革，却间接造成了侠客们后继无人的尴尬情况。</p><p>社会主流思潮的改变，也对侠客的存在产生了致命的打击。因为侠客们自身武功高强，非寻常人能敌，再加上他们以暴制暴的惯用手法，万一在行侠仗义的过程中对无辜者造成了伤害，无人赔偿这种损失便成了一个社会现实性的问题。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132614.jpg" alt="img"> </p><p>久而久之，侠客们的社会声望与自身名气开始受到致命性打击，他们也不再受到群众的爱戴与拥护。侠客们作为不受朝廷控制与法律监管的人，早就为朝廷所忌惮，而在没了“白昼杀人红尘中,京兆知名不敢捕。”的社会地位后，他们的人身安全开始受到极大的威胁。</p><p>在这种情况之下，相比对抗官府，加入其中，反倒成了最好的解决措施与选择。</p><p>虽然不同时期的侠客对社会的影响的深度不同，但不可否认的是，他们早已渗透进人们生活的方方面面。侠客们的故事作为大众百姓茶余饭后的谈资，极大丰富了人们的日常生活，他们的行为也被不断模仿，成为中华文化的一种符号。</p><p>而作为说书先生和文学作品的描写对象，他们又在客观上促进了古代商品经济的发展，推动了平民阶层地位的提升。同时，侠客们作为曾经百姓所崇拜与敬仰的对象，他们自身所拥有的品格与修养也在不自觉中成为了中国道德标准的一部分，在千年间对国人的思想观念造成了巨大的影响。</p><p>其实，侠客精神在我国的文明传承中从未消失，它只是在不同时代有着不同的显现方式而已。无论是战争时代抗击外敌侵略的英勇战士，还是在和平社会乐于助人的热心群众，都是传统侠义精神的传承者与实施者。而行侠仗义这种方式，也在不断地文明进步中，更加合理、自然的融入这个社会。</p><p>参考资料:</p><p>《史记·游侠列传》</p><p>《论武侠小说》</p><p>《中国文学侠特征的异变及启示》</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 侠客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles 抓包使用教程</title>
      <link href="/charles-zhua-bao-shi-yong-jiao-cheng.html"/>
      <url>/charles-zhua-bao-shi-yong-jiao-cheng.html</url>
      
        <content type="html"><![CDATA[<h1 id="Charles-抓包使用教程"><a href="#Charles-抓包使用教程" class="headerlink" title="Charles 抓包使用教程"></a>Charles 抓包使用教程</h1><ul><li><p>charles使用教程</p></li><li><p>将 Charles 设置成系统代理</p></li><li><p>Charles 主界面介绍</p></li><li><p>过滤网络请求</p></li><li><p>截取 iPhone 上的网络封包</p></li><li><p>截取 Https 通讯信息</p></li><li><p>模拟慢速网络</p></li><li><p>修改网络请求内容</p></li><li><p>给服务器做压力测试</p></li><li><p>修改服务器返回内容</p></li><li><p>总结</p></li><li><p><strong>简介</strong></p></li><li><p><img src="https://img.iamghf.top/blog/2019-12-27-082708.png" alt="img"></p><p><a href="http://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a> 是在 Mac 下常用的网络封包截取工具，在做 <a href="http://lib.csdn.net/base/wechat" target="_blank" rel="noopener"><strong>移动开发</strong></a>时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p><p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p><p>除了在做<a href="http://lib.csdn.net/base/android" target="_blank" rel="noopener"><strong>移动开发</strong></a>中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p><p>Charles 主要的功能包括：</p><ol><li>截取 Http 和 Https 网络封包。</li><li>支持重发网络请求，方便后端调试。</li><li>支持修改网络请求参数。</li><li>支持网络请求的截获并动态修改。</li><li>支持模拟慢速网络。</li></ol></li></ul><p>  <strong>将 Charles 设置成系统代理</strong></p><p>  之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。</p><p>  启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” –&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082741.png" alt="img"></p><p>  之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。</p><p>  需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。</p><p>  <strong>Charles 主界面介绍</strong></p><p>  <strong><em>\</em><img src="https://img.iamghf.top/blog/2019-12-27-082748.png" alt="img">**</strong></p><p>  Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。</p><ol><li><p>Structure 视图将网络请求按访问的域名分类。</p></li><li><p>Sequence 视图将网络请求按访问的时间排序。</p><p>大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。</p><p>对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。</p></li></ol><p>  <strong>过滤网络请求</strong></p><p>  通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法：</p><p>  方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：<a href="http://yuantiku.com" target="_blank" rel="noopener">http://yuantiku.com</a> , 那么只需要在 Filter 栏中填入 yuantiku 即可。</p><p>  方法二：在 Charles 的菜单栏选择 “Proxy”–&gt;“Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082800.png" alt="img"></p><p>  通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。</p><p>  方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082806.png" alt="img"></p><p>  这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。</p><p>  <strong>截取 iPhone 上的网络封包</strong></p><p>  Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。</p><p>  <strong>Charles 上的设置</strong></p><p>  要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”–&gt;“Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示:</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082812.png" alt="img"></p><p>  <strong>iPhone 上的设置</strong></p><p>  首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”–&gt;“Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082818.png" alt="img"></p><p>  在 iPhone 的 “ 设置 ”–&gt;“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082822.png" alt="img"></p><p>  设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082828.png" alt="img"></p><p>  <strong>截取 Https 通讯信息</strong></p><p>  <strong>安装证书</strong></p><p>  如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。</p><p>  首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” –&gt; “SSL Proxying” –&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082833.png" alt="img"></p><p>  需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082839.png" alt="img"></p><p>  这样，对于该 Host 的所有 SSL 请求可以被截取到了。</p><p>  <strong>截取移动设备中的 Https 通讯信息</strong></p><p>  如果我们需要在 <a href="http://lib.csdn.net/base/ios" target="_blank" rel="noopener"><strong>iOS</strong></a> 或 <a href="http://lib.csdn.net/base/android" target="_blank" rel="noopener"><strong>Android</strong></a> 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” –&gt; “SSL Proxying” –&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082845.png" alt="img"></p><p>  按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：<a href="http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的" target="_blank" rel="noopener">http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的</a> Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。</p><p>  <strong>模拟慢速网络</strong></p><p>  在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener"><strong>测试</strong></a>在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。</p><p>  在 Charles 的菜单上，选择 “Proxy”–&gt;“Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082851.png" alt="img"></p><p>  如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。</p><p>  <strong>修改网络请求内容</strong></p><p>  有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082857.png" alt="img"></p><p>  我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082909.png" alt="img"></p><p>  <strong>给服务器做压力测试</strong></p><p>  我们可以使用 Charles 的 Repeat 功能来简单地<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener"><strong>测试</strong></a>服务器的并发处理能力，方法如下。</p><p>  我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082915.png" alt="img"></p><p>  接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082920.png" alt="img"></p><p>  悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener"><strong>数据库</strong></a>打挂了，嗯，请叫我雷锋。</p><p>  <strong>修改服务器返回内容</strong></p><p>  有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。</p><p>  根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：</p><ol><li>Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。</li><li>Rewrite 功能适合对网络请求进行一些正则替换。</li><li>Breakpoints 功能适合做一些临时性的修改。</li></ol><p>  <strong>Map 功能</strong></p><p>  Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。</p><p>  在 Charles 的菜单中，选择 “Tools”–&gt;“Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082925.png" alt="img"></p><p>  对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 ytk1.yuanku.ws（测试服务器）的请求重定向到了 <a href="http://www.yuantiku.com（线上服务器）。" target="_blank" rel="noopener">www.yuantiku.com（线上服务器）。</a></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082930.png" alt="img"></p><p>  对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082936.png" alt="img"></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082951.png" alt="img"></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082956.png" alt="img"></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-083128.png" alt="img"></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-083122.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2009⇆2019：六组数据里的中国十年</title>
      <link href="/zhong-guo-shi-nian.html"/>
      <url>/zhong-guo-shi-nian.html</url>
      
        <content type="html"><![CDATA[<h1 id="2009⇆2019：六组数据里的中国十年"><a href="#2009⇆2019：六组数据里的中国十年" class="headerlink" title="2009⇆2019：六组数据里的中国十年"></a>2009⇆2019：六组数据里的中国十年</h1><p> 来源：微信公众号吴晓波频道</p><p>你的2019年余额仅剩6天</p><p>在即将迈向2020年的这个节点</p><p>我们不妨回顾一下</p><p>过去10年的变化</p><p>当2009年第一缕阳光洒下的时候</p><p>马云还是阿里巴巴CEO</p><p>彼时茅台的股价也才<strong>60元</strong></p><p>手机应用商店里还搜不到支付宝</p><p>10年后的2019年</p><p>马爸爸已投身教育事业</p><p>茅台股价飙涨了<strong>20倍</strong></p><p>支付宝下载量超过<strong>120亿</strong></p><p>当然，在这10年中</p><p>有不少新玩意应运而生</p><p><strong>会员制</strong>成为新兴线上付费模式</p><p><strong>共享单车</strong>解决了“出行最后一公里”难题</p><p>……</p><p>那么</p><p>正值201“X”年结束之际</p><p>不妨看看小巴整理的一些对比图</p><p>感受这10年间的变化</p><p><img src="https://img.iamghf.top/blog/2019-12-26-123550.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123607.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123616.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123628.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123644.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123656.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 十年 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vsftpd高级用法之虚拟用户配置</title>
      <link href="/vsftpd-gao-ji-yong-fa-zhi-xu-ni-yong-hu-pei-zhi.html"/>
      <url>/vsftpd-gao-ji-yong-fa-zhi-xu-ni-yong-hu-pei-zhi.html</url>
      
        <content type="html"><![CDATA[<h1 id="vsftpd高级用法之虚拟用户配置"><a href="#vsftpd高级用法之虚拟用户配置" class="headerlink" title="vsftpd高级用法之虚拟用户配置"></a>vsftpd高级用法之虚拟用户配置</h1><p>需求：需要2个ftp用户访问不同的根目录，其他的访问ftp默认目录。</p><p>2个用户为：test1、test2</p><p>首先安装vsftpd，然后配置文件如下：</p><p>vsftpd.conf：</p><p>anonymous_enable=NO</p><p>local_enable=YES</p><p>write_enable=YES</p><p>local_umask=022</p><p>dirmessage_enable=YES</p><p>xferlog_enable=YES</p><p>connect_from_port_20=YES</p><p>xferlog_std_format=YES</p><p>chroot_local_user=NO</p><p>chroot_list_enable=YES</p><p>chroot_list_file=/etc/vsftpd/chroot_list</p><p>listen=YES</p><p>ftpd_banner=”welcome test Ftp Server.”</p><p>pam_service_name=vsftpd  #设置PAM使用的名称,该名称就是/etc/pam.d/目录下vsfptd文件的文件名</p><p>userlist_enable=YES</p><p>tcp_wrappers=YES</p><p>local_root=/home/www/test/upload/</p><p>virtual_use_local_privs=YES</p><p>guest_enable=YES  #表示是否开启vsftpd虚拟用户的功能，yes表示开启，no表示不开启。</p><p>guest_username=www</p><p>user_config_dir=/etc/vsftpd/vuser_conf #指定每个虚拟用户账号配置目录</p><p>pasv_enable=YES</p><p>pasv_min_port=40000</p><p>pasv_max_port=40080</p><p>pasv_promiscuous=YES</p><p>创建虚拟用户配置目录：</p><p>mkdir /etc/vsftpd/vuser_conf</p><p>创建虚拟用户文件，把这些用户名和密码存放在一个文件中。该文件内容格式是：用户名占用一行，密码占一行。如下：</p><p>[root@localhost vsftpd]# cat /etc/vsftpd/login.txt<br>test1<br>testone<br>test2<br>testtwo</p><p>这个文件的虚拟用户和密码的文本文件无法被系统帐号直接调用，所以我们需要使用db_load命令生成db口令数据库文件，命令如下：</p><p><strong>db_load -T -t hash -f /etc/vsftpd/login.txt /etc/vsftpd/login.db</strong></p><p>为了使服务器能够使用上述生成的数据库文件，对客户端进行身份验证，需要调用系统的PAM模块。PAM(Plugable Authentication Module)为可插拔认证模块，不必重新安装应用系统，通过修改指定的配置文件，调整对该程序的认证方式。PAM模块配置文件路径为/etc/pam.d/目录，此目录下保存着大量与认证有关的配置文件，并以服务名称命名。</p><p>我们现在切换到/etc/pam.d/ 目录下，编辑vsfptd文件。如下图：</p><p>[<img src="https://img.iamghf.top/blog/2019-12-26-113253.jpg" alt=""></p><p>auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/login</p><p>account required /lib64/security/pam_userdb.so db=/etc/vsftpd/login</p><p>auth是指对用户的用户名口令进行验证。</p><p>accout是指对用户的帐户有哪些权限哪些限制进行验证。</p><p>再后面的/lib64/security/pam_userdb.so表示该条审核将调用pam_userdb.so这个库函数进行。</p><p>注意该函数会根据系统的位数而所在位置不同。</p><p>如果是32bit系统，该文件所在位置是/lib/security/pam_userdb.so</p><p>如果是64bit系统，该文件所在位置是/lib64/security/pam_userdb.so</p><p>最后db=/etc/vsftpd/login则指定了验证库函数将到这个指定的数据库中调用数据进行验证。其实该文件指的是/etc/vsftpd/login.db文件。</p><p><strong>注意：**</strong>db=/etc/vsftpd/login<strong>**格式是这样的，去掉.db后缀。</strong></p><p>PAM配置完毕后，我们现在开始创建虚拟用户与系统用户对应的文件。切换到/etc/vsftpd/vuser_conf目录下，并创建test1文件。注意该文件名称一定要与login.txt中的虚拟用户要对应。比如现在login.txt文件有test1用户，那么在 /etc/vsftpd/vuser_conf目录下创建一个文件名为test1的文件。</p><p>[root@localhost vsftpd]# cat /etc/vsftpd/vuser_conf/test1</p><p>local_root=/home/www/test1/upload/  #表示使用本地用户登录到ftp时的默认目录<br>virtual_use_local_privs=YES  #虚拟用户和本地用户有相同的权限<br>guest_username=www  #表示的是设置FTP对应的系统用户为www<br>write_enable=YES<br>anon_umask=022</p><p>以上配置完毕后，启动vsftpd服务完成。</p><p>测试test1、test2 ftp用户均可以正常登录，对应的根目录不同，均有创建和删除、上传权限。</p><p><strong>ftp虚拟用户，故不需要事先创建系统用户。</strong></p><p>关于chroot：</p><p>  \1. chroot_local_user</p><p>  \2. chroot_list_enable</p><p>  \3. chroot_list_file</p><p>可以通过如下两种方法来设置chroot，从而杜绝上述不安全的情况发生：</p><p>（1）设置所有的本地用户执行chroot，只要将/etc/vsftpd/vsftpd.con文件中的chroot_local_ user值置为YES，即       chroot_local_user=YES。</p><p>（2）设置指定的用户执行chroot，按照如下方法进行设置：</p><pre><code>chroot_local_user=NOchroot_list_enable=YESchroot_list_file=/etc/vsftpd.chroot_list</code></pre><p>设置后，只有/etc/vsftpd.chroot_list文件中指定的用户才能够执行chroot命令。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装配置vsftp搭建FTP</title>
      <link href="/centos7-an-zhuang-pei-zhi-vsftp-da-jian-ftp.html"/>
      <url>/centos7-an-zhuang-pei-zhi-vsftp-da-jian-ftp.html</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS7安装配置vsftp搭建FTP"><a href="#CentOS7安装配置vsftp搭建FTP" class="headerlink" title="CentOS7安装配置vsftp搭建FTP"></a>CentOS7安装配置vsftp搭建FTP</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装前查看是否已安装vsftpd</p><pre><code># 查看是否已安装 方法一[root@localhost ~]# rpm -q vsftpdvsftpd-3.0.2-21.el7.x86_64# 查看是否已安装 方法二[root@localhost ~]# vsftpd -vvsftpd: version 3.0.2# 安装 vsftpd[root@localhost ~]# yum -y install vsftpd</code></pre><h2 id="查看位置"><a href="#查看位置" class="headerlink" title="查看位置"></a>查看位置</h2><pre><code>[root@localhost ~]# whereis vsftpdvsftpd: /usr/sbin/vsftpd /etc/vsftpd /usr/share/man/man8/vsftpd.8.gz</code></pre><h2 id="启动vsftpd服务"><a href="#启动vsftpd服务" class="headerlink" title="启动vsftpd服务"></a>启动vsftpd服务</h2><pre><code>systemctl start vsftpd.service</code></pre><h2 id="关闭firewall和SELinux"><a href="#关闭firewall和SELinux" class="headerlink" title="关闭firewall和SELinux"></a>关闭firewall和SELinux</h2><pre><code>setenforce 0   # 设置SELinux 成为permissive模式  （关闭SELinux）setenforce 1   # 设置SELinux 成为enforcing模式   （开启SELinux）# 或者修改配置vi /etc/selinux/config# SELINUX=enforcing# 注释掉# SELINUXTYPE=targeted# 注释掉SELINUX=disabled# 增加:wq! #保存退出setenforce 0</code></pre><p>或者设置SELinux</p><pre><code>getsebool -a | grep ftpsetsebool -P ftpd_full_access onsystemctl stop firewalld.service#停止firewallsystemctl disable firewalld.service#禁止firewall开机启动</code></pre><p>如果你不愿意关闭防火墙，需要防火墙添加FTP服务。</p><pre><code>firewall-cmd --permanent --zone=public --add-service=ftpfirewall-cmd --reload</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>配置文件<code>/etc/vsftpd/vsftpd.conf</code></p><pre><code>anonymous_enable=NO        # 不允许匿名访问，禁用匿名登录chroot_local_user=YES      # 启用限定用户在其主目录下use_localtime=YES          # 使用本地时(自行添加)chroot_list_enable=YESlocal_enable=YES           # 允许使用本地帐户进行FTP用户登录验证allow_writeable_chroot=YES # 如果启用了限定用户在其主目录下需要添加这个配置，解决报错 500 OOPS: vsftpd: refusing to run with writable root inside chroot()xferlog_enable=YES         # 启用上传和下载的日志功能，默认开启。local_umask=022            # 设置本地用户默认文件掩码022# FTP上本地的文件权限，默认是077，不过vsftpd安装后的配置文件里默认是022</code></pre><p>虚拟用户高级参数</p><pre><code>当virtual_use_local_privs=YES 时，虚拟用户和本地用户有相同的权限；当virtual_use_local_privs=NO  时，虚拟用户和匿名用户有相同的权限，默认是NO。当virtual_use_local_privs=YES，write_enable=YES时，虚拟用户具有写权限（上传、下载、删除、重命名）。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=YES，anon_upload_enable=YES时，虚拟用户不能浏览目录，只能上传文件，无其他权限。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=NO，anon_upload_enable=NO时，虚拟用户只能下载文件，无其他权限。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=NO，anon_upload_enable=YES时，虚拟用户只能上传和下载文件，无其他权限。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=NO，anon_mkdir_write_enable=YES时，虚拟用户只能下载文件和创建文件夹，无其他权限。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=NO，anon_other_write_enable=YES时，虚拟用户只能下载、删除和重命名文件，无其他权限。</code></pre><h2 id="匿名登录"><a href="#匿名登录" class="headerlink" title="匿名登录"></a>匿名登录</h2><p>安装完默认情况下是开启匿名登录的，对应的是 <code>/var/ftp</code> 目录，这时只要服务启动了，就可以直接连上FTP了。默认用户名是<code>ftp</code>，密码是空的。如果你在配置里面配置了<code>anonymous_enable=NO</code>，匿名就无法登录。</p><pre><code>$ ftp 192.168.188.114Connected to 192.168.188.114.220 (vsFTPd 3.0.2)Name (192.168.188.114:kennywang): ftp331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls229 Entering Extended Passive Mode (|||47867|).150 Here comes the directory listing.-rw-r--r--    1 0        0              12 Jan 18 06:31 README.mddrwxr-xr-x    2 0        0               6 Nov 05 19:43 pub226 Directory send OK.</code></pre><h2 id="多用户配置"><a href="#多用户配置" class="headerlink" title="多用户配置"></a>多用户配置</h2><p>多用户配置需要自己手工添加配置，下面内容到vsftpd.conf末尾</p><pre><code># # use_localtime=YES          # 使用本地时(自行添加)listen_port=21chroot_local_user=YES      # 启用限定用户在其主目录下idle_session_timeout=300data_connection_timeout=120  # 数据连接超时时间guest_enable=YES             # 设定启用虚拟用户功能guest_username=ftpuser       # 指定虚拟用户的宿主用户 ftpuser（就是我们后面会新建这个用户）# guest_username=www# 如果ftp目录是指向网站根目录，用来上传网站程序，# 可以指定虚拟用户的宿主用户为nginx运行账户www，可以避免很多权限设置问题 user_config_dir=/etc/vsftpd/vuser_conf   # 虚拟用户配置文件目录virtual_use_local_privs=YES # NO时，虚拟用户和匿名用户有相同的权限，默认是NOpasv_min_port=10060         # 被动模式最小端口号10060pasv_max_port=10090         # 被动模式最大端口号10090accept_timeout=5connect_timeout=1</code></pre><h3 id="创建宿主用户"><a href="#创建宿主用户" class="headerlink" title="创建宿主用户"></a>创建宿主用户</h3><p>新建系统用户ftpuser，用户目录为<code>/home/vsftpd</code>, 用户登录终端设为/bin/false(即使之不能登录系统)</p><pre><code># 方法一# 创建用户 ftpuser 指定 `/home/vsftpd` 目录useradd -g root -M -d /home/vsftpd -s /sbin/nologin ftpuser# 设置用户 ftpuser 的密码passwd ftpuser# 把 /home/vsftpd 的所有权给ftpuser.rootchown -R ftpuser.root /home/vsftpd# 方法二useradd ftpuser -d /home/vsftpd -s /bin/falsechown ftpuser:ftpuser /home/vsftpd -R # 如果虚拟用户的宿主用户为www，需要这样设置# www目录是你应用的目录chown www:www /home/www -R</code></pre><p>删除用户 <code>userdel ftpuser</code></p><h3 id="建立虚拟用户文件"><a href="#建立虚拟用户文件" class="headerlink" title="建立虚拟用户文件"></a>建立虚拟用户文件</h3><pre><code>touch /etc/vsftpd/vuser_passwd# 编辑虚拟用户名单文件：（# 第一行账号，第二行密码，注意：不能使用root做用户名，系统保留）vi /etc/vsftpd/vuser_passwd # 编辑内容，下面是 vuser_passwd 内容wcj123456hss123456#保存退出</code></pre><h3 id="生成虚拟用户数据文件"><a href="#生成虚拟用户数据文件" class="headerlink" title="生成虚拟用户数据文件"></a>生成虚拟用户数据文件</h3><pre><code>db_load -T -t hash -f /etc/vsftpd/vuser_passwd /etc/vsftpd/vuser_passwd.dbchmod 600 /etc/vsftpd/vuser_passwd.db</code></pre><h3 id="创建用户配置"><a href="#创建用户配置" class="headerlink" title="创建用户配置"></a>创建用户配置</h3><pre><code>mkdir /etc/vsftpd/vuser_conf  # 建立虚拟用户个人vsftp的配置文件cd /etc/vsftpd/vuser_conf     # 进入目录touch hss wcj                 # 这里创建两个虚拟用户配置文件</code></pre><p>每一个文件配置文件都差不多，只是参数<code>local_root</code>不一样。</p><pre><code>local_root=/home/vsftpd/hss   # 用户 hss 配置目录，这个地方不一样write_enable=YES              # 允许本地用户对FTP服务器文件具有写权限anon_world_readable_only=NOanon_upload_enable=YES        # 允许匿名用户上传文件(须将全局的write_enable=YES,默认YES)anon_mkdir_write_enable=YES   # 允许匿名用户创建目录anon_other_write_enable=YES   # 允许匿名用户删除和重命名权限(自行添加)</code></pre><h3 id="创建用户目录"><a href="#创建用户目录" class="headerlink" title="创建用户目录"></a>创建用户目录</h3><p>每个用户目录文件夹是有root用户创建的，也就是上面<code>local_root</code>配置目录，其权限应设置为755。因为权限的问题在该文件夹内无法直接上传文件。而如果设置为777则无法访问，这是由于vsftpd的安全性设置。解决上传问题的方法是在local_root文件夹内新建一个upload的文件夹，权限设置为777，可将文件上传到该文件夹。</p><pre><code>mkdir -p /home/vsftpd/hss     # 每个用户对于一个目录，创建两个目录“hss”、“wcj”# 下面是目录结构/home/vsftpd      ├── hss      │   ├── filename.md      │   └── upload      └── wcj          └── filename.md# 赋予其权限chmod -R 777 /var/vsftpd/hss/upload/# 在/var/ftp下新建一个目录来实现匿名用户上传mkdir /var/ftp/upload</code></pre><p>vsftpd中几种用户的区分：</p><p><strong>本地用户</strong>：用户在FTP服务器拥有账号，且该账号为本地用户的账号，可以通过自己的账号和口令进行授权登录，登录目录为自己的home目录<code>$HOME</code><br><strong>虚拟用户</strong>：用户在FTP服务器上拥有账号，但该账号只能用于文件传输服务。登录目录为某一特定的目录，通常可以上传和下载<br><strong>匿名用户</strong>：用户在FTP服务器上没有账号，登录目录为/var/ftp</p><h3 id="最后重启vsftpd服务器"><a href="#最后重启vsftpd服务器" class="headerlink" title="最后重启vsftpd服务器"></a>最后重启vsftpd服务器</h3><pre><code>systemctl restart vsftpd.service</code></pre><h2 id="服务运维"><a href="#服务运维" class="headerlink" title="服务运维"></a>服务运维</h2><pre><code>systemctl restart vsftpd.service  # 重启服务systemctl start vsftpd.service    # 启动服务systemctl status vsftpd.service   # 服务状态查看</code></pre><h2 id="FTP命令"><a href="#FTP命令" class="headerlink" title="FTP命令"></a>FTP命令</h2><pre><code>ftp&gt; ascii  # 设定以ASCII方式传送文件(缺省值) ftp&gt; bell   # 每完成一次文件传送,报警提示. ftp&gt; binary # 设定以二进制方式传送文件. ftp&gt; bye    # 终止主机FTP进程,并退出FTP管理方式. ftp&gt; case # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. ftp&gt; cd     # 同UNIX的CD命令. ftp&gt; cdup   # 返回上一级目录. ftp&gt; chmod  # 改变远端主机的文件权限. ftp&gt; close  # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. ftp&gt; delete # 删除远端主机中的文件. ftp&gt; dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. ftp&gt; get [remote-file] [local-file] # 从远端主机中传送至本地主机中. ftp&gt; help [command] # 输出命令的解释. ftp&gt; lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. ftp&gt; ls [remote-directory] [local-file] # 同DIR. ftp&gt; macdef                 # 定义宏命令. ftp&gt; mdelete [remote-files] # 删除一批文件. ftp&gt; mget [remote-files]    # 从远端主机接收一批文件至本地主机. ftp&gt; mkdir directory-name   # 在远端主机中建立目录. ftp&gt; mput local-files # 将本地主机中一批文件传送至远端主机. ftp&gt; open host [port] # 重新建立一个新的连接. ftp&gt; prompt           # 交互提示模式. ftp&gt; put local-file [remote-file] # 将本地一个文件传送至远端主机中. ftp&gt; pwd  # 列出当前远端主机目录. ftp&gt; quit # 同BYE. ftp&gt; recv remote-file [local-file] # 同GET. ftp&gt; rename [from] [to]     # 改变远端主机中的文件名. ftp&gt; rmdir directory-name   # 删除远端主机中的目录. ftp&gt; send local-file [remote-file] # 同PUT. ftp&gt; status   # 显示当前FTP的状态. ftp&gt; system   # 显示远端主机系统类型. ftp&gt; user user-name [password] [account] # 重新以别的用户名登录远端主机. ftp&gt; ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。ftp&gt; ! # 从 ftp 子系统退出到外壳。 </code></pre><h3 id="关闭FTP连接"><a href="#关闭FTP连接" class="headerlink" title="关闭FTP连接"></a>关闭FTP连接</h3><pre><code>byeexitquit</code></pre><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><pre><code>ftp&gt; get readme.txt # 下载 readme.txt 文件ftp&gt; mget *.txt     # 下载 </code></pre><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><pre><code>ftp&gt; put /path/readme.txt # 上传 readme.txt 文件ftp&gt; mput *.txt           # 可以上传多个文件</code></pre><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul><li>230 - 登录成功</li><li>200 - 命令执行成功</li><li>150 - 文件状态正常，开启数据连接端口</li><li>250 - 目录切换操作完成</li><li>226 - 关闭数据连接端口，请求的文件操作成功</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://hx100.blog.51cto.com/44326/383143/" target="_blank" rel="noopener">Vsftpd虚拟用户的配置</a></li><li><a href="http://www.cnblogs.com/flandre/p/6051532.html" target="_blank" rel="noopener">CentOS7安装和配置FTP</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三十而立</title>
      <link href="/san-shi-er-li.html"/>
      <url>/san-shi-er-li.html</url>
      
        <content type="html"><![CDATA[<h1 id="三十而立"><a href="#三十而立" class="headerlink" title="三十而立"></a>三十而立</h1><p><img src="https://img.iamghf.top/91ef76c6a7efce1b6e9970cda251f3deb48f6503.jpg" alt=""></p><p>《论语·为政》中说：“三十而立。”指年至三十，学有成就。我从小读了很多书，但都是一些乱七八糟的书。后来上错了大学，耽误了学业，学术上没什么成绩，大部时间都用来思考宇宙和人生了。<br>三十岁对于一个男人来说是一个矛盾的年龄。三十岁的男人，才真正开始走向成熟、拥有担当能力的开端。<br>三十岁是人生的分界线。我出身平凡，努力改变命运，前二十年走过很多坑；三十岁的男人，应当有立锥之地。<br>三十多岁的男人，就象早秋午后太阳，即便过了正午时分，也不应有太多的倦意。<br>女人十八岁便开始成熟，而男人要到二十八岁才知道自己是怎么回事。<br>生命如此短暂，二十岁的男人还没有来得及享受生活，就要开始面对生活、社会、家庭和责任。<br>突然感觉有写点什么的必要，一来算是对青年时期的感悟总结；二来算是和年轻读者的谈心。<br>人生要远离“官场”。官场一个有原则无底线的是非场。年轻的时候总有人削尖脑袋想当官，成为“干部”。这些年接触了各种各样的“干部”，碰到了很多志大才疏，德不配位之人，让我对“官场”认识更加深刻。这是一个把君子变成小人的场所。我以后也会有儿子、孙子，我要告诉他们，一定不要有为了做官而做官的想法；要学会隐居，努力去做学问。对于张口“级别”、“待遇”、“工资”的这些人，要学会远离他们，最好拉黑。这些人无时无刻不在想着不劳而获，你跟他们混在一起，只会吃亏。<br>人生要远离“身份感”。年轻人最不该碰的东西，就是身份感和优越感。优越感，来自比较。内敛而不失度的优越，俗称自信。狂放而失礼的优越，俗称傲慢。天主教认定的遭永劫的七宗罪：傲慢，暴怒，懒惰，贪婪，嫉妒，饕餮，淫欲。排在首位的赫然便是傲慢，可见傲慢的杀伤力。当然，优越感源自优越，这点无可否认。但沉浸在优越中不可自拔，养成傲慢的脾气秉性，将导致固步自封、不思进取，既不被人待见，又坐吃山空。深到骨子里的高贵，是没有身份感。<br>人生始终要重视教育，要学会主动选择教育。当一个人出身贫困，没有平台和背景，教育是最好的投资。好的教育能唤醒人的意识，促进美德和智力的发展，差的教育喜欢“塑造”，强迫人去便成别人想要看到的样子。越是质量低劣的教育越喜欢“洗脑”。很多人无法意识到自己接受了什么样的教育，原因在于他们缺乏教育标准是非观，最终只能随波逐流。<br>人生要学会思考，认准自己的定位，远离口号。中国人二十岁之前都在考试，很少会去思考“我是谁？我为什么在这里”之类的问题。人类的痛苦往往来自于对自身认识不清的缘故。理想和现实产生了冲突，从而精神分类。因此，认准自己在社会中的位置非常重要，不要被口号欺骗和蒙蔽。<br>阅读是最好的教育。多阅读经典，多阅读原著。同样一本书，不同的人会有不同的感受，一定要先阅读原著，形成自己的认识，然后再去和别人交流，这样才能产生思想的碰撞，切不可人云亦云，失去自我。<br>清醒时做事，糊涂时读书。时时刻刻都要读书学习，你的知识面有多广，心怀有多宽，世界的舞台就有多大。<br>人生要有敬畏之心。曾经我也是那么叛逆，目无尊长、不拘约束，很多和我对抗过的故人至今还宣扬：你是降服不了他的。我们要对生命和规则充满敬畏之心，学会善良和尊重。<br>学会沉默，不要卖惨。不要报怨出身，不要埋怨现状。总有人家庭背景比你好，总有人生活条件比你差。人生来是为改变命运而努力的，一切的不如意都是为了让我们拼搏奋斗。<br>要懂得诚实，不要自欺欺人。很多时候，我们走错了路，做错了选择，都是因为自己骗自己。那个东西明明不好，却非要说服自己认为它是好的。所有错误的选择，大体如此。<br>要克制贪欲。我们本来就是赤条条来到世间的，一切都是身外之物，对物质的过分追求会失去自我。<br>要学会慎独。在很多孤独、自我相处的时间里，放松不放纵，做让自己欣赏的自己。总有一天你会明白，孤独才是人生的常态。<br>要有规则意识，不要道德绑架。文明社会是讲规则的社会，言谈举止一定要尊重社会规则。道德是规则的升华，自古以来道德是强调约束自己的，而今天很多人却用道德去要求别人，这就是道德绑架。<br>要认清君子和小人。看清一个人的嘴脸，看他对领导的态度；看清一个人的品性，看他如何对待弱者；看清一人的将来，看他在在读什么样的书。<br>不要滥交朋友。人生得一知已足亦，很多人注定是我们生命中的过客，不要太热情，不要太冷漠，平平淡淡的交往就好。<br>人生要有一个正直的朋友。有个正直的朋友是痛苦的，他总会盯着你的缺点；有了正直的朋友是幸福的，你的人生不会犯大错。<br>要远离疯狗杠精。流言蜚语总会围绕在我们周围，甚至威胁我们的名誉。不要企图和疯狗争论是非。如果辱骂能够胜利，泼妇将统治世界，流言总会消失，清白总是沉淀而出。总有人喜欢你，总有人不喜欢你，你只需要在乎喜欢你的人便可。<br>要远离脑残智障。太监脱掉裤子才知道不是正常人，脑残一张嘴就知道不是正常人。太监因残疾而自卑，脑残因无知而狂妄。一个人获得信息来源的途径决定认识水平，接受单一教育的人看问题容易偏激。批判是创新的前提，要远离那些满嘴赞美权力、习惯歌功颂德之流，奴颜婢膝之徒是不配做我们的朋友的。<br>不要轻视人性之恶。人是一种喜欢在欺负弱小中得到快感的动物，敢于挑战强者的只是极少数，孤傲而高贵。人在利益和原则之间是很容易犯错的，要时时提防可能来临的伤害，保全自我是人生的必修课。<br>与贵族为友，与流氓共事。项羽是贵族，刘邦是流氓，贵族斗不过流氓。做人与做事是人生两门功课，外圆内方，把贵族当作朋友，把流氓当作同事。<br>要学会和异性正常交往。异性地球上唯一的另类智能生物。和异性交往，充满了人类智慧当中最高的技巧和情商。不要去做女性的舔狗，喜欢被男性跪舔的女性是不值得交往的。<br>要多思考家庭、婚姻和两性关系。人生可以没有婚姻，但是要有一段付出真心的爱情；人生可以没有伴侣，一定要有一个红颜知已，彼此都记在心间，可以相互付出所有。<br>要学会在市场中赚钱养活自己。作为一个男人，没有赚钱的能力，是万万不行的。人口越来越老化，平均每个中国男人的身上，都有七八口人要养活。如果你不幸是体制内人员，只能靠工资活着，家里又没有背景和财富，那还是请多考虑“赚钱”的问题。<br>学会孝敬父母。父母是我们的心灵归宿，父母在，我们永远是孩子，受了委屈或得到荣耀，可以回家，总感觉生死离我们很远；父母不在了，我们开始直接面对生死。<br>要同情弱势群体，不要轻易可怜他人。社会公平总有顾及不到的地方，弱势群体更需要同情和关爱，要有区别的对待个体可怜之人，可怜之人必有可恨之处，理智不能被同情控制。<br>要永远相信公平正义。无论位居多高，掌握多少财富，都要和普通百姓站在一起，不要为权势们锦上添花，要为天下百姓说话，只要和百姓在一起，人生就不会偏离方向。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库表连接</title>
      <link href="/shu-ju-ku-biao-lian-jie.html"/>
      <url>/shu-ju-ku-biao-lian-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库表连接"><a href="#数据库表连接" class="headerlink" title="数据库表连接"></a>数据库表连接</h1><p>关系型数据库最难的地方，就是建模（model）。</p><p>错综复杂的数据，需要建立模型，才能储存在数据库。所谓”模型”就是两样东西：实体（entity）+ 关系（relationship）。</p><p>实体指的是那些实际的对象，带有自己的属性，可以理解成一组相关属性的容器。关系就是实体之间的联系，通常可以分成”一对一”、”一对多”和”多对多”等类型。</p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo3-1552277828.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p>在关系型数据库里面，每个实体有自己的一张表（table），所有属性都是这张表的字段（field），表与表之间根据关联字段”连接”（join）在一起。所以，表的连接是关系型数据库的核心问题。</p><p>表的连接分成好几种类型。</p><blockquote><ul><li>内连接（inner join）</li><li>外连接（outer join）</li><li>左连接（left join）</li><li>右连接（right join）</li><li>全连接（full join）</li></ul></blockquote><p>以前，很多文章采用维恩图（两个圆的集合运算），解释不同连接的差异。</p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo2-1552277828.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo2-1552277828-1.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo0-1552277828.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo1-1552277829.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p>上周，我读到一篇文章，认为还有比维恩图更好的解释方式。我发现确实如此，换一个角度解释，更容易懂。</p><p>所谓”连接”，就是两张表根据关联字段，组合成一个数据集。问题是，两张表的关联字段的值往往是不一致的，如果关联字段不匹配，怎么处理？比如，表 A 包含张三和李四，表 B 包含李四和王五，匹配的只有李四这一条记录。</p><p>很容易看出，一共有四种处理方法。</p><blockquote><ul><li>只返回两张表匹配的记录，这叫内连接（inner join）。</li><li>返回匹配的记录，以及表 A 多余的记录，这叫左连接（left join）。</li><li>返回匹配的记录，以及表 B 多余的记录，这叫右连接（right join）。</li><li>返回匹配的记录，以及表 A 和表 B 各自的多余记录，这叫全连接（full join）。</li></ul></blockquote><p>下图就是四种连接的图示。我觉得，这张图比维恩图更易懂，也更准确。</p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo1-1552277829.jpeg" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p>上图中，表 A 的记录是 123，表 B 的记录是 ABC，颜色表示匹配关系。返回结果中，如果另一张表没有匹配的记录，则用 null 填充。</p><p>这四种连接，又可以分成两大类：内连接（inner join）表示只包含匹配的记录，外连接（outer join）表示还包含不匹配的记录。所以，左连接、右连接、全连接都属于外连接。</p><p>这四种连接的 SQL 语句如下。</p><pre><code>SELECT * FROM A  INNER JOIN B ON A.book_id=B.book_id;</code></pre><p>SELECT * FROM A<br>LEFT JOIN B ON A.book_id=B.book_id;</p><pre><code></code></pre><p>SELECT * FROM A<br>RIGHT JOIN B ON A.book_id=B.book_id;</p><pre><code></code></pre><p>SELECT * FROM A<br>FULL JOIN B ON A.book_id=B.book_id;</p><pre><code></code></pre><p>上面的 SQL 语句还可以加上where条件从句，对记录进行筛选，比如只返回表 A 里面不匹配表 B 的记录。</p><pre><code>SELECT * FROM ALEFT JOIN BON A.book_id=B.book_idWHERE B.id IS null;</code></pre><p>另一个例子，返回表 A 或表 B 所有不匹配的记录。</p><pre><code>SELECT * FROM AFULL JOIN BON A.book_id=B.book_idWHERE A.id IS null OR B.id IS null;</code></pre><p>此外，还存在一种特殊的连接，叫做”交叉连接”（cross join），指的是表 A 和表 B 不存在关联字段，这时表 A（共有 n 条记录）与表 B （共有 m 条记录）连接后，会产生一张包含 n x m 条记录的新表（见下图）。</p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo10-1552277829.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大基础实用算法</title>
      <link href="/shi-da-ji-chu-shi-yong-suan-fa.html"/>
      <url>/shi-da-ji-chu-shi-yong-suan-fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="十大基础实用算法"><a href="#十大基础实用算法" class="headerlink" title="十大基础实用算法"></a>十大基础实用算法</h1><p><strong>算法一：快速排序算法</strong></p><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(nlogn) 次比较。在最坏状况下则需要Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(nlogn) 算法更快，因为它的内部循环（innerloop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divideandconquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p><strong>算法步骤：</strong></p><p>\1. 从数列中挑出一个元素，称为「基准」（pivot），</p><p>\2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p><p>\3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><strong>算法二：堆排序算法</strong></p><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>堆排序的平均时间复杂度为Ο(nlogn)。</p><p><strong>算法步骤：</strong></p><p>\1. 创建一个堆 H[0..n-1]</p><p>\2. 把堆首（最大值）和堆尾互换</p><p>\3. 把堆的尺寸缩小 1，并调用 shift_down(0), 目的是把新的数组顶端数据调整到相应位置</p><p>\4. 重复步骤 2，直到堆的尺寸为 1</p><p><strong>算法三：归并排序</strong></p><p>归并排序（Mergesort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（DivideandConquer）的一个非常典型的应用。</p><p><strong>算法步骤：</strong></p><p>\1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p><p>\2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置</p><p>\3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p><p>\4. 重复步骤 3 直到某一指针达到序列尾</p><p>\5. 将另一序列剩下的所有元素直接复制到合并序列尾</p><p><strong>算法四：二分查找算法</strong></p><p>二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn)。</p><p><strong>算法五：BFPRT（线性查找算法）</strong></p><p>BFPRT 算法解决的问题十分经典，即从某 n 个元素的序列中选出第 k 大（第 k 小）的元素，通过巧妙的分析，BFPRT 可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到 o(n) 的时间复杂度，五位算法作者做了精妙的处理。</p><p><strong>算法步骤：</strong></p><p>\1. 将 n 个元素每 5 个一组，分成 n/5(上界) 组。</p><p>\2. 取出每一组的中位数，任意排序方法，比如插入排序。</p><p>\3. 递归的调用 selection 算法查找上一步中所有中位数的中位数，设为 x，偶数个中位数的情况下设定为选取中间小的一个。</p><p>\4. 用 x 来分割数组，设小于等于 x 的个数为 k，大于 x 的个数即为 n-k。</p><p>\5. 若 i==k，返回 x；若 i&lt;k，在小于 x 的元素中递归查找第 i 小的元素；若 i&gt;k，在大于 x 的元素中递归查找第 i-k 小的元素。</p><p>终止条件：n=1 时，返回的即是 i 小元素。</p><p><strong>算法六：DFS（深度优先搜索）</strong></p><p>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所有边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS 属于盲目搜索。</p><p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现 DFS 算法。</p><p><strong>深度优先遍历图算法步骤：</strong></p><p>\1. 访问顶点 v；</p><p>\2. 依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问；</p><p>\3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</p><p>上述描述可能比较抽象，举个实例：</p><p>DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1 邻接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，…如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。</p><p>接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</p><p><strong>算法七：BFS（广度优先搜索）</strong></p><p>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树 (图) 的宽度遍历树 (图) 的节点。如果所有节点均被访问，则算法中止。BFS 同样属于盲目搜索。一般用队列数据结构来辅助实现 BFS 算法。</p><p><strong>算法步骤：</strong></p><p>\1. 首先将根节点放入队列中。</p><p>\2. 从队列中取出第一个节点，并检验它是否为目标。</p><p>如果找到目标，则结束搜寻并回传结果。</p><p>否则将它所有尚未检验过的直接子节点加入队列中。</p><p>\3. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传「找不到目标」。</p><p>\4. 重复步骤 2。</p><p><strong>算法八：Dijkstra算法</strong></p><p>戴克斯特拉算法（Dijkstra』salgorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p><p>该算法的输入包含了一个有权重的有向图 G，以及 G 中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u,v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示 G 中所有边的集合，而边的权重则由权重函数 w:E→[0,∞] 定义。因此，w(u,v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t 的最低权重路径 (例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra 算法是目前已知的最快的单源最短路径算法。</p><p><strong>算法步骤：</strong></p><p>\1. 初始时令 S={V0},T={其余顶点}，T 中顶点对应的距离值</p><p>若存在，d(V0,Vi) 为弧上的权值</p><p>若不存在，d(V0,Vi) 为∞</p><p>\2. 从 T 中选取一个其距离值为最小的顶点 W 且不在 S 中，加入 S</p><p>\3. 对其余 T 中顶点的距离值进行修改：若加进 W 作中间顶点，从 V0 到 Vi 的距离值缩短，则修改此距离值</p><p>重复上述步骤 2、3，直到 S 中包含所有顶点，即 W=Vi 为止</p><p><strong>算法九：动态规划算法</strong></p><p>动态规划（Dynamicprogramming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><p>关于动态规划最经典的问题当属背包问题。</p><p><strong>算法步骤：</strong></p><p>\1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p><p>\2. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p><p><strong>算法十：朴素贝叶斯分类算法</strong></p><p>朴素贝叶斯分类算法是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下，如何完成推理和决策任务。概率推理是与确定性推理相对应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其他特征都不相关。</p><p>朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获取得非常好的分类效果。在许多实际应用中，朴素贝叶斯模型参数估计使用最大似然估计方法，换言之朴素贝叶斯模型能工作并没有用到贝叶斯概率或者任何贝叶斯模型。</p><p>尽管是带着这些朴素思想和过于简单化的假设，但朴素贝叶斯分类器在很多复杂的现实情形中仍能够取得相当好的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生苦短，我用PyCharm</title>
      <link href="/ren-sheng-ku-duan-wo-yong-pycharm.html"/>
      <url>/ren-sheng-ku-duan-wo-yong-pycharm.html</url>
      
        <content type="html"><![CDATA[<h1 id="人生苦短，我用PyCharm"><a href="#人生苦短，我用PyCharm" class="headerlink" title="人生苦短，我用PyCharm"></a>人生苦短，我用PyCharm</h1><p>导读：PyCharm 是一种 Python IDE，可以帮助程序员节约时间，提高生产效率。那么具体如何使用呢？本文从 PyCharm 安装到插件、外部工具、专业版功能等进行了一一介绍，希望能够帮助到大家。</p><p>在本文中，我们并不会提供非常完善的指南，但是会介绍 PyCharm 最主要的一些能力，了解这些后，后面就需要我们在实践中再具体学习了。</p><p>JetBrains 开发的 PyCharm 差不多是 Python 最常用的 IDE。PyCharm 可以为我们节省大量时间，它能够管理代码，并完成大量其他任务，如 debug 和可视化等。</p><p>本文将介绍：</p><ul><li>PyCharm 安装</li><li>在 PyCharm 中写代码</li><li>在 PyCharm 中运行代码</li><li>在 PyCharm 中进行代码 debug 和测试</li><li>在 PyCharm 中编辑已有项目</li><li>在 PyCharm 中搜索和导航</li><li>在 PyCharm 中使用版本控制</li><li>在 PyCharm 中使用插件和外部工具</li><li>使用 PyCharm Professional 功能，如 Django 支持和科学模式</li></ul><p>本文假设读者熟悉 Python 开发，且计算机中已安装某个版本的 Python。该教程将使用 Python 3.6 版本，屏幕截图和 demo 均来自 macOS 系统。由于 PyCharm 可在所有主流平台上运行，读者在其他系统中会看到略微不同的 UI 元素，可能需要调整某些命令。</p><h3 id="01、PyCharm-安装"><a href="#01、PyCharm-安装" class="headerlink" title="01、PyCharm 安装"></a>01、PyCharm 安装</h3><p>本文将使用 PyCharm Community Edition 2019.1 版本，该版本免费且可在所有主流平台上使用。只有最后一部分「PyCharm Professional 功能」使用的是 PyCharm Professional Edition 2019.1 版本。</p><p>推荐使用 JetBrains Toolbox App 安装 PyCharm。使用该 App，你可以安装不同的 JetBrains 产品或者同一产品的不同版本，并在必要的情况下更新、回滚和轻松删除任意工具。你还可以在恰当的 IDE 及版本中快速打开任意项目。</p><p>Toolbox App 安装指南，参见 JetBrains 官方文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/installation-guide.html#toolbox" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/installation-guide.html#toolbox</a></p><p>该 App 会根据你的操作系统提供合适的安装说明。如果它无法准确识别系统，你可以在右上角的下拉列表中找到合适的系统。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092628.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>安装成功后，启动该 app 并接受用户协议。在 Tools 选项下，你可以看到一个可用产品列表。从中找到 PyCharm Community，并点击 Install。</p><p>好啦，现在你的机器上已经安装 PyCharm 了。如果不想使用 Toolbox app，你可以单独安装 PyCharm。</p><p>启动 PyCharm，你将看到导入设置弹窗。PyCharm 会自动检测出这是首次安装，并为你选择「Do not import settings」选项。点击 OK，之后 PyCharm 会让你选择键盘映射（keymap scheme）。保留默认设置，点击右下角的「Next: UI Themes」：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092637.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>PyCharm 将询问选择深色模式 Darcula 还是浅色模式。你可以选择自己喜欢的模式，并点击「Next: Launcher Script」：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092643.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>本教程将使用深色模式 Darcula。</p><p>在下一个页面上，直接保留默认设置，并点击「Next: Featured plugins」，这时 PyCharm 将展示可用插件列表。点击「Start using PyCharm」，现在你可以写代码了！</p><h3 id="02、在-PyCharm-中写代码"><a href="#02、在-PyCharm-中写代码" class="headerlink" title="02、在 PyCharm 中写代码"></a>02、在 PyCharm 中写代码</h3><p>在 PyCharm 中，你可以在「项目」中执行任意操作。因此，首先你需要创建一个项目。</p><p>安装和打开 PyCharm 后，你会看到欢迎页面。点击「Create New Project」，出现「New Project」弹窗：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092649.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>指定项目位置，打开 Project Interpreter 列表，选择创建新的项目解释器或者使用已有的解释器。选择「New environment using」，打开其右方的下拉列表，选择 Virtualenv、Pipenv 或 Conda。这些工具可以为不同项目单独创建 Python 环境，从而分别保存不同项目所需的依赖项。</p><p>你可以选择其中任意一个，本教程使用的是 Virtualenv。选择后，指定环境位置，从 Python 解释器列表中选择要安装在系统中的 base interpreter。通常，保持默认设置即可。下面有两个可选框：在新环境中继承全局包环境、令当前环境可以用其它所有项目，两个都不要选。</p><p>点击右下角的「Create」，创建新项目：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092655.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>屏幕上出现「Tip of the Day」弹窗，在每次启动时 PyCharm 通过该弹窗提供 trick。关掉该弹窗。</p><p>现在我们可以开始新的 Python 程序了。如果你使用的是 Mac 系统，使用 Cmd+N 键；如果你使用的是 Windows 或 Linux 系统，使用 Alt+Ins 键。然后选择 Python File。你也可以在菜单中选择 File → New。将新文件命名为 guess_game.py 并点击 OK。你将看到如下 PyCharm 窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092701.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>至于测试代码，我们来快速写一个简单的猜谜游戏，即程序选择一个数字让用户来猜，在每一次猜测时，程序将告诉用户他猜的数字比神秘数字大还是小，用户猜中数字时游戏结束。以下是该游戏的代码：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092707.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>直接键入上述代码，而不是复制粘贴。你会看到如下画面：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092714.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>如上图所示，PyCharm 提供 Intelligent Coding Assistance 功能，可以执行代码补全、代码检查、错误高亮显示和快速修复建议。比如键入 main 并点击 tab 键，PyCharm 会自动补全整个 main 从句。</p><p>此外，如果你在条件句前忘记键入 if，在该句子最后增添.if 并点击 Tab 键，PyCharm 将修复该 if 条件句。该用法同样适用于 True.while。这即是 PyCharm 的 Postfix Completion 功能，它可以帮助用户减少退格键使用次数。</p><h3 id="03、在-PyCharm-中运行代码"><a href="#03、在-PyCharm-中运行代码" class="headerlink" title="03、在 PyCharm 中运行代码"></a>03、在 PyCharm 中运行代码</h3><p>现在你已经编码完成该游戏，可以运行了。</p><p>该游戏程序有三种运行方式：</p><ol><li>在 Mac 系统中使用快捷键 Ctrl+Shift+R，在 Windows 或 Linux 系统中，使用快捷键 Ctrl+Shift+F10。</li><li>右键单击背景，从菜单中选择「Run 『guess_game』」。</li><li>由于该程序具备<strong>main</strong> 从句，你可以点击<strong>main</strong> 从句左侧的绿色小箭头，选择「Run 『guess_game』」。</li></ol><p>使用以上任一方式运行该程序，窗口底部会出现终端面板（Terminal pane），显示你的代码输出结果：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092720.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>你可以玩一下这个游戏，看看自己能否猜中数字。（专业建议：从 50 开始猜。）</p><h3 id="04、在-PyCharm-中进行代码-debug"><a href="#04、在-PyCharm-中进行代码-debug" class="headerlink" title="04、在 PyCharm 中进行代码 debug"></a>04、在 PyCharm 中进行代码 debug</h3><p>找到神秘数字了吗？如果找到了，你可能会看到一些奇怪的东西：程序没有打印出祝贺信息和显示退出按钮，而是重新开始了。这就是 bug 所在。要想发现程序重新开始的原因，你需要 debug。</p><p>首先，点击第 8 行代码左侧的空白区域，设置断点：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092725.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>断点即程序运行到这一行时会自动停止，你可以探索断点处之后的代码有什么错误。接下来，从以下三种方式中选择一种开始 debug：</p><ol><li>在 Mac 系统中使用 Ctrl+Shift+D 键，在 Windows 或 Linux 系统中使用 Shift+Alt+F9 键。</li><li>右键单击背景，选择「Debug 『guess_game』」。</li><li>点击<strong>main</strong>从句左侧的绿色小箭头，选择「Debug 『guess_game』」。</li></ol><p>之后，你将看到底部出现 Debug 窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092732.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>按照下列步骤执行程序 debug：</p><ol><li>注意当前行被蓝色高亮显示。</li><li>Debug 窗口显示 random_int 及其值。记录该数字。（上图中该数字为 85。）</li><li>点击 F8 执行当前代码行，并执行到下一行代码。如有必要，你也可以使用 F7 跳转到当前行内的函数。随着你继续执行语句，变量的变化将自动呈现在 Debugger 窗口。</li><li>注意 Debugger 标签右侧有一个 Console 标签。Console 标签和 Debugger 标签相互独立。你可以在 Console 中与程序进行交互，在 Debugger 中执行 debug 动作。</li><li>转向 Console 标签，进入猜测过程。</li><li>键入左侧 Debugger 标签中显示的数字，点击 Enter 键。</li><li>转回 Debugger 标签。</li><li>再次点击 F8，计算 if 语句。注意现在你在第 14 行。为什么不是第 11 行呢？因为第 10 行的 if 语句被计算为 False。那么为什么当你键入数字后它算出来为 False 了呢？</li><li>仔细看第 10 行，注意我们在对比 user_guess 和一个错误的项。我们应该对比用户猜测的数字和 random_int，但此处我们对比的是 randint（从 random 包导入的函数）。</li><li>将 randint 更改为 random_int，按照同样的步骤重新开始 debug。你会发现，这一次到达的是第 11 行，第 10 行算出来为 True：</li></ol><p><img src="https://img.iamghf.top/blog/2019-12-26-092737.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>恭喜你，bug 被修复了！</p><h3 id="05、在-PyCharm-中进行代码测试"><a href="#05、在-PyCharm-中进行代码测试" class="headerlink" title="05、在 PyCharm 中进行代码测试"></a>05、在 PyCharm 中进行代码测试</h3><p>不经单元测试的应用都不可靠。PyCharm 可以帮助你快速舒适地写单元测试并运行。默认情况下，unittest 被用作测试运行器，而 PyCharm 还支持其他测试框架，如 pytest、nose、doctest、tox 和 trial。例如，你可以按照以下步骤为项目选择 pytest 测试运行器：</p><ol><li>打开 Settings/Preferences → Tools → Python Integrated Tools 设置对话框。</li><li>在默认测试运行器字段中选择 pytest。</li><li>点击 OK 保存该设置。</li></ol><p>本教程的示例将使用默认测试运行器 unittest。</p><p>在同一个项目中，创建文件 calculator.py，并将以下 Calculator 类放入该文件：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092743.png" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>PyCharm 使得为已有代码创建测试变得轻而易举。打开 calculator.py 文件，执行以下步骤中的任意一个：</p><ul><li>在 Mac 系统中使用 Shift+Cmd+T 键，在 Windows 或 Linux 系统中使用 Ctrl+Shift+T。</li><li>右键单击该类的背景，选择「Go To and Test」。</li><li>在主菜单中吗，选择 Navigate → Test。</li></ul><p>选择「Create New Test…」，得到以下窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092748.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>Target directory、Test file name 和 Test class name 这三项均保留默认设置。选中上图中两种需要测试的方法并点击 OK。好了！PyCharm 自动创建文件 test_calculator.py，并在其中创建了以下 stub test：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092753.png" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>使用以下方法中的任意一个运行测试：</p><ul><li>在 Mac 系统中使用 Ctrl+R 键，在 Windows 或 Linux 系统中使用 Shift+F10 键。</li><li>右键单击背景，选择「Run 『Unittests for test_calculator.py』」。</li><li>点击测试类名称左侧的绿色小箭头，选择「Run 『Unittests for test_calculator.py』」。</li></ul><p>你将看到底部出现测试窗口，所有测试均失败：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092801.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>注意，左侧是测试结果的层次结构，右侧是终端的输出。现在，将代码更改成以下代码，实现 test_add：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092806.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>重新运行测试，你会看到一个测试通过了，另一个则失败。按照如下操作探索不同选项，来展示已通过测试和被忽略测试，按照字母顺序对测试进行排序，以及按照时长对测试进行排序：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092811.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>注意，上图中的 sleep(0.1) 方法的作用是使其中一个测试变慢，以便按时长对测试进行排序。</p><h3 id="06、在-PyCharm-中编辑已有项目"><a href="#06、在-PyCharm-中编辑已有项目" class="headerlink" title="06、在 PyCharm 中编辑已有项目"></a>06、在 PyCharm 中编辑已有项目</h3><p>单文件项目非常适合作为示例，但你通常需要处理较大的项目。这部分将介绍如何使用 PyCharm 处理较大项目。</p><p>为了探索 PyCharm 以项目为中心的特征，你将使用 Alcazar web 框架（该框架用于学习目的）。在本地复制该 repo。</p><p>地址：</p><p><a href="https://realpython.com/optins/view/alcazar-web-framework/" target="_blank" rel="noopener">https://realpython.com/optins/view/alcazar-web-framework/</a></p><p>当你在本地已有项目时，使用以下方法中的任意一个在 PyCharm 中打开项目：</p><ul><li>在主菜单中点击 File → Open。</li><li>在欢迎页面点击 Open。</li></ul><p>之后，在计算机中找到包含该项目的文件夹，并打开。</p><p>如果该项目包含虚拟环境，PyCharm 将自动使用该虚拟环境，并将它作为项目解释器。</p><p>如果你需要配置不同的虚拟环境 virtualenv，在 Mac 上打开 Preferences，或在 Windows 或 Linux 系统中使用 Ctrl+Alt+S 打开 Settings，找到 Project: ProjectName。打开下拉列表，选择 Project Interpreter：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092818.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>从下拉列表中选择 virtualenv。如果没有要选择的项，则点击下拉列表右方的设置按钮选择 Add…其余步骤和创建新项目的步骤相同。</p><h3 id="07、在-PyCharm-中搜索和导航"><a href="#07、在-PyCharm-中搜索和导航" class="headerlink" title="07、在 PyCharm 中搜索和导航"></a>07、在 PyCharm 中搜索和导航</h3><p>在大项目中，我们很难记住每个事物的位置，因此快速导航和搜索非常重要。PyCharm 可以提供这些功能。接下来，我们使用上一节中打开的项目，实践以下快捷键：</p><ul><li>在当前文件中搜索代码段：在 Mac 系统中使用 Cmd+F 键，在 Windows 或 Linux 系统中使用 Ctrl+F 键。</li><li>在整个项目中搜索代码段：在 Mac 系统中使用 Cmd+Shift+F 键，在 Windows 或 Linux 系统中使用 Ctrl+Shift+F 键。</li><li>搜索类：在 Mac 系统中使用 Cmd+O 键，在 Windows 或 Linux 系统中使用 Ctrl+N 键。</li><li>搜索文件：在 Mac 系统中使用 Cmd+Shift+O 键，在 Windows 或 Linux 系统中使用 Ctrl+Shift+N 键。</li><li>如果你不知道要搜索的是文件、类还是代码段，则搜索全部：按两次 Shift 键。</li></ul><p>导航可使用以下快捷键：</p><ul><li>前往变量的声明：在 Mac 系统中使用 Cmd 键，在 Windows 或 Linux 系统中使用 Ctrl 键，然后单击变量。</li><li>寻找类、方法或文件的用法：使用 Alt+F7 键。</li><li>查看近期更改：使用 Shift+Alt+C 键，或者在主菜单中点击 View → Recent Changes。</li><li>查看近期文件：在 Mac 系统中使用 Cmd+E 键，在 Windows 或 Linux 系统中使用 Ctrl+E 键，或者在主菜单中点击 View → Recent Files。</li><li>多次跳转后在导航历史中前进和后退：在 Mac 系统中使用 Cmd+[ / Cmd+] 键，在 Windows 或 Linux 系统中使用 Ctrl+Alt+Left / Ctrl+Alt+Right 键。</li></ul><p>更多细节，参见官方文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/tutorial-exploring-navigation-and-search.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/tutorial-exploring-navigation-and-search.html</a></p><h3 id="08、PyCharm-中的版本控制"><a href="#08、PyCharm-中的版本控制" class="headerlink" title="08、PyCharm 中的版本控制"></a>08、PyCharm 中的版本控制</h3><p>版本控制系统（如 Git 和 Mercurial）是现代软件开发世界中最重要的工具之一。因此，IDE 必须支持版本控制。PyCharm 在这方面做得很好，它集成了大量流行的版本控制系统，如 Git（和 Github (<a href="https://github.com/)）、Mercurial、Perforce" target="_blank" rel="noopener">https://github.com/)）、Mercurial、Perforce</a> 和 Subversion。</p><p>注：以下示例中使用的版本控制系统为 Git。</p><h4 id="1-配置版本控制系统（VCS）"><a href="#1-配置版本控制系统（VCS）" class="headerlink" title="1. 配置版本控制系统（VCS）"></a>1. 配置版本控制系统（VCS）</h4><p>要想实现 VCS 集成，你需要在顶部菜单点击 VCS → VCS Operations Popup…，或者在 Mac 系统中使用 Ctrl+V 键，在 Windows 或 Linux 系统中使用 Alt+` 键。选择 Enable Version Control Integration…，你将看到以下窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092827.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>从下拉列表中选择 Git，点击 OK，这样你就为项目设置好了 VCS。（注意，如果你打开的已有项目已经具备版本控制系统，PyCharm 将会发现并自动使用该版本控制系统。）</p><p>这时如果你前往 VCS Operations Popup…，你会发现一个不同的弹窗，它具备选项 git add、git stash、git branch、git commit、git push 等等：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092834.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>如果你找不到所需要的选项，你可以在顶部菜单中点击 VCS，选择 Git，在这里你可以创建和查看 pull request。</p><h4 id="2-提交和冲突处理"><a href="#2-提交和冲突处理" class="headerlink" title="2. 提交和冲突处理"></a>2. 提交和冲突处理</h4><p>这是 PyCharm 中 VCS 集成的两大特征，我个人经常使用并且非常喜欢。假如你完成了工作，打算提交，前往 VCS → VCS Operations Popup… → Commit…，或者在 Mac 系统中使用 Cmd+K 键，在 Windows 或 Linux 系统中使用 Ctrl+K 键。你将看到如下窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092840.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>在该窗口中，你可以：</p><ul><li>选择要提交的文件</li><li>写下提交信息</li><li>在提交前执行各项检查</li><li>查看更改</li><li>点击右下角 Commit 按钮旁边的箭头，选择 Commit and Push…，从而一次性完成提交和 push</li></ul><p>是不是感觉很神奇很迅速？特别是如果你以前经常通过命令行手动执行这些任务时。</p><p>团队合作中会出现合并冲突（merge conflict）。当一个人对你正在处理的文件提交更改时，你们二人更改了同一行导致更改重叠，这时 VCS 无法决定选择你的更改还是队友的更改。那么你可以使用以下箭头和符号来解决这个问题：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092846.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>看起来很奇怪，我们很难分辨应该删除哪些更改、保留哪些更改。不要怕，PyCharm 来了！它可以用更好、更简洁的方法解决冲突。在顶部菜单中前往 VCS，选择 Git，然后选择 Resolve conflicts…。选择存在冲突的文件，点击 Merge，出现以下窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092852.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>在左侧列中，你可以查看自己做的更改。在右侧列中，可以查看队友做的更改。而中间列则显示结果。存在冲突的代码行被高亮显示，你可以在它们旁边看到 X 和 &gt;&gt;/&lt;&lt;。点击箭头表示接受更改，点击 X 则表示拒绝更改。解决所有冲突后，点击 Apply 按钮：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092858.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>在上图中，对于第一个冲突行，作者选择拒绝自己的更改，接受队友的更改。而在第二个冲突行中，作者接受了自己的更改，拒绝了队友的更改。</p><p>使用 PyCharm 中的 VCS 集成还可以执行很多操作。详情参见：</p><p><a href="https://www.jetbrains.com/help/pycharm/version-control-integration.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/version-control-integration.html</a></p><h3 id="09、在-PyCharm-中使用插件和外部工具"><a href="#09、在-PyCharm-中使用插件和外部工具" class="headerlink" title="09、在 PyCharm 中使用插件和外部工具"></a>09、在 PyCharm 中使用插件和外部工具</h3><p>在 PyCharm 中你可以找到开发所需的几乎所有功能。如果没找到，那么很可能存在一个插件，向 PyCharm 提供你需要的功能。例如，它们可以：</p><ul><li>添加多语言和多框架支持</li><li>使用快捷键提示（shortcut hint）、文件监视器（file watcher）等提升你的生产效率</li><li>利用代码练习，帮助你学习新的编程语言</li></ul><p>例如，IdeaVim 插件向 PyCharm 添加 Vim 模拟。如果你喜欢 Vim，这个插件可以实现不错的结合。</p><p>Material Theme UI 插件可将 PyCharm 的外观改变为 Material Design 的外观：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092904.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>Vue.js 插件使 PyCharm 支持 Vue.js 项目。Markdown 插件使得在 IDE 内可以编辑 Markdown 文件，并实时预览渲染后的 HTML。</p><p>在 Mac 系统上点击 Preferences → Plugins，在 Windows 或 Linux 系统中点击 Settings → Plugins，你可以在 Marketplace 标签下找到和安装所有可用插件：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092910.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>如果仍然没找到所需插件，你甚至可以自己开发一个。</p><p>如果你找不到合适的插件，又不想自己开发，因为 PyPI 上有可用的包，你可以将这个包作为外部工具添加到 PyCharm。以代码分析器 Flake8 为例。</p><p>首先，在所选 Terminal app 中键入 pip install flake8，从而在虚拟环境中安装 Flake8。或者也可以使用 PyCharm 集成的 Terminal：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092916.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>在 Mac 系统上点击 Preferences → Tools，在 Windows 或 Linux 系统中点击 Settings → Tools，选择 External Tools。然后点击底部 (1) 处的 + 按钮。在弹出的窗口中，输入细节并在两个窗口中点击 OK，如下图所示：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092923.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>上图中，Program (2) 指 Flake8，你可以在虚拟环境文件夹（bin）中找到它。Arguments (3) 表示你想用 Flake8 分析的文件。Working directory 表示项目目录。</p><p>你可以把这里所有项的绝对路径写死，但这就意味着你无法在其他项目中使用该外部工具，只能在一个项目中针对一个文件使用该工具。</p><p>因此你需要使用 Macros。它是$name$格式的变量，根据语境而变化。例如，当你编辑 first.py 时，$FileName$ 为 first.py，当你编辑 second.py 时，$FileName$ 为 second.py。你可以查看它们的列表，点击 Insert Macro… 按钮将其中一个插入。此处你使用了 macros，它们的值会根据你目前处理的项目而改变，Flake8 将继续准确执行其工作。</p><p>要想使用它，你需要创建文件 example.py，并在其中写入以下代码：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092928.png" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>上述代码故意破坏了 Flake8 的一些规则。右键单击文件背景，选择 External Tools → Flake8。Flake8 分析结果将出现在窗口底部：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092933.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>为了使效果更好，你可以为其添加快捷键。在 Mac 系统中选择 Preferences，在 Windows 或 Linux 系统中选择 Settings。然后，点击 Keymap → External Tools → External Tools。双击 Flake8，选择 Add Keyboard Shortcut，出现以下窗口：</p><p>上图中，快捷键是 Ctrl+Alt+A（本教程使用该快捷键）。你可以在文本框中添加喜欢的快捷键，然后在两个窗口中点击 OK。然后，你就可以用该快捷键，在 Flake8 的帮助下分析目前在处理的文件了。</p><h3 id="10、PyCharm-Professional-功能"><a href="#10、PyCharm-Professional-功能" class="headerlink" title="10、PyCharm Professional 功能"></a>10、PyCharm Professional 功能</h3><p>PyCharm Professional 是 PyCharm 的付费版本，具备更多开箱即用的功能和集成。这部分将概览其主要功能，以及官方文档链接（其中详细介绍了每一项功能）。记住，以下功能在 PyCharm Community 版本中均不可用。</p><h4 id="1-Django-支持"><a href="#1-Django-支持" class="headerlink" title="1. Django 支持"></a>1. Django 支持</h4><p>Django 是最流行和最受喜爱的 Python web 框架，PyCharm 对 Django 提供广泛的支持。要确保对 Django 的支持，需要执行以下步骤：</p><ol><li>在 Mac 系统中打开 Preferences，在 Windows 或 Linux 系统中打开 Settings。</li><li>选择 Languages and Frameworks。</li><li>选择 Django。</li><li>检查复选框 Enable Django support。</li><li>应用更改。</li></ol><p>现在确保了对 Django 的支持，你在 PyCharm 中的 Django 开发之旅将轻松很多。具体而言在创建项目时，你会得到一个专用的 Django 项目类型。这表示，当你选择该类型时，你将拥有所有必要文件和设置。这等同于使用 django-admin startproject mysite。</p><p>你也可以在 PyCharm 内直接运行 manage.py 命令。目前支持的 Django 模板，包括以下一些：</p><ul><li>语法和错误高亮显示</li><li>代码补全</li><li>导航</li><li>block 名称补全</li><li>自定义标签和过滤器补全</li><li>标签和过滤器的快速文档</li><li>模板 debug 能力</li></ul><p>除此之外，我们还可以在其他 Django 部分（如视图、URL 和模型）中执行代码补全、对 Django ORM 提供代码追踪支持（code insight support）、对 Django 模型提供模型依赖项关系图。</p><p>更多细节，参见官方文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/django-support7.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/django-support7.html</a></p><h4 id="2-数据库支持"><a href="#2-数据库支持" class="headerlink" title="2. 数据库支持"></a>2. 数据库支持</h4><p>现代数据库开发是一个复杂的任务，需要多个支持系统和工作流。这也是 JetBrains 开发独立 IDE DataGrip 的原因。DataGrip 是独立于 PyCharm 的产品，二者的应用场景和授权都不相同。</p><p>但幸运的是，通过 Database tools and SQL 插件（该插件默认开启），PyCharm 可以支持 DataGrip 中的所有特性。在该插件的帮助下，你可以查询、创建和管理数据库，不管数据库在本地、服务器，还是在云端。该插件支持 MySQL、PostgreSQL、Microsoft SQL Server、SQLite、MariaDB、Oracle、Apache Cassandra 等。</p><p>关于该插件的更多用途，请查看文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/relational-databases.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/relational-databases.html</a></p><h4 id="3-线程并发可视化（Thread-Concurrency-Visualization）"><a href="#3-线程并发可视化（Thread-Concurrency-Visualization）" class="headerlink" title="3. 线程并发可视化（Thread Concurrency Visualization）"></a>3. 线程并发可视化（Thread Concurrency Visualization）</h4><p>Django Channels、asyncio 和近期框架（如 Starlette (<a href="https://www.starlette.io/)）表明异步" target="_blank" rel="noopener">https://www.starlette.io/)）表明异步</a> Python 编程正逐渐成为趋势。异步编程具备很多好处，但很难写，也很难 debug。在此类案例中，Thread Concurrency Visualization 就是医生，帮助你全面管理多线程应用并进行优化。</p><p>更多细节，参见文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/thread-concurrency-visualization.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/thread-concurrency-visualization.html</a></p><h4 id="4-Profiler"><a href="#4-Profiler" class="headerlink" title="4. Profiler"></a>4. Profiler</h4><p>说到优化，profiling 是另一种代码优化方法。profiling 可以帮助你查看代码的哪一部分占用了最多的执行时间。profiler 运行的优先级如下：</p><ol><li>vmprof</li><li>yappi</li><li>cProfile</li></ol><p>如果你没有安装 vmprof 或 yappi，则运行标准 cProfile。</p><p>更多细节，参见：</p><p><a href="https://www.jetbrains.com/help/pycharm/profiler.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/profiler.html</a></p><h4 id="4-科学模式"><a href="#4-科学模式" class="headerlink" title="4. 科学模式"></a>4. 科学模式</h4><p>Python 不仅是通用和 web 编程语言，由于 NumPy、SciPy、scikit-learn、Matplotlib、Jupyter 等库和工具的加持，Python 成为数据科学和机器学习领域的最优工具。有了这些强大工具，你还需要一个强大的 IDE 来支持这些库所具备的绘图、分析等所有功能。</p><p>关于科学模式的更多详情，参见：</p><p><a href="https://www.jetbrains.com/help/pycharm/matplotlib-support.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/matplotlib-support.html</a></p><h4 id="5-远程开发"><a href="#5-远程开发" class="headerlink" title="5. 远程开发"></a>5. 远程开发</h4><p>很多应用出现 bug 的一个常见原因是，开发环境和生产环境不同。尽管在大多数情况下，开发时完美复制生产环境并不现实，但力求实现完美复刻是值得追寻的目标。</p><p>在 PyCharm 的帮助下，你可以使用另一台计算机（如 Linux VM）上的解释器对应用进行 debug。这样，你就可以拥有与生产环境一样的解释器了，从而避免很多因开发环境和生产环境差异导致的 bug。</p><p>详情参见：</p><p><a href="https://www.jetbrains.com/help/pycharm/remote-debugging-with-product.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/remote-debugging-with-product.html</a></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>PyCharm 是最好的 Python 开发 IDE 之一。它提供大量优势，帮助执行例行任务，从而节约大量时间。学完本教程，现在你知道如何利用 PyCharm 提高生产效率了吗？</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量劫持技术分析</title>
      <link href="/liu-liang-jie-chi-ji-zhu-fen-xi.html"/>
      <url>/liu-liang-jie-chi-ji-zhu-fen-xi.html</url>
      
        <content type="html"><![CDATA[<h1 id="流量劫持技术分析"><a href="#流量劫持技术分析" class="headerlink" title="流量劫持技术分析"></a>流量劫持技术分析</h1><p>万物互联时代，无线网络全面覆盖我们的生活，基本上各家门店都有wifi标志，而且有的还没有密码，蹭WiFi似乎已成为一项基本“生存技能”，现代人的基本状态就像下面这首打油诗一样：</p><p>枯藤老树昏鸦，空调Wifi西瓜</p><p>葛优同款沙发，我就往那一趴</p><p>如果企业没有对自家应用做好数据防护，蹭网的同时，用户个人隐私也暴露在互联网中，不安全协议传输数据，直接导致用户数据被中间人劫持获取。</p><p>同时，流量被劫持获取，可以直接对服务器发起攻击，获取服务器业务数据、用户数据等核心资产信息。那么企业应该如何去避免此类攻击的发生呢？首先得去了解一下中间人攻击的前因后果。</p><p><strong>中间人攻击的前因后果</strong></p><p><strong>协议先天性缺陷</strong></p><p><strong>（1）HTTP明文传输导致用户信息泄露？</strong></p><p>从攻击的视频中可以知道，攻击者是实施了HTTP协议的中间人攻击，相信每个计算机行业人员都知道，超文本传输协议（HTTP，HyperText TranSfer Protocol）是互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准，也就是说万维网不得不使用这个协议，也是非常的尴尬。</p><p><strong>从攻击者的角度是怎么看待这个问题呢？</strong></p><p>寻找一个采用HTTP协议传输数据的网站系统，这里针对用户登录的账号信息进行数据获取，使用WireShark流量分析工具对局域网下的用户HTTP数据包进捕获，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121924.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>对TCP数据流进行数据分析，可以发现，存在明文的用户名uname和密码password，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121935.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><strong>总结：由此可见HTTP数据流是用明文方式传输数据，攻击者可以利用局域网抓包等手段轻易获取用户与服务器的交互信息。</strong> </p><p><strong>（2）为什么HTTP是明文传输？</strong></p><p>从上一小节可以知道攻击者抓取的HTTP数据包里面的数据是明文，为了解明文传输的原理，可以先了解以下在OSI七层模型中HTTP协议工作的地方，OSI模型七个层次的功能以及协议集图示如下：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121943.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>根据OSI七层模型，可以知道HTTP协议工作在应用层，再来看看HTTP数据包的封装过程，发送方在客户端页面输入上层数据，上层数据到传输层会添加TCP报头形成数据段，再下送到网络层添加IP报头形成数据段，在继续下送至数据链路层添加以太网首部和尾部，形成以太网帧，最后传递至物理层形成01010形式的比特流，整个过程，上层数据这一部分没有进行任何加密数据处理，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121952.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>同理接收方也是如此，接受方收到二进制比特流，通过层层上送解包，最终获取明文的上层数据，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121957.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><strong>总结：HTTP虽然是应用层的协议，但是其数据在整个数据装包中都是处于明文状态，只是不同层次之间进行了包的封装转换，在不同层次会看到不同的数据，比如在物理层，只能看到0101010类型的二进制比特流，但是在应用层却可以看到明文的数据，整个过程只是一个数据包的封装和解包，没有设计数据的加密和解密操作。</strong></p><p><strong>（3）中间人攻击的根源是什么？</strong></p><p>通过了解HTTP明文传输的分析过后，结合OSI七层模型每一层的含义，参考如下：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122005.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>路由器是存在于OSI七层模型的网络层，也就是通常接触最多的局域网，家里接入有线或者无线网络都会设置路由器，用户通过接入路由器与外界网络进行联系。</p><p>中间人攻击也是在这一层面实施攻击的，这一层存在的协议参考OSI七层模型可以知道有IP，ARP，ICMP等协议。在路由器层面，也就是局域网内是通过地址解析协议即ARP（AddreSS ReSolution Protocol），根据IP地址获取物理地址进行目标寻址交流。大概的流程内容如下：</p><ul><li>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；</li><li>收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</li></ul><p>ARP协议没有安全认证机制，因为局域网内主机是建立在信任的基础上的，所以只要主机接收到ARP应答包，都会缓存在ARP表中，这就为ARP欺骗提供了可能。攻击者可以发送错误的IP地址MAC地址的映射关系。</p><p>ARP欺骗主机等攻击是最常见的中间人攻击，在同一个局域网中，通过将网卡设置为混杂模式，借助ARP欺骗实现中间人攻击即可监听目标设备的网络通信。ARP攻击原理如下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122010.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-122018.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>主机A IP:192.168.1.2 MAC:02-02-02-02-02-02</p><p>主机B IP:192.168.1.3 MAC:03-03-03-03-03-03</p><p>网关 IP:192.168.1.1 MAC:01-01-01-01-01-01</p><p>主机B为攻击者，向被攻击者主机A不断发送ARP响应数据包内容：IP：192.168.1.1对应MAC：03-03-03-03-03-03 向网关不断发送ARP响应包内容：192.168.1.2对应MAC：03-03-03-03-03-03，在局域网内，广播寻址是根据MAC地址来定位用户地址的，所以，一旦mac地址进行了改变，用户地址也就进行了改变，由于ARP会更新缓存表的特性，导致了攻击者可以通过不断发送ARP响应包达到欺骗网关和被攻击者的目的，代替用户与网关进行信息交互，同时代替网关与用户联系，进而形成了中间人攻击。</p><p><strong>总结：ARP缓存接受任何时间更新成为中间人攻击的根本原因</strong></p><p><strong>安全协议不安全</strong></p><p><strong>（1）HTTPS加密传输也存在信息泄漏？</strong></p><p>开发人员针对部分不安全协议进行了安全控制，采用HTTP+SSL的方式进行数据传输，也就是我们常说的HTTPS协议。使用安全套接字层（SSL）进行信息交换，简单来说就是HTTP的安全版，来保证传输的数据安全。</p><p>从攻击者的角度是怎么看待这个问题呢？</p><p>可以通过实验来看结果，选择QQ邮箱登录网站，该网站使用HTTPS，使用WireShark抓包查看TCP数据量</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122024.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>追踪TCP数据流，数据全是乱码，无法识别数据，很明显数据已经被加密了，通过抓包并没有获取用户信息。</p><p>到这里一定会存在一个疑问，如果我的App与服务器全部采用HTTPS通信不就没有中间人攻击的问题了吗？</p><p>事实上如果用自己伪造的CA证书去加解密数据包，一样可以获取到敏感信息，大致攻击思路：攻击者在设备上导入并信任自己的CA证书，然后利用该证书进行数据的加密和解密，在这个过程中，明文信息已经被暴露在攻击者面前。</p><p>比如这里，将CA证书导入设备让其信任，使用工具抓包，能够清晰看见HTTPS数据包的信息。同样是qq邮箱登录的数据，区别就在于使用工具之前我让设备信任了自己的CA证书。当然这里并没有抓到明文密码，这是由于qq邮箱还有其他数据安全加密设置，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122029.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><strong>总结：HTTPS证书信任机制出现问题，还是可以进行中间人攻击截取用户明文的数据流量。</strong></p><p><strong>（2）HTTPS为什么存在安全风险？</strong></p><p>从上一节可以了解到，HTTPS加密协议也是存在中间人攻击的，为了解攻击的原理，我们可以先来看一看HTTPS的握手过程。这里以支付宝为例，利用WireShark获取支付宝的HTTPS数据流量进行分析</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122035.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>客户端发送Client Hello请求建立HTTPS链接，服务器返回Server Hello回应客户端接收到请求，并下发HTTPS证书给客户进行验证，客户端验证通过，发送对称加密密钥，进行数据交换。能够非常直观的看出握手流程，简单的HTTPS实现图</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122040.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>如果客户端未严格校验证书或者忽略了域名校验，攻击者可以通过对客户端进行操作，从而绕过客户端的弱校验，达到欺骗服务器，进行中间人攻击的目的。简单例举了HTTPS存在的问题</p><ul><li>忽略SSL证书校验</li><li>忽略域名校验</li><li>证书信息泄漏</li></ul><p>情况一、信任任何证书。出现这种情况的原因很有可能是使用的开源通信库存在缺陷，还有就是开发人员在开发过程中未连接生产环境的服务器，为解决认证过程中证书报错的问题只能暂时修改代码使其APP信任任意证书，而在上线前未对此代码进行处理。通过对APP进行逆向分析，可以在客户端代码中发现存在开发人员忽略证书认证的代码片段</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122045.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>该段代码重写了谷歌原有X509Certificate[]的校验方式，进行了覆盖，却没有添加自己的证书校验代码，导致证书校验的代码为空，攻击者可以使用任意证书进行流量劫持，这里利用了工具自签名一个证书，即可进行HTTPS证书校验绕过，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122051.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>情况二、信任证书管理机构（CA）颁发的证书。这种情况的APP可以信任任何CA颁发的证书，据说这类的证书只需50美元就能买到。此类问题出在AFNetworking 2.5.2及之前的版本，也就是说如果某APP使用了此版本的开源通信库，在不安全Wifi网络中的黑客、VPN网络中的职工或者国家支持的黑客，只要使用CA颁发的证书就可以对该APP的HTTPS加密数据进行监听或者篡改，在源代码中发现配置代码片段：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122058.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>该段代码一个重要的配置ALLOW_ALL_HOSTNAME_VERIFIER,使其信任官方的CA证书，无论是颁发给谁的，只要是官方的证书，都可以信任，从而导致验证失败。</p><p>情况三、信任合法证书。这种情况的APP只信任对自己而言合法的证书，首先我们看一下SSL认证的原理的前三步：1、客户端向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。2、服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。3、客户端利用服务端传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行下一步。那么如何让APP信任非法的证书呢，看上文说到的3步，我们只需要做到在合法性验证的时候能够欺骗APP，通讯就不会中断。在手机本地添加一个信任证书，APP在本地验证的时候，由于手机信任该证书，APP默认也信任该证书，达到欺骗APP的目的。</p><p>情况四、这种情况是采用了服务器和客户端双向认证的措施，即客户端在确认服务器是否合法之后，服务器也要确认客户端是否是合法的（服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥）。正是这个原因，我们在测试APP时会发现尽管我们信任了burp或者fiddler的证书，可是在进行登录操作时APP依然会显示网络连接错误，此时服务端已经知道客户端可能是非法的，然后拒绝连接。如果你是开发人员，想分析HTTPS流量也很简单：使用burp导入客户端证书，此时burp就可以与服务器正常的建立连接，你也可以正常的截取到数据包了，只要获取到证书以及密钥，即可进行数据获取。APP开发时，在本地实现证书导入，应用于HTTPS双向校验传输证书的密钥可以在本地获取，参考实现代码片段</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122105.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>分析上例代码可以发现，应用于证书client.p12的密钥，猜测在he.b()/he.a()函数中会进行一个处理，利用hook技术，对函数内容进行hook，即可获取字符串信息，该信息包括了密钥和其他的数据，利用获取的密钥和本地保存的client.p12证书，即可模拟开发人员进行HTTPS双向验证，截取用户明文信息。</p><p>两者代码片段分别如下</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122110.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><strong>总结：HTTPS安全协议不安全，主要还是在设计阶段选择了单向校验，在加上后期没有进行严格的证书校验，导致HTTPS证书验证被绕过，其次就是采用了双向校验，但是本地校验的代码没有进行安全保护，攻击者通过动态HOOK，也是可以获取CA证书以及其密钥信息。</strong></p><p><strong>（3）HTTPS中间人攻击的危害？</strong></p><p>HTTPS虽然也存在中间人攻击，但是和ARP局域网攻击又存在很大的差别，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122117.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>ARP欺骗，数据信息攻击获取范围是介于路由器和用户手机之间，也就是OSI模型的数据链路层，路由器和用户手机之间传输的信息都可能被攻击者截取，通过中间人攻击获取在同一局域网下所有用户的数据流量</p><p>SSL欺骗，SSL是位于OSI模型的传输层和应用层之间，可以通过绕过APP本地校验机制实现在传输层和应用层之间的数据传输（数据到达应用层，也就是给用户的展示界面是明文的）截取，从而获取明文数据，或者是HTTPS相关的密钥信息。仅存在用户自己手机内部，只能获取攻击者本身操作的账户流量信息</p><p>总结：就攻击范围来讲，在客户端的攻击HTTPS攻击是影响面比较窄，但就针对服务端的攻击影响来看，两者是一致的，都可以操作服务端数据，获取服务端信息，都能危及服务器安全。</p><p><strong>几维安全解决方案</strong></p><p>应对传输协议缺陷，流量被劫持的安全风险，几维安全建议以协议安全，数据安全，应用代码安全为目标来应对中间人攻击。</p><p>首先对客户端APP的可执行文件DEX、SO、Mach-O被破解的风险，几维安全采用源代码保护技术，对DEX文件进行JAVA2C，将JAVA代码下沉至Native层，并在该层对转化后的伪C代码进行强度最高的虚拟化处理，对SO和Mach-O文件采用源代码编译的方式，直接把C/C++/Object-C/Swift工程项目编译成KiwiVM虚拟化后的结果，保障客户的不被攻击者逆向破解。</p><p>其次对在终端设备运行的客户端运行时会在内存中传递重要的数据，通过接入几维安全防御安全SDK，可以对手机环境，进程防护，代码注入等方面进行全面的检测和防护，保证本地内存数据不遭受恶意篡改。</p><p>同时，针对通道存在的明文传输和协议破解伪造风险，几维安全提供结合<a href="https://www.kiwisec.com/product/KiwiVM-iot.html" target="_blank" rel="noopener">代码虚拟化技术</a>和白盒技术研发的白盒密钥SDK。利用SDK对传输的数据和存储的数据进行高强度的加密，且提供动态加密、数据完整性校验等功能，支持多种对称加密、非对称加密和哈希算法，严格保障了数据的完整性和保密性。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122124.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流量劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何超过大多数人</title>
      <link href="/ru-he-chao-guo-da-duo-shu-ren.html"/>
      <url>/ru-he-chao-guo-da-duo-shu-ren.html</url>
      
        <content type="html"><![CDATA[<p>当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！</p><p>P.S. 这篇文章借鉴于《<a href="https://coolshell.cn/articles/4758.html" target="_blank" rel="noopener">如何写出无法维护的代码</a>》一文的风格……嘿嘿</p><h4 id="相关技巧和最佳实践"><a href="#相关技巧和最佳实践" class="headerlink" title="相关技巧和最佳实践"></a>相关技巧和最佳实践</h4><p>要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。<strong>所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了</strong>。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。</p><p>在信息获取上，你要不断地向大众鼓吹下面的这些事：</p><ul><li>让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。</li><li>让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。</li><li>把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。</li><li>让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场……</li><li>利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。</li></ul><p>然后，在知识学习和技能训练上，让他们不得要领并产生幻觉</p><ul><li>让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……</li><li>培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……</li><li>不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”……</li><li>让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃……</li><li>玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……</li><li>让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……</li><li>告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……</li><li>让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……</li><li>让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……</li></ul><p>最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。</p><ul><li>让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好……</li><li>宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……</li><li>告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……</li><li>多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……</li><li>多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……</li><li>让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……</li><li>让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……</li><li>告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春……</li><li>当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）</li><li>告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……</li><li>每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……</li></ul><p><strong>最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。</strong></p><h4 id="相关原理和思维模型"><a href="#相关原理和思维模型" class="headerlink" title="相关原理和思维模型"></a>相关原理和思维模型</h4><p>对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。</p><p>一般来说，超过别人一般来说就是两个维度：</p><ol><li><strong>在认知、知识和技能上</strong>。这是一个人赖以立足社会的能力（参看《<a href="https://coolshell.cn/articles/4235.html" target="_blank" rel="noopener">程序员的荒谬之言还是至理名言？</a>》和《<a href="https://coolshell.cn/articles/2250.html" target="_blank" rel="noopener">21天教你学会C++</a>》）</li><li><strong>在领导力上</strong>。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《<a href="https://coolshell.cn/articles/17583.html" target="_blank" rel="noopener">技术人员发展之路</a>》）</li></ol><p>首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。</p><h5 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h5><p>要在认知上超过别人，就要在下面几个方面上做足功夫：</p><p>1）<strong>信息渠道</strong>。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？）</p><p>2）<strong>信息质量</strong>。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。</p><p>3）<strong>信息密度</strong>。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像<a href="https://medium.com/netflix-techblog" target="_blank" rel="noopener">Netflix的官方blog</a>和<a href="https://www.allthingsdistributed.com/" target="_blank" rel="noopener">AWS CTO的blog</a>等等地方也会经常有一些这样的文章。</p><h5 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h5><p>要在知识上超过别人，你就需要在下面几个方面上做足功夫：</p><p>1）<strong>知识树（图）</strong>。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，<strong>对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！</strong></p><p>2）<strong>知识缘由</strong>。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。<strong>能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。</strong></p><p>3）<strong>方法套路</strong>。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。<strong>你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路</strong>。</p><h5 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h5><p>要在技能上超过别人，你就需要在下面几个方面做足功夫：</p><p>1）<strong>精益求精</strong>。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。</p><p>2）<strong>让自己犯错</strong>。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！</p><p>3）<strong>找高手切磋</strong>。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！</p><h5 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h5><p>最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。</p><p>1）<strong>识别自己的特长和天赋</strong>。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。</p><p>2）<strong>识别自己的兴趣和事业</strong>。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。</p><p>3）<strong>建立高级的习惯和方法</strong>。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。</p><p>4）<strong>勤奋努力执着坚持</strong>。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《<a href="https://coolshell.cn/articles/2250.html" target="_blank" rel="noopener">21天教你学会C++</a>》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。</p><p>好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。</p><p>转至 <a href="https://coolshell.cn/articles/19464.html" target="_blank" rel="noopener">https://coolshell.cn/articles/19464.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天生容易胖？坚持这几项运动，减肥依旧不是梦</title>
      <link href="/jian-fei.html"/>
      <url>/jian-fei.html</url>
      
        <content type="html"><![CDATA[<p>你是不是也有过这样的经历？同样是放飞自我胡吃海喝，自己逢年过节胖三斤，身边的小伙伴却还一如既往瘦如闪电。</p><h2 id="容易发胖是谁的锅？"><a href="#容易发胖是谁的锅？" class="headerlink" title="容易发胖是谁的锅？"></a>容易发胖是谁的锅？</h2><p>这事儿其实不能怪你，人容不容易胖，和很多因素有关，比如性别、年龄，比如喝酒、抽烟习惯，甚至有研究发现学历越高越不容易发胖 [1]。</p><p>另外，还有一个相当重要的因素——<strong>基因</strong>，并且不是一个两个基因，而是一堆基因：2014年，美国的学者们利用贝叶斯模型找出了欧洲裔美国人群体中8个和肥胖相关的基因，并推测这些基因是通过影响能量摄入的方式影响肥胖 [2]；2015年，又有学者通过全基因组关联分析鉴定出了欧洲人中97个和肥胖相关的基因 [3]。</p><p>所以如果你觉得自己喝水都会长肉，也许这就是命……</p><p>不过，就算命运如此安排，大家还是不可自暴自弃！近期一项最新的研究结果表明，先天易胖，还是有救的！</p><p><img src="https://img.iamghf.top/blog/2019-12-26-113105.gif" alt="img">先天易胖，还是有救的 | 《大侦探皮卡丘》</p><p>最近PLoS Genetics杂志发表了一项关于基因性易胖和运动的研究 [4]。在这项研究中，Lin等人主要探讨了下面这两个问题：运动能不能影响基因导致的肥胖倾向？如果能的话，哪种运动影响最大？</p><h2 id="运动可以改变被写进基因的命运"><a href="#运动可以改变被写进基因的命运" class="headerlink" title="运动可以改变被写进基因的命运"></a>运动可以改变被写进基因的命运</h2><p>为了回答这两个问题，研究者们首先建立了一个多基因风险评分模型。多基因风险评分模型能够通过统计学方法，用一个人的基因序列来预测其患病风险，或者身高啦、是否会脱发啦等等性状的产生概率。在Lin等人的研究中，这个模型便用来预测基因导致的个体肥胖风险。</p><p>通过多基因风险评分模型，Lin等人将研究涉及到的近2万名个体按照基因肥胖风险分为了四个等级；在这个基础上，他们又将每个等级中的个体按照“是否进行规律锻炼”分成了两类，分别统计了每一类样本个体的平均BMI.（注：“规律锻炼”被定义为每次至少30分钟，每周至少三次，每天定时定点亲自下楼买奶茶是不算的！）</p><p>BMI 指一个人的体重与身高的平方之比，是用来评估个体肥胖程度的一个常用指标，BMI指数超过25即为“超重”，超过30就是“肥胖”。</p><p>研究表明，BMI在22.5kg/m2至25kg/m2 之间的个体死亡风险最小。不出意外地，基因肥胖风险更小的组平均BMI更低，基因肥胖风险更大的组平均BMI更高。与此同时，Lin等人发现，在基因肥胖风险最小的组中，规律锻炼的个体BMI比不锻炼个体的BMI更高；而在基因肥胖风险最大的组中，规律锻炼的个体BMI更低。这说明，规律锻炼的人更可能拥有健康的BMI水平。</p><p><img src="https://1-im.guokr.com/jBgXo_YBS-xzWiVAjCYJX00wodTu07RrEd6ObLUIwq44BAAAogMAAEpQ.jpg?imageView2/1/w/555/h/477" alt="img">四组不同基因肥胖风险评分的人群中，不锻炼/日常锻炼个体的平均BMI | 修改自参考文献4</p><p>除了BMI之外，还有其它肥胖衡量指标，比如体脂率，腰围（反映向心性肥胖，就是“将军肚”），臀围（反映糖尿病等代谢疾病）等等。这些指标与BMI类似，和基因肥胖风险成正相关。同样地，在基因肥胖风险最大的组中，规律锻炼个体的所有指标都比不锻炼个体的指标要低——说明规律锻炼能够改善个体健康状况，在一定程度上抵抗基因导致的肥胖风险。</p><h2 id="对于易胖人群，哪些运动更减肥？"><a href="#对于易胖人群，哪些运动更减肥？" class="headerlink" title="对于易胖人群，哪些运动更减肥？"></a>对于易胖人群，哪些运动更减肥？</h2><p>这个结果其实也不算意外，如果研究发现“运动对减肥没有效果”，那才是个大新闻呢。真正的重点在后面——你知道那么多种运动，哪种最减肥吗？</p><p>Lin等人比较了十八种运动对于肥胖指标的影响。这十八种武艺运动包括：慢跑、散步、快走、骑行、爬山、拉伸、国标舞、游泳、太极、跳舞毯、瑜伽、气功、举重、羽毛球、乒乓球、篮球、网球和其它。而在实验室或者办公室或者工地搬砖等，只要是因工作产生的运动，都不计算在内。</p><p><img src="https://1-im.guokr.com/IBr6FDO5fhqnqcBZAwK5fH1nFe7n39ohaAZMbSr0FWBcAQAAjwEAAFBO.png" alt="img">基因肥胖风险评分每升高一个标准差，日常锻炼者BMI和非锻炼者BMI的变化差异。其中，不同运动方式按流行程度自上而下排列。单位：kg/m2 | 修改自参考文献4</p><p>研究者们定量地比较了不同运动对基因肥胖风险的抵消性。从数字上看，大部分运动（上图为负值的运动）都能够在一定程度上抵消部分基因肥胖风险。但值得注意的是，有些运动的抵消效果其实是“<strong>不显著</strong>” 的。这里，“不显著”的意思是指运动效果不大稳定。举个例子，四个朋友一起团购了减肥课程A，课程结束，四个朋友中有两个人各减了10斤，有个人一斤没减，还有一个人胖了10斤。平均每个人减了2.5斤，看起来效果还不错。但是，如果你去参加这个课程，你认为自己会是减10斤的那个，还是胖10斤的那个呢？——A课程的减肥效果就是不显著的。第二年，这群朋友出于某些原因又相约团购了减肥课程B，这次课程结束之后每个人都减了2斤，虽然平均下来不如课程A减得重量多，但胜在表现稳定，给后续想要报名课程的伙伴们提供了很好的参照——课程B的效果就是比A显著的。</p><p>在科学研究中，显著性检验是得出结论的必须步骤之一。在Lin等人的研究中，他们使用了较为严苛的显著性检验方法，最终发现，<strong>慢跑作为能够同时抑制BMI、体脂、和臀围的Top1运动脱颖而出，爬山、散步、快走和国标舞对于抑制BMI也有良好的效果</strong>。至于其它运动，例如游泳啊、骑车啊等等，则被淘汰出局了。</p><p><img src="https://2-im.guokr.com/iLNFoaNOyXDuU57d0UePx_qefEPXExCuzl9djTW3mKn0AQAAGQEAAEpQ.jpg" alt="img">慢跑从众多运动中脱颖而出 | pexels</p><p>好些运动对于减肥的效果似乎并没有那么有效，这个结果还挺出人意料的。前面提到，当前模型里只考虑了“是否参与某种运动”，<strong>那如果把运动时间、运动频率也考虑进来呢？</strong>结果显示，瑜伽做得久也可以抑制BMI的升高，但是颇受欢迎的游泳运动，即使游得久、游得多，好像对于抑制肥胖来说还是没有什么用。</p><p>为什么会有这样的结果呢？作者分析，举重、羽毛球、乒乓球、篮球和网球可能是因为样本量小造成统计不显著；骑行、拉伸运动和气功可能是因为一般人运动时能量消耗太小；至于游泳，有研究提到，<strong>冷水中的运动会刺激食欲，导致运动后吃得更多了</strong>[5, 6]……不过，这些结果也有可能是由样本本身具有、而文章中没有考虑到的因素带来的统计偏差。</p><p>值得一提的是，这篇研究论文中使用的多基因评分模型是基于台湾省人体生物资料库中的相关数据建立的，<strong>这个资料库的绝大部分样本来自具有汉族血统的志愿者</strong> [4, 7]，也就是说，这一篇研究的结果应该对大部分中国人都相当具有参考性了！</p><p>不过话又说回来，不管什么基因啊、血统啊、还是哪种运动效果更好啊，都不是重点。重点是，每天只是动动手指收藏不同的运动分析文章是没有用没有用没有用的！</p><p>今天天气正好，不如晚上一起去跑个步？</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 减肥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统的事务处理</title>
      <link href="/fen-bu-shi-xi-tong-de-shi-wu-chu-li.html"/>
      <url>/fen-bu-shi-xi-tong-de-shi-wu-chu-li.html</url>
      
        <content type="html"><![CDATA[<p>#分布式系统的事务处理</p><p>当我们在生产线上用一台服务器来提供数据服务的时候，我会遇到如下的两个问题：</p><p>1）一台服务器的性能不足以提供足够的能力服务于所有的网络请求。</p><p>2）我们总是害怕我们的这台服务器停机，造成服务不可用或是数据丢失。</p><p>于是我们不得不对我们的服务器进行扩展，加入更多的机器来分担性能上的问题，以及来解决单点故障问题。 通常，我们会通过两种手段来扩展我们的数据服务：</p><p>1）<strong>数据分区</strong>：就是把数据分块放在不同的服务器上（如：uid % 16，一致性哈希等）。</p><p>2）<strong>数据镜像</strong>：让所有的服务器都有相同的数据，提供相当的服务。</p><p>对于第一种情况，我们无法解决数据丢失的问题，单台服务器出问题时，会有部分数据丢失。所以，<strong>数据服务的高可用性只能通过第二种方法来完成——数据的冗余存储</strong>（一般工业界认为比较安全的备份数应该是3份，如：Hadoop和Dynamo）<strong>。 但是，加入更多的机器，会让我们的数据服务变得很复杂，尤其是跨服务器的事务处理，也就是跨服务器的数据一致性</strong>。这个是一个很难的问题。 让我们用最经典的Use Case：“A帐号向B帐号汇钱”来说明一下，熟悉RDBMS事务的都知道从帐号A到帐号B需要6个操作：</p><ol><li>从A帐号中把余额读出来。</li><li>对A帐号做减法操作。</li><li>把结果写回A帐号中。</li><li>从B帐号中把余额读出来。</li><li>对B帐号做加法操作。</li><li>把结果写回B帐号中。</li></ol><p>为了数据的一致性，这6件事，要么都成功做完，要么都不成功，而且这个操作的过程中，对A、B帐号的其它访问必需锁死，所谓锁死就是要排除其它的读写操作，不然会有脏数据的问题，这就是事务。那么，我们在加入了更多的机器后，这个事情会变得复杂起来：</p><p>1）<strong>在数据分区的方案中</strong>：如果A帐号和B帐号的数据不在同一台服务器上怎么办？我们需要一个跨机器的事务处理。也就是说，如果A的扣钱成功了，但B的加钱不成功，我们还要把A的操作给回滚回去。这在跨机器的情况下，就变得比较复杂了。</p><p>2）<strong>在数据镜像的方案中</strong>：A帐号和B帐号间的汇款是可以在一台机器上完成的，但是别忘了我们有多台机器存在A帐号和B帐号的副本。如果对A帐号的汇钱有两个并发操作（要汇给B和C），这两个操作发生在不同的两台服务器上怎么办？也就是说，在数据镜像中，在不同的服务器上对同一个数据的写操作怎么保证其一致性，保证数据不冲突？</p><p>同时，我们还要考虑性能的因素，如果不考虑性能的话，事务得到保证并不困难，系统慢一点就行了。除了考虑性能外，我们还要考虑可用性，也就是说，一台机器没了，数据不丢失，服务可由别的机器继续提供。 于是，我们需要重点考虑下面的这么几个情况：</p><p>1）<strong>容灾</strong>：数据不丢、结点的Failover</p><p>2）<strong>数据的一致性</strong>：事务处理</p><p>3）<strong>性能：吞吐量 、 响应时间</strong></p><p>前面说过，要解决数据不丢，只能通过数据冗余的方法，就算是数据分区，每个区也需要进行数据冗余处理。这就是数据副本：当出现某个节点的数据丢失时可以从副本读到，数据副本是分布式系统解决数据丢失异常的唯一手段。所以，在这篇文章中，简单起见，我们只讨论在数据冗余情况下考虑数据的一致性和性能的问题。简单说来：</p><p><strong>1）要想让数据有高可用性，就得写多份数据。</strong></p><p><strong>2）写多份的问题会导致数据一致性的问题。</strong></p><p><strong>3）数据一致性的问题又会引发性能问题</strong></p><p>这就是软件开发，按下了葫芦起了瓢。</p><h4 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h4><p>说起数据一致性来说，简单说有三种类型（当然，如果细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：</p><p>1）<strong>Weak 弱一致性</strong>：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系，VOIP这样的系统，或是百度搜索引擎（呵呵）。</p><p>2）<strong>Eventually 最终一致性</strong>：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。</p><p>3）<strong>Strong 强一致性</strong>：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。</p><p>从这三种一致型的模型上来说，我们可以看到，Weak和Eventually一般来说是异步冗余的，而Strong一般来说是同步冗余的，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。 好，让我们由浅入深，一步一步地来看有哪些技术：</p><h4 id="Master-Slave"><a href="#Master-Slave" class="headerlink" title="Master-Slave"></a>Master-Slave</h4><p>首先是Master-Slave结构，对于这种加构，Slave一般是Master的备份。在这样的系统中，一般是如下设计的：</p><p>1）读写请求都由Master负责。</p><p>2）写请求写到Master上后，由Master同步到Slave上。</p><p>从Master同步到Slave上，你可以使用异步，也可以使用同步，可以使用Master来push，也可以使用Slave来pull。 通常来说是Slave来周期性的pull，所以，是最终一致性。这个设计的问题是，如果Master在pull周期内垮掉了，那么会导致这个时间片内的数据丢失。如果你不想让数据丢掉，Slave只能成为Read-Only的方式等Master恢复。</p><p>当然，如果你可以容忍数据丢掉的话，你可以马上让Slave代替Master工作（对于只负责计算的结点来说，没有数据一致性和数据丢失的问题，Master-Slave的方式就可以解决单点问题了） 当然，Master Slave也可以是强一致性的， 比如：当我们写Master的时候，Master负责先写自己，等成功后，再写Slave，两者都成功后返回成功，整个过程是同步的，如果写Slave失败了，那么两种方法，一种是标记Slave不可用报错并继续服务（等Slave恢复后同步Master的数据，可以有多个Slave，这样少一个，还有备份，就像前面说的写三份那样），另一种是回滚自己并返回写失败。（注：一般不先写Slave，因为如果写Master自己失败后，还要回滚Slave，此时如果回滚Slave失败，就得手工订正数据了）你可以看到，如果Master-Slave需要做成强一致性有多复杂。</p><h4 id="Master-Master"><a href="#Master-Master" class="headerlink" title="Master-Master"></a>Master-Master</h4><p>Master-Master，又叫<a href="http://en.wikipedia.org/wiki/Multi-master_replication" target="_blank" rel="noopener">Multi-master</a>，是指一个系统存在两个或多个Master，每个Master都提供read-write服务。这个模型是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。 Master-Master的好处是，一台Master挂了，别的Master可以正常做读写服务，他和Master-Slave一样，当数据没有被复制到别的Master上时，数据会丢失。很多数据库都支持Master-Master的Replication的机制。</p><p>另外，如果多个Master对同一个数据进行修改的时候，这个模型的恶梦就出现了——对数据间的冲突合并，这并不是一件容易的事情。看看Dynamo的Vector Clock的设计（记录数据的版本号和修改者）就知道这个事并不那么简单，而且Dynamo对数据冲突这个事是交给用户自己搞的。就像我们的SVN源码冲突一样，对于同一行代码的冲突，只能交给开发者自己来处理。（在本文后后面会讨论一下Dynamo的Vector Clock）</p><h4 id="Two-Three-Phase-Commit"><a href="#Two-Three-Phase-Commit" class="headerlink" title="Two/Three Phase Commit"></a>Two/Three Phase Commit</h4><p>这个协议的缩写又叫2PC，中文叫两阶段提交。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为<strong>协调者</strong>的组件来统一掌控所有节点(称作<strong>参与者</strong>)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。 两阶段提交的算法如下：</p><p><strong>第一阶段</strong>：</p><ol><li>协调者会问所有的参与者结点，是否可以执行提交操作。</li><li>各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……</li><li>参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。</li></ol><p><strong>第二阶段</strong>：</p><ul><li><p>如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。</p></li><li><p>如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。</p></li></ul><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/Two-phase_commit.png" alt="img"></p><p>我们可以看到，2PC说白了就是第一阶段做Vote，第二阶段做决定的一个算法，也可以看到2PC这个事是强一致性的算法。在前面我们讨论过Master-Slave的强一致性策略，和2PC有点相似，只不过2PC更为保守一些——先尝试再提交。 2PC用的是比较多的，在一些系统设计中，会串联一系列的调用，比如：A -&gt; B -&gt; C -&gt; D，每一步都会分配一些资源或改写一些数据。比如我们B2C网上购物的下单操作在后台会有一系列的流程需要做。如果我们一步一步地做，就会出现这样的问题，如果某一步做不下去了，那么前面每一次所分配的资源需要做反向操作把他们都回收掉，所以，操作起来比较复杂。现在很多处理流程（Workflow）都会借鉴2PC这个算法，使用 try -&gt; confirm的流程来确保整个流程的能够成功完成。 举个通俗的例子，西方教堂结婚的时候，都有这样的桥段：</p><p>1）牧师分别问新郎和新娘：你是否愿意……不管生老病死……（询问阶段）</p><p>2）当新郎和新娘都回答愿意后（锁定一生的资源），牧师就会说：我宣布你们……（事务提交）</p><p>这是多么经典的一个两阶段提交的事务处理。 另外，我们也可以看到其中的一些问题， A）其中一个是同步阻塞操作，这个事情必然会非常大地影响性能。 B）另一个主要的问题是在TimeOut上，比如，</p><p>1）如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。</p><p>2）如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。</p><p>3）糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。</p><p>两段提交最大的问题就是第3）项，<strong>如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务</strong>。也就是说，协调者Coordinator对于事务的完成非常重要，Coordinator的可用性是个关键。 因些，我们引入三段提交，三段提交在<a href="http://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank" rel="noopener">Wikipedia</a>上的描述如下，他把二段提交的第一个段break成了两段：询问，然后再锁资源。最后真正提交。三段提交的示意图如下：</p><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/Three-phase_commit_diagram.png" alt="img"></p><p>三段提交的核心理念是：<strong>在询问的时候并不锁定资源，除非所有人都同意了，才开始锁资源</strong>。</p><p>理论上来说，如果第一阶段所有的结点返回成功，那么有理由相信成功提交的概率很大。这样一来，可以降低参与者Cohorts的状态未知的概率。也就是说，一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了。这一点很重要。下面我们来看一下3PC的状态迁移图：（<strong>注意图中的虚线，那些F,T是Failuer或Timeout</strong>，其中的：状态含义是 q – Query，a – Abort，w – Wait，p – PreCommit，c – Commit）</p><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/Three-phase_commit_status.png" alt="img"></p><p>从上图的状态变化图我们可以从虚线（那些F,T是Failuer或Timeout）看到——<strong>如果结点处在P状态（PreCommit）的时候发生了F/T的问题，三段提交比两段提交的好处是，三段提交可以继续直接把状态变成C状态（Commit），而两段提交则不知所措</strong>。</p><p>其实，三段提交是一个很复杂的事情，实现起来相当难，而且也有一些问题。</p><p>看到这里，我相信你有很多很多的问题，你一定在思考2PC/3PC中各种各样的失败场景，<strong>你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设</strong>。</p><p><strong>一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候</strong>。</p><h4 id="Two-Generals-Problem（两将军问题）"><a href="#Two-Generals-Problem（两将军问题）" class="headerlink" title="Two Generals Problem（两将军问题）"></a>Two Generals Problem（两将军问题）</h4><p><a href="http://en.wikipedia.org/wiki/Two_Generals' target="_blank" rel="noopener"_Problem">Two Generals Problem</a> 两将军问题是这么一个思维性实验问题： 有两支军队，它们分别有一位将军领导，现在准备攻击一座修筑了防御工事的城市。这两支军队都驻扎在那座城市的附近，分占一座山头。一道山谷把两座山分隔开来，并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是，这个山谷已经被那座城市的保卫者占领，并且存在一种可能，那就是任何被派出的信使通过山谷是会被捕。 请注意，虽然两位将军已经就攻击那座城市达成共识，但在他们各自占领山头阵地之前，并没有就进攻时间达成共识。两位将军必须让自己的军队同时进攻城市才能取得成功。因此，他们必须互相沟通，以确定一个时间来攻击，并同意就在那时攻击。如果只有一个将军进行攻击，那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。下面是我们的思考：</p><p>1）第一位将军先发送一段消息“让我们在上午9点开始进攻”。然而，一旦信使被派遣，他是否通过了山谷，第一位将军就不得而知了。任何一点的不确定性都会使得第一位将军攻击犹豫，因为如果第二位将军不能在同一时刻发动攻击，那座城市的驻军就会击退他的军队的进攻，导致他的军对被摧毁。</p><p>2）知道了这一点，第二位将军就需要发送一个确认回条：“我收到您的邮件，并会在9点的攻击。”但是，如果带着确认消息的信使被抓怎么办？所以第二位将军会犹豫自己的确认消息是否能到达。</p><p>3）于是，似乎我们还要让第一位将军再发送一条确认消息——“我收到了你的确认”。然而，如果这位信使被抓怎么办呢？</p><p>4）这样一来，是不是我们还要第二位将军发送一个“确认收到你的确认”的信息。</p><p>靠，于是你会发现，这事情很快就发展成为不管发送多少个确认消息，都没有办法来保证两位将军有足够的自信自己的信使没有被敌军捕获。</p><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/two-generals-problems.jpg" alt="img"></p><p><strong>这个问题是无解的</strong>。两个将军问题和它的无解证明首先由E.A.Akkoyunlu,K.Ekanadham和R.V.Huber于1975年在《一些限制与折衷的网络通信设计》一文中发表，就在这篇文章的第73页中一段描述两个黑帮之间的通信中被阐明。 1978年，在Jim Gray的《数据库操作系统注意事项》一书中（从第465页开始）被命名为两个将军悖论。作为两个将军问题的定义和无解性的证明的来源，这一参考被广泛提及。</p><p>这个实验意在阐明：试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。</p><p>从工程上来说，一个解决两个将军问题的实际方法是使用一个能够承受通信信道不可靠性的方案，并不试图去消除这个不可靠性，但要将不可靠性削减到一个可以接受的程度。比如，第一位将军排出了100位信使并预计他们都被捕的可能性很小。在这种情况下，不管第二位将军是否会攻击或者受到任何消息，第一位将军都会进行攻击。另外，第一位将军可以发送一个消息流，而第二位将军可以对其中的每一条消息发送一个确认消息，这样如果每条消息都被接收到，两位将军会感觉更好。然而我们可以从证明中看出，他们俩都不能肯定这个攻击是可以协调的。他们没有算法可用（比如，收到4条以上的消息就攻击）能够确保防止仅有一方攻击。再者，第一位将军还可以为每条消息编号，说这是1号，2号……直到n号。这种方法能让第二位将军知道通信信道到底有多可靠，并且返回合适的数量的消息来确保最后一条消息被接收到。如果信道是可靠的话，只要一条消息就行了，其余的就帮不上什么忙了。最后一条和第一条消息丢失的概率是相等的。</p><p> 两将军问题可以扩展成更变态的<strong>拜占庭将军问题 (Byzantine Generals Problem)</strong>，其故事背景是这样的：拜占庭位于现在土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，军队可能有叛徒和敌军间谍，这些叛徒将军们会扰乱或左右决策的过程。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，这就是拜占庭将军问题。</p><h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h4><p><a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)" target="_blank" rel="noopener">Wikipedia上的各种Paxos算法</a>的描述非常详细，大家可以去围观一下。</p><p>Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个「一致性算法」以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。从20世纪80年代起对于一致性算法的研究就没有停止过。</p><p><strong>Notes</strong>：Paxos算法是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的”La”，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。由于算法难以理解起初并没有引起人们的重视，使Lamport在八年后1998年重新发表到ACM Transactions on Computer Systems上（<a href="http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="noopener">The Part-Time Parliament</a>）。即便如此paxos算法还是没有得到重视，2001年Lamport 觉得同行无法接受他的幽默感，于是用容易接受的方法重新表述了一遍（<a href="http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">Paxos Made Simple</a>）。可见Lamport对Paxos算法情有独钟。近几年Paxos算法的普遍使用也证明它在分布式一致性算法中的重要地位。2006年Google的三篇论文初现“云”的端倪，其中的Chubby Lock服务使用Paxos作为Chubby Cell中的一致性算法，Paxos的人气从此一路狂飙。（Lamport 本人在 <a href="http://research.microsoft.com/users/lamport/pubs/pubs.html#lamport-paxos" target="_blank" rel="noopener">他的blog 中</a>描写了他用9年时间发表这个算法的前前后后）</p><p>注：Amazon的AWS中，所有的云服务都基于一个ALF（Async Lock Framework）的框架实现的，这个ALF用的就是Paxos算法。我在Amazon的时候，看内部的分享视频时，设计者在内部的Principle Talk里说他参考了ZooKeeper的方法，但他用了另一种比ZooKeeper更易读的方式实现了这个算法。</p><p>简单说来，Paxos的目的是让整个集群的结点对某个值的变更达成一致。Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以Paxos算法需要集群中的结点是单数）。</p><p>这个算法有两个阶段（假设这个有三个结点：A，B，C）：</p><p><strong>第一阶段：Prepare阶段</strong></p><p>A把申请修改的请求Prepare Request发给所有的结点A，B，C。注意，Paxos算法会有一个Sequence Number（你可以认为是一个提案号，这个数不断递增，而且是唯一的，也就是说A和B不可能有相同的提案号），这个提案号会和修改请求一同发出，任何结点在“Prepare阶段”时都会拒绝其值小于当前提案号的请求。所以，结点A在向所有结点申请修改请求的时候，需要带一个提案号，越新的提案，这个提案号就越是是最大的。</p><p>如果接收结点收到的提案号n大于其它结点发过来的提案号，这个结点会回应Yes（本结点上最新的被批准提案号），并保证不接收其它&lt;n的提案。这样一来，结点上在Prepare阶段里总是会对最新的提案做承诺。</p><p>优化：在上述 prepare 过程中，如果任何一个结点发现存在一个更高编号的提案，则需要通知 提案人，提醒其中断这次提案。</p><p><strong>第二阶段：Accept阶段</strong></p><p>如果提案者A收到了超过半数的结点返回的Yes，然后他就会向所有的结点发布Accept Request（同样，需要带上提案号n），如果没有超过半数的话，那就返回失败。</p><p>当结点们收到了Accept Request后，如果对于接收的结点来说，n是最大的了，那么，它就会修改这个值，如果发现自己有一个更大的提案号，那么，结点就会拒绝修改。</p><p>我们可以看以，这似乎就是一个“两段提交”的优化。其实，<strong>2PC/3PC都是分布式一致性算法的残次版本，Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。</strong></p><p>我们还可以看到：对于同一个值的在不同结点的修改提案就算是在接收方被乱序收到也是没有问题的。</p><p>关于一些实例，你可以看一下Wikipedia中文中的“<a href="http://zh.wikipedia.org/zh/Paxos算法#.E5.AE.9E.E4.BE.8B" target="_blank" rel="noopener">Paxos样例</a>”一节，我在这里就不再多说了。对于Paxos算法中的一些异常示例，大家可以自己推导一下。你会发现基本上来说只要保证有半数以上的结点存活，就没有什么问题。</p><p>多说一下，自从Lamport在1998年发表Paxos算法后，对Paxos的各种改进工作就从未停止，其中动作最大的莫过于2005年发表的<a href="http://research.microsoft.com/apps/pubs/default.aspx?id=64624" target="_blank" rel="noopener">Fast Paxos</a>。无论何种改进，其重点依然是在消息延迟与性能、吞吐量之间作出各种权衡。为了容易地从概念上区分二者，称前者Classic Paxos，改进后的后者为Fast Paxos。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>下图来自：Google App Engine的co-founder Ryan Barrett在2009年的google i/o上的演讲《<a href="http://snarfed.org/transactions_across_datacenters_io.html" target="_blank" rel="noopener">Transaction Across DataCenter</a>》（视频： <a href="http://www.youtube.com/watch?v=srOgpXECblk）" target="_blank" rel="noopener">http://www.youtube.com/watch?v=srOgpXECblk）</a></p><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/Transaction-Across-DataCenter.jpg" alt="img"></p><p>前面，我们说过，要想让数据有高可用性，就需要冗余数据写多份。写多份的问题会带来一致性的问题，而一致性的问题又会带来性能问题。从上图我们可以看到，我们基本上来说不可以让所有的项都绿起来，这就是著名的CAP理论：一致性，可用性，分区容忍性，你只可能要其中的两个。</p><h4 id="NWR模型"><a href="#NWR模型" class="headerlink" title="NWR模型"></a>NWR模型</h4><p><strong>最后我还想提一下Amazon Dynamo的NWR模型。这个NWR模型把CAP的选择权交给了用户，让用户自己的选择你的CAP中的哪两个</strong>。</p><p>所谓NWR模型。N代表N个备份，W代表要写入至少W份才认为成功，R表示至少读取R个备份。<strong>配置的时候要求W+R &gt; N</strong>。 因为W+R &gt; N， 所以 R &gt; N-W 这个是什么意思呢？就是读取的份数一定要比总备份数减去确保写成功的倍数的差值要大。</p><p>也就是说，每次读取，都至少读取到一个最新的版本。从而不会读到一份旧数据。当我们需要高可写的环境的时候，我们可以配置W = 1 如果N=3 那么R = 3。 这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。如果我们要求读的高效率，我们可以配置 W=N R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。</p><p>NWR模型的一些设置会造成脏数据的问题，因为这很明显不是像Paxos一样是一个强一致的东西，所以，可能每次的读写操作都不在同一个结点上，于是会出现一些结点上的数据并不是最新版本，但却进行了最新的操作。</p><p>所以，Amazon Dynamo引了数据版本的设计。也就是说，如果你读出来数据的版本是v1，当你计算完成后要回填数据后，却发现数据的版本号已经被人更新成了v2，那么服务器就会拒绝你。版本这个事就像“乐观锁”一样。</p><p>但是，对于分布式和NWR模型来说，版本也会有恶梦的时候——就是版本冲的问题，比如：我们设置了N=3 W=1，如果A结点上接受了一个值，版本由v1 -&gt; v2，但还没有来得及同步到结点B上（异步的，应该W=1，写一份就算成功），B结点上还是v1版本，此时，B结点接到写请求，按道理来说，他需要拒绝掉，但是他一方面并不知道别的结点已经被更新到v2，另一方面他也无法拒绝，因为W=1，所以写一分就成功了。于是，出现了严重的版本冲突。</p><p>Amazon的Dynamo把版本冲突这个问题巧妙地回避掉了——版本冲这个事交给用户自己来处理。</p><p>于是，Dynamo引入了Vector Clock（矢量钟？!）这个设计。这个设计让每个结点各自记录自己的版本信息，也就是说，对于同一个数据，需要记录两个事：1）谁更新的我，2）我的版本号是什么。</p><p>下面，我们来看一个操作序列：</p><p>1）一个写请求，第一次被节点A处理了。节点A会增加一个版本信息(A，1)。我们把这个时候的数据记做D1(A，1)。 然后另外一个对同样key的请求还是被A处理了于是有D2(A，2)。这个时候，D2是可以覆盖D1的，不会有冲突产生。</p><p>2）现在我们假设D2传播到了所有节点(B和C)，B和C收到的数据不是从客户产生的，而是别人复制给他们的，所以他们不产生新的版本信息，所以现在B和C所持有的数据还是D2(A，2)。于是A，B，C上的数据及其版本号都是一样的。</p><p>3）如果我们有一个新的写请求到了B结点上，于是B结点生成数据D3(A,2; B,1)，意思是：数据D全局版本号为3，A升了两新，B升了一次。这不就是所谓的代码版本的log么？</p><p>4）如果D3没有传播到C的时候又一个请求被C处理了，于是，以C结点上的数据是D4(A,2; C,1)。</p><p>5）好，最精彩的事情来了：如果这个时候来了一个读请求，我们要记得，我们的W=1 那么R=N=3，所以R会从所有三个节点上读，此时，他会读到三个版本：</p><ul><li><ul><li>A结点：D2(A,2)</li><li>B结点：D3(A,2;  B,1);</li><li>C结点：D4(A,2;  C,1)</li></ul></li></ul><p>6）这个时候可以判断出，D2已经是旧版本（已经包含在D3/D4中），可以舍弃。</p><p>7）但是D3和D4是明显的版本冲突。于是，交给调用方自己去做版本冲突处理。就像源代码版本管理一样。</p><p>很明显，上述的Dynamo的配置用的是CAP里的A和P。</p><p>我非常推大家都去看看这篇论文：《<a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf" target="_blank" rel="noopener">Dynamo：Amazon’s Highly Available Key-Value Store</a>》，如果英文痛苦，你可以<a href="http://vdisk.weibo.com/s/AKRQZMLLc1ol" target="_blank" rel="noopener">看看译文</a>（译者不详）。</p><p>（全文完）</p><p>转至 <a href="https://coolshell.cn/articles/10910.html" target="_blank" rel="noopener">https://coolshell.cn/articles/10910.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 事务 </tag>
            
            <tag> 一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相忘于江湖</title>
      <link href="/xiang-wang-yu-jiang-hu.html"/>
      <url>/xiang-wang-yu-jiang-hu.html</url>
      
        <content type="html"><![CDATA[<h1 id="相忘于江湖"><a href="#相忘于江湖" class="headerlink" title="相忘于江湖"></a>相忘于江湖</h1><p><img src="https://img.iamghf.top/v2-250781f866d4401cd039b578cc4867af_r.jpg" alt=""></p><blockquote><p>泉涸，鱼相与处于陆，相呴以湿，相濡以沫，不如相忘于江湖。与其誉尧而非桀也，不如两忘而化其道。  </p></blockquote><p>湖泊干涸了，原先在水中嬉戏的鱼都被搁浅在了陆地上。它们快要干死了，相互之间吹出湿气河护着，吐出唾沫湿润着，这是多有亲情！何等的友爱！可是谁都不愿意这样，在它们看来，与其在干涸的陆地上如此友爱亲情，还不如在江湖水中各自游走、相互忘去。与其称誉尧而谴责桀，不如把两者都忘掉而把他们的作为都归于事物的本来规律。</p><p>“相濡以沫、相忘于江湖”本意，“相濡以沫”长久以来当做了爱情美好的代名词，形容夫妻二人相扶相携、相依为命地共度患难，相知相敬地品赏平凡，相偎相依地享受温暖。没有奢华，但存质朴；没有距离，但闻呼吸；有的只是一同在困难的处境里，用微薄的力量互相帮助。</p><p>“相忘于江湖”是一种很好的境界，它代表了放弃、淡泊，有一种不计后果率性而为的坦荡心境。</p><p>“相濡以沫，不如相忘于江湖”，仿佛我们在不得已时相忘于江湖，可在不得已时真的是那么大度，那么开怀吗？能够做到彼此在一起的时候，尽量享受点滴幸福的时光；分开的时候，希望彼此抛开一切痛苦，在各自的生活轨迹上活得更好、人生更灿烂吗？我们只能活一次，在有限的生命里我们却会和太多的人相遇，然而却只有一次选择的机会，上帝没有赐于我们一双慧眼，不能轻易把情感看得清清楚楚明明白白真真切切。相遇不一定能够相爱，而相爱却又不一定能够在一起，于是我们的人生中就出现无数不断上演的“邂逅与错过”人生悲情剧。</p><p>我们总是不愿意放手。那是因为用心地爱过，舍不得放弃，如果放弃，也心有不甘。也许有人会说：爱还有另外一个名字，叫做“放弃”！却又有几人能做到？道理其实谁都明白，可依然是“每当午夜梦醒时，发现内心牵挂的依然是远方的你…”，为什么就是抓着疼痛不肯放手呢？因为人是有感情的，你会忘吗？你能忘吗？你忘得了吗？会毫无知觉吗？不能！也绝不会！</p><p>现实中的“相濡以沫”或许是为了生存的必要，或许有太多的无奈，却是令人感动的，但这种难能可贵的情感，与其说是爱情，不如说是一种心灵上的归依和情感上的依托，夫妻结婚之后，也把爱情转化为亲情了。</p><p>雪中送炭固然值得感激和回味，但是，为何一定要求对方置身于风雪之中？与其让相爱的人和自己一起受苦，不如放手让对方处在更符合天性的地方。相忘于江湖才是更高境界的大爱。成全对方，达到庄子所说的大自在境界。</p><p><img src="https://img.iamghf.top/v2-ad4a9ef1a62481f3d9b36e3124ac5eb7_r.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么南方不集中供暖？</title>
      <link href="/nan-fang-gong-nuan.html"/>
      <url>/nan-fang-gong-nuan.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么南方不集中供暖？"><a href="#为什么南方不集中供暖？" class="headerlink" title="为什么南方不集中供暖？"></a>为什么南方不集中供暖？</h1><p>作者：管亚锋</p><p>中国的集中供暖线以秦岭－淮河为界，北边的有，南边的就没有。体现到实际的建设中，一般有集中供暖的城市在城市规划中都会做供热专项规划，确定供热体制，热源，安排供热管网等。</p><p>南方的城市在规划中就没有这个专项，连规划都没有，建设的时候自然也不会考虑了。</p><p>这两年有人提出南方也需要集中供暖，我的个人观点是南方集中供暖是没必要的，也是不应该的。</p><p>首先，由于南方的城市在建设过程中一直以来都没有考虑过供热系统，供热的基础设施是几乎没有的，假如未来要集中供热，那在基础设施的建设投入上就是政府承担不了的，也是大家受不了的。</p><p>首先要重建或改建电厂，水力发电可不行，一定要火力发电烧煤的，烧出来的蒸汽才能作为热源供暖。一个热电厂还不行，在城市里还要建设若干个大型锅炉房，无数个小型锅炉房。</p><p>有了热源还不行，还要输热管网，有从地面走的，街道两边就要架设几十厘米粗的大管子，也有从地下走的，每条街道又要都开挖一遍。</p><p>街道上有了输热管了还不行，建筑里也要有，现在南方的建筑结构几乎都没考虑这个的，还要在墙体上重新架设，这一折腾就要好几十年，没人受得了的。</p><p>其次，南方集中供暖的使用效率不高。北方有的地方集中供暖的天数会达到半年之久，一般的也会有三、四个月，南方有些地区要是集中供暖，总天数会比北方少很多，花巨资做的供暖系统大部分时间是闲置的，再怎么算也是划不来的。</p><p>第三，集中供暖的浪费也是很大的，北方家庭每年采暖费一般都要三、四千，南方家庭哪有开空调花这么多钱的呢。</p><p>仇保兴曾经在公开接受采访时给出了一些触目惊心的数字：「由于供热系统设计不合理，用户室内无法自主调控，如果热了，只好开窗户调节室温，大约浪费了全部热量的 7%。</p><p>目前，办公楼、教室等公共建筑，在下班、放学以后，周末、元旦、春节以及寒假室内无人的情况下，照常供热，浪费很明显。</p><p>以华北地区为例，从 11 月 15 日到第二年的 3 月 15 日，供热期 121 天，其中节假日就有 40 天，占采暖期的 30%。也就是说，这 40 天的供热都浪费了。」</p><p>所以，南方集中供暖是没必要，也是不应该的。天冷就开开空调，不用了就关掉，既省钱又环保。不过以秦岭－淮河为界一刀切的分法是有些不妥，靠近分界线的城市也可以根据实际情况适当做一些集中供暖。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 供暖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回忆是一壶酒，待你忆时品一口</title>
      <link href="/hui-yi-shi-yi-hu-jiu-dai-ni-yi-shi-pin-yi-kou.html"/>
      <url>/hui-yi-shi-yi-hu-jiu-dai-ni-yi-shi-pin-yi-kou.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.iamghf.top/blog/20200410160548.png" alt=""><br><img src="https://img.iamghf.top/blog/20200410160646.png" alt=""><br><img src="https://img.iamghf.top/blog/20200410160721.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金庸 </tag>
            
            <tag> 武侠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>江湖仍在，何时再见</title>
      <link href="/jiang-hu-reng-zai-he-shi-zai-jian.html"/>
      <url>/jiang-hu-reng-zai-he-shi-zai-jian.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.iamghf.top//Snip20181101_5.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有意思吧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金庸武侠年表</title>
      <link href="/jin-yong-wu-xia-nian-biao.html"/>
      <url>/jin-yong-wu-xia-nian-biao.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/69bbca83gy1fwrgj14xilj20go0be0t1.jpg" alt=""><br>公元前483年 西施送入吴国；范蠡遇到阿青，阿青传越国剑士剑法。</p><p>公元前476年 越国灭掉吴国；范蠡与西施隐居，阿青离去。</p><p>527年南北朝时期，印度高僧菩提达摩来到中国，在嵩山少林寺面壁九年，创立中国禅宗。</p><p>536年 达摩逝世</p><p>554年 西魏宇文泰攻破江陵城（今荆州），梁元帝萧绎留下宝藏在天宁寺，连城诀宝藏来源于此</p><p>隋朝末年，李靖将《易筋经》中的武学奥秘，尽数领悟。</p><p>640年 侯君集攻破高昌国</p><p>694年 明教传至中土。</p><p>唐朝末叶，嘉兴剑术名家改良越女剑法。</p><p>877年 丐帮建立。</p><p>907年 唐朝灭亡</p><p>907年 耶律阿保机建立契丹</p><p>937年 段思平建立大理</p><p>936年—946年 少林寺法慧禅师练成了一指禅。</p><p>960年赵匡胤陈桥兵变，建立宋朝</p><p>1030年 慕容博出生。</p><p>1038年 西夏建立</p><p>1047年 慕容博伤黄眉僧。</p><p>1051年 扫地僧到少林寺。</p><p>1060年 萧峰出生。</p><p>1061年 雁门关外乱石谷大战。</p><p>1062年 萧远山到少林偷研武功。</p><p>1063年 丁春秋暗算师门。</p><p>1064年 慕容复出生。</p><p>1065年 波斯“山中老人”霍山，制圣火令，将平生武功精要，镌刻于圣火令之上。</p><p>1069年 虚竹出生。</p><p>1071年 段誉出生。</p><p>1072年 慕容博伤崔百泉。</p><p>1074年 阿朱出生。</p><p>1077年 慕容博诈死。</p><p>1083年 萧峰接任丐帮帮主。</p><p>1090年 鸠摩智单挑天龙寺六僧。</p><p>1091年 萧峰离开丐帮。</p><p>1092年 聚贤庄大战。</p><p>1093年 萧峰助耶律洪基平定皇太叔之乱（历史上为1063年）；无崖子去世；虚竹接任逍遥派掌门，同年被西夏招为驸马；少林寺门外混战；扫地僧讲经说法。</p><p>1094年 大理段正明禅位侄子段誉；萧峰自尽。</p><p>1103年 岳飞出生。</p><p>1112年 王重阳出生。</p><p>1115年 完颜阿骨打建立金国，黄裳雕版印行万寿道藏。</p><p>1120年 黄裳向明教的高手挑战。</p><p>1125年 金国灭辽</p><p>1127年 金国灭北宋</p><p>1127年—1130年 少林寺灵兴禅师花了三十九年练成了一指禅。</p><p>1140年 独孤求败创独孤九剑第九式破气式。</p><p>1141年 岳飞于狱中撰写《武穆遗书》。</p><p>1158年 段智兴出生。</p><p>1162年 柯镇恶（江南七怪之首）出生。</p><p>1163年 周伯通出生。</p><p>1164年 黄裳完成九阴真经。洪七公出生。</p><p>1168年 欧阳锋出生。</p><p>1170年 独孤求败郁寂而终。</p><p>1171年 黄药师出生。</p><p>1173年 曲灵风出生。</p><p>1178年 裘千仞出生。</p><p>1183年 金轮法王出生</p><p>1184年 朱子柳出生。</p><p>1186年 陈玄风欧阳克出生。</p><p>1190年 火工头陀于少林寺中大开杀戒。</p><p>1196年 王重阳再入古墓，于棺上刻下部分九阴真经，并留“玉女心经，欲胜全真；重阳一生，不弱于人” 的文字，后某日无名僧与王重阳斗酒参阅九阴创九阳；南宋宦官在宫中创葵花宝典。</p><p>1200年 第一次华山论剑。</p><p>1203年 重阳真人拜访段皇爷，废了欧阳峰20年蛤蟆功；王重阳仙逝。</p><p>1205年 郭靖出生</p><p>1206年 成吉思汗建立蒙古汗国</p><p>1206年 裘千仞伤瑛姑幼子。</p><p>1208年 黄蓉出生。</p><p>1222年 小龙女出生。</p><p>1225年 穆念慈比武招亲。</p><p>1226年 杨过出生。</p><p>1227年 第二次华山论剑；蒙古灭西夏；成吉思汗去世。</p><p>1234年 金国灭于蒙古与南宋联合进攻</p><p>1235年 明教高手参考五代十国时期武林高手慕容龙城的“斗转星移”，创出威力更大的“乾坤大挪移”神功，遂为镇教之宝。</p><p>1243年 洪七公、欧阳峰去世。</p><p>1243年 杨过小龙女双剑合壁初试锋芒挫败金轮法王；杨过学弹指神通。</p><p>1243年 郭襄出生；杨过断臂，初入独孤求败剑冢。</p><p>1247年 张三丰出生。</p><p>1253年 蒙古灭大理国</p><p>1257年 明教石教主圣火令为丐帮所夺。</p><p>1259年 杨过飞石击毙蒙哥大汗；第三次华山论剑。</p><p>1262年 郭襄游少林。</p><p>1271年 忽必烈改蒙古国号为“大元”</p><p>1273年 一代大侠郭靖和黄蓉战死襄阳。</p><p>1276年 蒙古攻进南宋都城临安</p><p>1296年 金毛狮王谢逊出生。</p><p>1317年 谢逊离开师父成昆，加入明教。</p><p>1318年 武当六弟子殷梨亭出生。</p><p>1323年 成昆杀谢逊一家。</p><p>1336年 谢逊及张翠山夫妇至冰火岛。</p><p>1337年 张三丰九十大寿；张无忌出生。</p><p>1338年 元兵剿灭袁州明教义军，常遇春、彭莹玉侥幸逃脱。</p><p>1339年 周芷若出生。</p><p>1340年 汝阳王女儿敏敏特穆尔出生，元帝封其“绍敏郡主”。</p><p>1341年 小昭出生。</p><p>1346年 张三丰百岁大寿；张翠山殷素素夫妇自尽。</p><p>1351年 张无忌得九阳神功。</p><p>1357年 六大派围攻光明顶；张无忌任明教教主；张三丰首创太极神功。</p><p>1358年 小昭远走波斯。</p><p>1359年 少林屠狮英雄会；白眉鹰王殷天正去世。</p><p>1360年 张无忌隐退，光明左使杨逍继任为明教第三十五代教主。</p><p>1365年 明教光明右使范遥参考北宋年间的两大神功“北冥神功”及“化功大法”，创出威力极大更为歹毒的“吸星大法”。</p><p>1368年 明朝灭元朝。</p><p>1372年 杨逍去世，明教内部争权夺力，陷入内乱，加上外部朱元璋打压，明教日渐式微。教中高手改组明教，遂为“日月神教”。</p><p>1400年 莆田少林寺得葵花宝典。</p><p>1401年 岳肃蔡子峰偷录葵花宝典；渡元禅师习辟邪剑法。</p><p>1402年 华山派分气宗剑宗。</p><p>1406年 日月神教十长老破五岳剑派剑法。</p><p>1420年 日月教袭武当山，张三丰手抄一部《太极拳经》和青年时佩带的真武剑被抢。</p><p>1458年 武当派开山祖师张三丰仙逝，享年212岁。（据《古今太极拳谱及源流阐秘》李师融先生的考证）</p><p>1469年 令狐冲出生。</p><p>1479年 华山派气宗剑宗之争。</p><p>1486年 任盈盈出生。</p><p>1493年 东方不败篡日月神教教主之位；任我行被囚地牢。</p><p>1503年 余沧海灭福威镖局。</p><p>1504年 令狐冲学得独孤九剑。</p><p>1505年 任我行重夺日月神教教主。</p><p>1506年 任我行去世。</p><p>1509年 令狐冲任盈盈喜结良缘。</p><p>1610年 金蛇郎君夏雪宜惨遭灭门之祸。</p><p>1612年 金蛇郎君夏雪宜得到云南五仙教的镇教“三宝”。</p><p>1623年 袁承志出生。</p><p>1643年 袁承志被推举为七省江湖首领，同年率众人挫毁西洋红夷大炮。</p><p>1644年 袁承志助阿九挫败成王与曹化淳篡位阴谋；李自成攻入北京，明亡；吴三桂降清；李岩夫妇自杀身亡。同年，袁承志、夏青青率亲友、部属避居海外，即今南洋新加坡之地。</p><p>1645年 仲夏，在清兵追击下，李自成率主力部队，败退至湖北通城县。一日，李自成带少数亲兵，在县南查勘地形，在九宫山玄帝庙中，因打盹疏忽，被姜姓农民误杀，终年三十九岁。</p><p>1655年 韦小宝出生在扬州妓院。</p><p>1669年 康熙韦小宝擒鳌拜。</p><p>1670年 韦小宝出任天地会青木堂香主。</p><p>1698年 武当派掌门陆菲青出生。</p><p>1711年 雍正帝与海宁陈家掉包刚出生的儿女，爱新觉罗弘历原来是海宁陈家之子。</p><p>1733年 陈家洛出生。</p><p>1735年 爱新觉罗·弘历登基，年号乾隆。</p><p>1753年腊月，苗人凤和胡一刀决战；胡斐出生。</p><p>1758年 红花会在六和塔囚禁乾隆，回部霍青桐力排众议，大败清军主力。</p><p>1759年 香香公主在北京自杀。</p><p>1780年三月十五日，苗人凤和胡斐决战。</p><p>1924年二月六日，金庸出生</p><p>2018年十月三十号，金庸去世</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金庸 </tag>
            
            <tag> 武侠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灌篮高手</title>
      <link href="/guan-lan-gao-shou.html"/>
      <url>/guan-lan-gao-shou.html</url>
      
        <content type="html"><![CDATA[<h1 id="灌篮高手"><a href="#灌篮高手" class="headerlink" title="灌篮高手"></a>灌篮高手</h1><p>这可能是这两天最热血的一条新闻了：</p><p>时隔 28 年，今年再版的《灌篮高手》，终于在前天（8 月 28 日）公开了所有新版封面。</p><p>一共 20 张，都是原作者井上雄彦亲笔画的。他说：</p><p>“我有点想见这些家伙了。”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090526.jpg" alt=""></p><p>有个网友疯狂转发了 20 多条，说自己已经变成拖家带口的老男人，有生之年还能看到这些画，直接泪崩了。</p><p>28 年了，这些热血、青春的面孔，又一次点燃了一大批 80 后、90 后。</p><p>90 年代初，国内没有引进 NBA 也没有姚明，很多男孩的篮球梦是从《灌篮高手》开始。</p><p>女孩们都为流川枫和仙道痴迷，觉得会打篮球的男生很帅。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090543.gif" alt=""></p><p>《灌篮高手》的贴吧有 2000 多万个帖子，每隔几分钟都会有新的留言讨论。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090551.jpg" alt=""></p><p>虎扑上到现在还有人在分析灌篮高手的战术。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090604.jpg" alt=""></p><p>快 30 年了，很多人至今还保留着那时候买的画册、海报和明信片。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090611.jpg" alt="image"></p><p>今年早些时候有篇文章刷了屏，只因为一句话：</p><p>“你喜欢的那个赤木晴子已经奔五了。”</p><p>人们好像被突然提醒：追《灌篮高手》的你们也快老了吧。</p><p>但，事实证明，热血这种东西是不会冷的。</p><p>新装版的漫画在日本上市一周，就卖到脱销。销量直接压过常年位居榜首的《海贼王》。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090618.jpg" alt=""><br><img src="https://img.iamghf.top/blog/2019-12-26-090647.jpg" alt=""></p><p>日本《朝日新闻》头版也是樱木花道的特写。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090657.jpg" alt=""></p><p>日本街头还出现了很多《灌篮高手》的巨幅广告牌，光看一眼就让人瞬间回到青春时代。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090706.jpg" alt=""></p><p>流川枫。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090714.jpg" alt=""></p><p>樱木花道。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090723.jpg" alt="image"></p><p>赤木刚宪。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090733.jpg" alt=""></p><p>三井寿。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090739.jpg" alt=""></p><p>宫城良田。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090744.jpg" alt=""></p><p>这些场面真热血，热血到几乎所有人都忽略了它是一个失败的故事。</p><p>这群被人贴在墙上、放在心里二三十年的人，其实真的很普通。</p><p>湘北是一直被瞧不起的篮球队，放到全国，队员们也根本算不上什么真正专业化的篮球天才。</p><p>他们拼尽全力想咸鱼翻身，却在全国大赛的第 3 轮就被淘汰了。</p><p>天天喊着的“全国制霸” 的梦想，到最后也没实现。</p><p>28 年了，多少人把这群“废柴”当成自己的精神偶像，用那么大的阵仗去纪念。</p><p>二</p><p>在你我的生活中，《灌篮高手》里的每个人都是热血励志的明星。</p><p>但事实上，在漫画里，湘北篮球队一开始就是个连名字都会被叫错的“废柴联盟”。</p><p>在县级选拔里几乎就没进过第二轮，被很多对手当做三流球队。</p><p>主角大半都是问题儿童。</p><p>顶着“篮球天才”光环的流川枫，是个不爱跟人说话的“自闭少年”，出场第一集就跟人打架打得满脸血。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090750.jpg" alt=""></p><p>樱木花道，头脑简单四肢发达的不良少年，脾气暴，也爱打架，动不动就拿头撞人。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090756.gif" alt=""></p><p>周围的所有人对他的态度都是不期待、不指望，别捣乱就好了。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090802.jpg" alt=""></p><p>三井寿也很可怕，初中时还带队拿过比赛冠军，但因为一次受伤就一蹶不振，留长发混社会，很像以前班上坐在最后一排那种自暴自弃的小混混。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090810.jpg" alt=""></p><p>队长赤木刚宪稍微好一点，有班干部的严厉和责任感，小学就有“称霸全国”的梦想，但直到高三还没实现。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090820.jpg" alt=""></p><p>知乎上有个回答说得很全面：</p><p>“我们认为湘北是全明星，只因为他们是主角，我们所看到的篇幅，他们的故事占据了绝大多数，所以我们势必会觉得他们比其他的球员要【优秀】。”</p><p>这样一个球队，训练不到两个月就放话要闯进全国联赛，制霸全国。</p><p>在别人看来，就像年级倒数的差生，在高考前两个月喊着要考清华一样。</p><p>别的队伍见到他们，笑都笑死了：</p><p>你们队里就算有优等生又怎么样？这种傻子制霸全国，怎么可能啊？</p><p>还好，他们都有一个共同目标：我要打篮球。</p><p>三</p><p>也正是因此，才让他们最终闯进全国大赛显得像个奇迹。</p><p>“如果我们拼命努力，却只能到达别人的起点，那我们为什么还要努力？”</p><p>《灌篮高手》里那些最热血的瞬间，给了所有人答案。</p><p>赤木，一个输过很多次的人，每天都在为赢的那一天做准备。</p><p>每天睡觉前我都会想象今天的情景，我们湘北跟神奈川县的王者海南附中，争夺全国大赛参赛权的一战。每个晚上，脑中都描绘着这个场景，从一年级开始，直到今天。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090859.jpg" alt=""></p><p>自暴自弃，没有勇气重新开始的三井，想起安西教练曾经告诉他的话：</p><p>“直到最后一刻也不能放弃希望，一但放弃的话，比赛就结束了。”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090907.jpg" alt=""></p><p>那一刻他再也忍不住自己的热泪，哭着说：</p><p>“教练，我……我想打篮球！”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090912.gif" alt=""></p><p>什么都不会，却老自称天才的樱木花道，在看到比自己强大得多的人，比自己更努力时，突然被一巴掌打醒。第二天一早就开始去训练。</p><p>“不要想着在场上出风头，必须每天脚踏实地去练习才行。”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090920.jpg" alt=""></p><p>一群咸鱼，为了一个目标拼了命往前冲，跑得乱七八糟摔得头破血流，最后居然跑赢了一次——打进了全国大赛。</p><p>这是他们最难的一场。比赛还没结束，湘北的士气已经摇摇欲坠，此时樱木用纸卷成大喇叭高喊：我要打倒山王！</p><p>比赛中樱木脊背受伤，教练告诉他，如果你继续上场，可能未来都无法打球了。</p><p>樱木说：“老头子，你最光辉的时刻是何时？是全日本时代吗？………而我，就是现在了！”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090926.jpg" alt=""></p><p>这场比赛，他们赢了。</p><p>那一刻，一直是死对头的樱木花道和流川枫有了第一次击掌，所有人都忘不掉。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090932.jpg" alt=""></p><p>但谁也没想到接下来的结局是这样的：</p><p>漫画的前一页，是对手失败后失落的背影，和湘北队赢了比赛后的全家福。</p><p>而下一页，他们就失败了——</p><p>8月4日 全国大赛第四天：湘北因体力不支不敌爱和，未能晋级全国 8 强。</p><p>按照一般的励志“套路”，主角倒下再多次，都会重新赢回来。</p><p>可《灌篮高手》的故事就这样戛然而止，这就是结局了：</p><p>他们还是没拿到全国冠军，他们的梦想还是破灭了。</p><p>很多人给作者井上雄彦写信，说这不是真的，要他改结局。</p><p>但他的回应是：青春就是不完美的。</p><p>有些时候就算你拼尽全力，还是会输掉。</p><p>四</p><p>28 年后我们依然把灌篮高手奉为经典，其实就是因为这个不够完满的结局。</p><p>如果他们赢到最后，那是个童话。</p><p>只有他们失败了，才叫真正的励志。</p><p>前段时间刷屏的一个故事，几乎是湘北的现实版重现。</p><p>日本一所来自偏远学校、没事会养猪养鸡的棒球队，奇迹般打进了全国总决赛，距离上次闯进决赛，隔了 103 年。</p><p>决赛上，他们的对手是春季冠军，两队的差距就像猫对老虎一样。</p><p>如果奇迹继续，他们肯定是赢了。</p><p>但最后 13-2，压倒性地败了。被打败的球员们互相拥抱，痛痛快快落了泪。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090939.gif" alt=""></p><p>我想起《灌篮高手》的最后一页，球队的全家福上，写着：</p><p>使尽全力来对抗山王的湘北，在第三回对爱和学院时，输得一塌糊涂。</p><p>但他们每个人都依然笑得那么开心、满足。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090944.jpg" alt=""></p><p>如果我们拼命努力，却只能到达别人的起点，那我们为什么还要努力？</p><p>是为了结束后，你可以问心无愧地说：我尽力了，真的尽了全力了。</p><p>不管你多么热爱，多么渴望，不管你付出多少汗水和心血，有时候，梦想还是会破灭。</p><p>这才是《灌篮高手》最后想要告诉你的事。</p><p>五</p><p>这部动漫在现实里连载了 6 年，但在他们的人生里，其实只有短短四个月。</p><p>后来，井上雄彦在一个学校的黑板上画了一段续篇，讲的是全国大赛十日后。</p><p>队伍散掉了。</p><p>赤木高三，跟目暮一起退部备考。</p><p>樱木在疗养院修养，还没追到晴子，背伤也还没好起来。</p><p>流川枫入选了日本青年队，依然想去美国，在学英语。</p><p>宫城当上新队长，三井继续为冬季赛努力。</p><p>他们曾经的劲敌鱼柱，毕业后去当了厨师。</p><p>28 年后，你会发现，你的现在，就是《灌篮高手》的结局。</p><p>他们接下来的人生很可能跟你一样，年少的梦想过了就过了，会按部就班地考大学、上班、结婚生子，很少再上球场，在各种事情上被别人吊打，未来很可能会有更多失败。</p><p>但他们总会在某个时刻重新提醒你，点燃你——</p><p>明天很可能不会更好，最后很可能会失败，还是要不停不停地向前走。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090950.jpg" alt=""></p><p>有个网友说，在东京买东西银座播放这首歌，一群叔叔辈的霓虹人全都跟着唱了起来。</p><p>还有个年纪很小的男生，有次偷偷发现他爸在电脑面前看哭了。</p><p>一个读者转行做广告，每天改二十几次广告方案。一丧气就幻想自己是第一控球后卫宫城良田，总有一天会“让甲方跪着叫爸爸”。</p><p>更年轻的时候，我们喜欢讨论谁输谁嬴。</p><p>但现在，我们已经接受了梦想很可能会破灭。</p><p>想认输的时候，我会打开《灌篮高手》。</p><p>22 年前那场比赛结束了，但人生的比赛还没完呢。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090956.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漫画 </tag>
            
            <tag> 灌篮高手 </tag>
            
            <tag> 樱木花道 </tag>
            
            <tag> 流川枫 </tag>
            
            <tag> 篮球 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>find Permission denied</title>
      <link href="/findpermissiondenied.html"/>
      <url>/findpermissiondenied.html</url>
      
        <content type="html"><![CDATA[<h1 id="find-Permission-denied"><a href="#find-Permission-denied" class="headerlink" title="find Permission denied"></a>find Permission denied</h1><p>mac下执行find命令去查找时会出现满屏的Permission denied  </p><pre><code>find / -name &quot;keywords&quot;</code></pre><p>哪怎样阻止这些Permission denied信息呢？解决方法如下：</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li><p>管理员权限执</p><pre><code>sudo find / -name &quot;keyword&quot; -print</code></pre></li></ul><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ul><li><p>丢弃错误输出</p><pre><code>find / -name &quot;keyword&quot; -print 2&gt;/dev/null</code></pre></li></ul><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><ul><li><p>过滤 Permission denied 信</p><pre><code>find / -name &quot;keyword&quot; -print 2&gt;&amp;1 | fgrep -v &quot;Permission denied&quot;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> linux </tag>
            
            <tag> find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酒店网络折腾</title>
      <link href="/jiu-dian-wang-luo-zhe-teng.html"/>
      <url>/jiu-dian-wang-luo-zhe-teng.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络折腾"><a href="#网络折腾" class="headerlink" title="网络折腾"></a>网络折腾</h1><p>出差在外，在酒店休息，无聊准备看下视频，没带电脑电源，只能选择电视。然而酒店电视又不能连网。这点小问题怎么能难倒机智的我。(^_^)</p><ul><li>先登录酒店Wi-Fi ，发现还要输手机验证码验证。bingo 这应该就是电视不能连网的原因了，电视能连Wi-Fi，但不能进行验证。</li><li>简单的设置电视连Wi-Fi已经行不通，换个思路先尝试去登陆下管理界面。</li><li>酒店使用了一个网关，一个机顶盒。网关上有账号与密码，登陆提示密码错误。怀疑是被管理人员修改了密码，尝试去网上搜索超级账号，都用不了。</li><li>难道已经没折了吗？（加一个网线应该就可以了，可身边没有多余网线）再仔细检查了网关和机顶盒，发现机顶盒上也有账号密码，大胆猜测Wi-Fi是由机顶盒提供的。</li><li>输入机顶盒账号密码，成功登进管理界面。</li><li>查看相关网络选项，发现有机顶盒创建了两个Wi-Fi，一个是隐藏的，一个是现在正连的。</li><li>正连的Wi-Fi 没有修改的选项，估计是有更高级的账号来开启。难倒这道门也关闭了吗？</li><li>不死心，又仔细检查 发现了个Wi-Fi认证里有个白名单，自己刚刚连接的设备已经在白名单里了。</li><li>大胆猜测在输入验证码后，会触发相关机制加入白名单，so 将电视的mac手工加入白名单</li><li>重启完设备，发现电视还是不能联网。问题出在哪呢？</li><li>再次登入管理界面，发现没有给电视分配ip地址，问题可能出现在这。</li><li>手工给电视分配ip</li><li>重启设备，电视终于连上网了，可以愉快的看视频了。</li></ul><p><strong>后记：</strong></p><ul><li>发现有人在蹭网，这显然不能忍。启用mac白名单过滤，把自己的设备加入白名单，将其他人都拦到门外。出门在外，网络安全还是要已最坏的恶意猜测他人，先小人后君子。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dokuwiki中文乱码</title>
      <link href="/dokuwiki-zhong-wen-luan-ma.html"/>
      <url>/dokuwiki-zhong-wen-luan-ma.html</url>
      
        <content type="html"><![CDATA[<h1 id="Dokuwiki-中文乱码"><a href="#Dokuwiki-中文乱码" class="headerlink" title="Dokuwiki 中文乱码"></a>Dokuwiki 中文乱码</h1><blockquote><p>在创建页面的时候，发现在网页端使用中文文字创建成功后，在本地服务器本机的文件夹<br>Dokuwiki\data\pages 可以看到该文件名是使用%数字%字母%等的形式显示出来，这对于文件的本地存档是很不方便的。 </p></blockquote><p><strong>解决方法</strong><br>主要修改2个地方:  </p><ol><li>在服务器机子上 dokuwiki\conf\local.php<br>在最后一行加上： <pre><code>$conf[‘fnencode’]==’GB2312’; #注意分号不能少。 </code></pre></li><li>在服务器机子上 dokuwiki\inc\pageutils.php<br>修改两个函数：utf8_encodeFN 和utf8_decodeFN  </li></ol><pre><code>function utf8_encodeFN($file,$safe=true){    global $conf;    if($conf[&#39;fnencode&#39;] == &#39;utf-8&#39;) return $file;    if($safe &amp;&amp; preg_match(&#39;#^[a-zA-Z0-9/_\-\.%]+$#&#39;,$file)){        return $file;    }    if($conf[&#39;fnencode&#39;] == &#39;safe&#39;){        return SafeFN::encode($file);    }     /*    #添加if判断开始    if ($conf[&#39;fnencode&#39;]==&#39;gb2312&#39;){        return iconv(&#39;UTF-8&#39;,&#39;GB2312&#39;,$file);    }    # if判断结束    $file = urlencode($file);    $file = str_replace(&#39;%2F&#39;,&#39;/&#39;,$file);    */    return $file;}</code></pre><pre><code>function utf8_decodeFN($file){    global $conf;    if($conf[&#39;fnencode&#39;] == &#39;utf-8&#39;) return $file;    if($conf[&#39;fnencode&#39;] == &#39;safe&#39;){        return SafeFN::decode($file);    }    /*    #添加该 if判断开始    if ($conf[&#39;fnencode&#39;]==&#39;gb2312&#39;){        return iconv(&#39;GB2312&#39;,&#39;UTF-8&#39;,$file);    }    #if判断结束    return urldecode($file);    */    return $file;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DokuWiki </tag>
            
            <tag> Wiki </tag>
            
            <tag> 中文乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贵州工程快速搭建</title>
      <link href="/gui-zhou-gong-cheng-kuai-su-da-jian.html"/>
      <url>/gui-zhou-gong-cheng-kuai-su-da-jian.html</url>
      
        <content type="html"><![CDATA[<p>#贵州工程快速搭建</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>eclipse</strong>  Version: Oxygen Release (4.7.0)<br><strong>代码下载</strong><br>svn ：<br><strong>jetty插件安装</strong><br>安装eclipse jetty插件<br><img src="https://img.iamghf.top/eclipse-jetty-plugsSnip20180822_29.png" alt="jetty"></p><h2 id="创建java-工程"><a href="#创建java-工程" class="headerlink" title="创建java 工程"></a>创建java 工程</h2><p>new-&gt;java project </p><h2 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h2><p>导入src,config,csfwvm,html,lib文件夹<br><img src="https://img.iamghf.top/Snip20180822_30.png" alt="import file"></p><h2 id="设置build-path"><a href="#设置build-path" class="headerlink" title="设置build path"></a>设置build path</h2><p>添加lib文件夹里的jar包<br><img src="https://img.iamghf.top/build-pathSnip20180822_31.png" alt="build path"></p><h2 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h2><p>打开debug Configurations<br><img src="https://img.iamghf.top/debug-configSnip20180822_32.png" alt="debug configurations"></p><p>新增jetty app<br><img src="https://img.iamghf.top/debug-jettySnip20180822_33.png" alt="debug-jetty"></p><p>大功告成！</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>问题一：</strong>  </p><blockquote><p>java.lang.NoClassDefFoundError: org/apache/juli/logging/LogFactory  </p></blockquote><p>引入tomcat根目录bin中的tomcat-juli.jar</p><p><strong>问题二：</strong></p><blockquote><p>java.lang.ClassCastException: org.apache.tomcat.SimpleInstanceManager cannot be cast to org.apache.tomcat.InstanceManager </p></blockquote><p>检查tomcat的jar包是否冲突</p><p><strong>问题三：</strong></p><blockquote><p>java.lang.NoSuchMethodError: org.apache.tomcat.JarScanner.scan(Ljavax/servlet/ServletContext;Ljava/lang/ClassLoader;Lorg/apache/tomcat/JarScannerCallback;Ljava/util/Set;)V</p></blockquote><p>jar包冲突，删除重复jar包 </p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贵州工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 程序性能排查</title>
      <link href="/cheng-xu-xing-neng-pai-cha.html"/>
      <url>/cheng-xu-xing-neng-pai-cha.html</url>
      
        <content type="html"><![CDATA[<p>#java 程序性能排查<br>最近服务器频繁告警，找个时间排查了下问题。</p><h2 id="使用top命令"><a href="#使用top命令" class="headerlink" title="使用top命令"></a>使用top命令</h2><p><img src="https://img.iamghf.top/Snip20180821_23.png" alt="linux top"></p><h2 id="查看线程情况"><a href="#查看线程情况" class="headerlink" title="查看线程情况"></a>查看线程情况</h2><p>命令： <strong>ps p pid -L -o pcpu,pmem,pid,tid,time,tname,cmd</strong><br><img src="https://img.iamghf.top/Snip20180821_24.png" alt="java 线程"></p><h2 id="jstack-查看堆栈"><a href="#jstack-查看堆栈" class="headerlink" title="jstack 查看堆栈"></a>jstack 查看堆栈</h2><p>首先要将tid转换成16进程<br>命令 <strong>printf “%x\n” pid</strong><br><img src="https://img.iamghf.top/Snip20180821_25.png" alt="printf"></p><p>命令 <strong>jstack -l pid &gt; tmp.log</strong><br>再在临时文件中搜索tid对应线程的相关信息</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python格言</title>
      <link href="/python-ge-yan.html"/>
      <url>/python-ge-yan.html</url>
      
        <content type="html"><![CDATA[<p>#python</p><blockquote><p><strong>The Zen of Python</strong>  - Tim Peters </p><p>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one– and preferably only one –obvious way to do it.<br>Although that way may not be obvious at first unless you’re Dutch.<br>Now is better than never.<br>Although never is often better than <strong>right</strong> now.<br>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea — let’s do more of those!  </p></blockquote><h2 id="翻译："><a href="#翻译：" class="headerlink" title="翻译："></a>翻译：</h2><p>美丽优于丑陋。<br>清楚优于含糊。<br>简单优于复杂。<br>复杂优于繁琐。<br>平坦优于曲折。<br>宽松优于密集。<br>重要的是可读性。<br>特殊的案例不足以特殊到破坏规则。<br>尽管实践可以打破真理。<br>错误却不可置之不理。<br>除非另有明确要求。<br>面对模棱两可，拒绝猜测。<br>总会有一个 —— 最好是只有一个 —— 显而易见的方式来明辨。<br>哪怕这种方式在开始的时候可能并不明显 —— 除非你是荷兰人。<br>现在有比没有好。<br>尽管没有经常好于现在。<br>如果如何实现很难被解释清楚，那么这个想法就是一个坏想法。<br>如果如何实现可以被很好的解释，那么这是一个好想法。<br>命名空间就是一个非常好的想法 —— 让我们在这方面多做些工作吧!  </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/git-chang-yong-ming-ling.html"/>
      <url>/git-chang-yong-ming-ling.html</url>
      
        <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><p><strong>mkdir</strong>  创建目录<br><strong>pwd</strong>    显示当前目录的路径。<br><strong>git init</strong> 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。<br><strong>git add</strong> 把xx文件添加到暂存区去。<br><strong>git commit -m “XX”</strong> 提交文件 –m 后面的是注释。<br><strong>git status</strong> 查看仓库状态<br><strong>git diff XX</strong>     查看XX文件修改了那些内容<br><strong>git log</strong>     查看历史记录<br><strong>git reset –hardHEAD^</strong>  或者gitreset–hardHEAD<del>回退到上一个版本(如果想回退到100个版本，使用gitreset–hardHEAD</del>100)<br><strong>cat XX</strong>     查看XX文件内容<br><strong>git reflog</strong>     查看历史记录的版本号id<br><strong>git checkout–XX</strong>     把XX文件在工作区的修改全部撤销。<br><strong>git rm XX</strong>     删除XX文件<br><strong>git remote add origin XXX</strong>     关联一个远程库xxx<br><strong>git push -u origin master</strong>     把当前master分支推送到远程库(-u第一次要用以后不需要)<br><strong>git clone XXX</strong>     从远程库中克隆<br><strong>git check out -b dev</strong>     创建dev分支并切换到dev分支上<br><strong>git branch</strong>     查看当前所有的分支<br><strong>git checkout master</strong>     切换回master分支<br><strong>git merge dev</strong>     在当前的分支上合并dev分支<br><strong>git branch -d dev</strong>     删除dev分支<br><strong>git branch name</strong>     创建分支<br><strong>git stash</strong>     把当前的工作隐藏起来等以后恢复现场后继续工作<br><strong>git stash list</strong>     查看所有被隐藏的文件列表<br><strong>git stash apply</strong>     恢复被隐藏的文件，但是内容不删除<br><strong>git stash drop</strong>     删除文件<br><strong>git stash pop</strong>     恢复文件的同时也删除文件<br><strong>git remote</strong>     查看远程库的信息<br><strong>git remote -v</strong>     查看远程库的详细信息<br><strong>git push origin master</strong>     Git会把master分支推送到远程库对应的远程分支上  </p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透方法</title>
      <link href="/nei-wang-chuan-tou-fang-fa.html"/>
      <url>/nei-wang-chuan-tou-fang-fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="内网穿透方法"><a href="#内网穿透方法" class="headerlink" title="内网穿透方法"></a>内网穿透方法</h1><h2 id="nat123"><a href="#nat123" class="headerlink" title="nat123"></a>nat123</h2><p>描述：非网站映射或者全端口映射都可以实现，非网站映射可以单独在虚拟机安装服务就行，但是速度不理想。免费版的全端口映射（P2P）可以实现点到点的访问，但是两端都要安装客户端，免费版在手机不可使用。属于商业软件，完全闭源。</p><h2 id="teamviewer"><a href="#teamviewer" class="headerlink" title="teamviewer"></a>teamviewer</h2><p>描述：是一种国外的远程控制软件，免费版已经功能很强大，支持win、Linux、iOS、安卓客户端。服务端就使用国外的服务器，速度中等。属于商业软件，完全闭源。</p><h2 id="向日葵"><a href="#向日葵" class="headerlink" title="向日葵"></a>向日葵</h2><p>描述：跟teamviewer原理差不多，但创始人是中国人，服务器也在中国，客户端包涵PC和手机端。实际使用体验上，感觉速度并不稳定，时好时坏。属于商业软件，完全闭源。</p><h2 id="ZeroTier"><a href="#ZeroTier" class="headerlink" title="ZeroTier"></a>ZeroTier</h2><p>描述：虚拟局域网。就是通过一个公共的服务器，建立一个虚拟局域网，让家里电脑和公司电脑同处于一个虚拟局域网，然后通过分配到的虚拟局域网ip进行连接。两端都需要安装客户端。服务器在国外，响应不理想。项目的服务端没有开源，客户端是开源的。</p><h2 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h2><p>描述：主要用途是给网站或者安装开发提供部署环境，但是也同样可以用来进行端口转发。除了官方提供的服务之外，作者也放出了源代码，国内有好心的小伙伴也有自行搭建服务端供大家使用的。建议可以找服务器是在自己地区附近的，响应速度会相对快很多。</p><h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>描述：原理与ngrok是相同的，但服务端需要自己搭建，由于该项目是完全开源的，所以代码安全性较高，目前自用感觉不错，前提是服务端速度足够。</p><h2 id="n2n"><a href="#n2n" class="headerlink" title="n2n"></a>n2n</h2><p>项目官网：<a href="https://github.com/ntop/n2n" target="_blank" rel="noopener">https://github.com/ntop/n2n</a></p><p>描述：n2n的原理与ZeroTier相似，但是n2n的中央节点服务端是需要自己搭建的，而ZeroTier的服务端是官网提供的。如果中央节点的服务端速度足够，那么速度相当快！</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>这个ssh就是Linux中的SSH，其实SSH也具有端口映射的功能，可以实现与nat123相似的功能，前提需要一台自己的服务器。</p><h2 id="NPS"><a href="#NPS" class="headerlink" title="NPS"></a>NPS</h2><p>项目官网：<a href="https://github.com/cnlh/nps/" target="_blank" rel="noopener">https://github.com/cnlh/nps/</a></p><p>类似frp，但文档质量高于frp，代码成熟度高于frp，如果想长期使用内网穿透建议使用这个。</p><blockquote><p>一款轻量级、功能强大的内网穿透代理服务器。支持tcp、udp流量转发，支持内网http代理、内网socks5代理，同时支持snappy压缩、站点保护、加密传输、多路复用、header修改等。支持web图形化管理，集成多用户模式。</p></blockquote><h2 id="Tinc"><a href="#Tinc" class="headerlink" title="Tinc"></a>Tinc</h2><p>项目官网：<a href="https://www.tinc-vpn.org/" target="_blank" rel="noopener">https://www.tinc-vpn.org/</a></p><p>与N2N、PeerVPN以及ZeroTier等属于一类，服务端可以自己搭建，官网介绍是一旦连接成功后，就可以不需要走服务器流量，而是走P2P。搭建起来难度虽不大，但自己尝试时总是配置失败，可能是英文文档没有看明白吧。</p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> NAT </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用</title>
      <link href="/git-shi-yong.html"/>
      <url>/git-shi-yong.html</url>
      
        <content type="html"><![CDATA[<h1 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h1><h2 id="创建github账户"><a href="#创建github账户" class="headerlink" title="创建github账户"></a>创建github账户</h2><p>略</p><h2 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><pre><code>1. git init //初始化仓库2. git add .(文件name) //添加文件到本地仓库3. git commit -m &quot;first commit&quot; //添加文件描述信息4. git remote add origin + 远程仓库地址 //链接远程仓库，创建主分支5. git pull origin master // 把本地仓库的变化连接到远程仓库主分支6. git push -u origin master //把本地仓库的文件推送到远程仓库</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
