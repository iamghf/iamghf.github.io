<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BurpSuite破解</title>
      <link href="/burpsuite-po-jie.html"/>
      <url>/burpsuite-po-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="BurpSuite-破解"><a href="#BurpSuite-破解" class="headerlink" title="BurpSuite 破解"></a>BurpSuite 破解</h1><p>最近系统暴露了毕竟多的安全问题，有必要在安全方法补补课，搞个BurpSuite先学习下。</p><ol><li><p>安装官网Mac版Burp。<a href="https://portswigger.net/burp/releases" target="_blank" rel="noopener">https://portswigger.net/burp/releases</a></p></li><li><p>准备破解的java agent程序</p></li><li><p>将破解程序放置到<code>/Applications/Burp Suite Professional.app/Contents/Resources/app</code>目录下</p></li><li><p>执行以下命令启动注册机</p><pre><code>cd &quot;/Applications/Burp Suite Professional.app/Contents/Resources/app&quot;&quot;/Applications/Burp Suite Professional.app/Contents/Resources/jre.bundle/Contents/Home/bin/java&quot; -jar BurpLoaderKeygen.jar</code></pre></li><li><p>修改<code>/Applications/Burp Suite Professional.app/Contents/vmoptions.txt</code>, 增加以下参数</p><pre><code>--add-opens=java.base/java.lang=ALL-UNNAMED--add-opens=java.base/java.lang=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.Opcodes=ALL-UNNAMED-javaagent:BurpLoaderKeygen.jar-noverify</code></pre><p>可以正常启动了。</p></li></ol><p><strong>附</strong></p><p>提示app已损坏，无法打开，解决方法：</p><pre><code>sudo xattr -r -d com.apple.quarantine /Applications/Burp\ Suite\ Professional.app</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 破解 </tag>
            
            <tag> BurpSuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署chatglm3</title>
      <link href="/chatglm3.html"/>
      <url>/chatglm3.html</url>
      
        <content type="html"><![CDATA[<h1 id="MacBook部署chatglm3-6b"><a href="#MacBook部署chatglm3-6b" class="headerlink" title="MacBook部署chatglm3-6b"></a>MacBook部署chatglm3-6b</h1><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><pre><code>git clone https://github.com/THUDM/ChatGLM3cd ChatGLM3pip install -r requirements.txt</code></pre><h2 id="本地加载模型"><a href="#本地加载模型" class="headerlink" title="本地加载模型"></a>本地加载模型</h2><p><a href="https://huggingface.co/THUDM/chatglm3-6b" target="_blank" rel="noopener">Huggingface</a>  国内网络问题推荐使用镜像站：<a href="https://hf-mirror.com/" target="_blank" rel="noopener">hf-mirror</a> 支持断点续传</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>MacBook M1 Pro 16g 部署</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> transformers <span class="token keyword">import</span> AutoTokenizer<span class="token punctuation">,</span> AutoModel<span class="token comment" spellcheck="true"># 本地模型</span>model_directory <span class="token operator">=</span> <span class="token string">"模型地址路径（推荐绝对路径）"</span><span class="token comment" spellcheck="true">#model_directory = "THUDM/chatglm3-6b"</span>tokenizer <span class="token operator">=</span> AutoTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_directory<span class="token punctuation">,</span> trust_remote_code<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>model <span class="token operator">=</span> AutoModel<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_directory<span class="token punctuation">,</span> trust_remote_code<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>half<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">'mps'</span><span class="token punctuation">)</span>model <span class="token operator">=</span> model<span class="token punctuation">.</span>eval<span class="token punctuation">(</span><span class="token punctuation">)</span>response<span class="token punctuation">,</span> history <span class="token operator">=</span> model<span class="token punctuation">.</span>chat<span class="token punctuation">(</span>tokenizer<span class="token punctuation">,</span> <span class="token string">"你好"</span><span class="token punctuation">,</span> history<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span></code></pre><p><img src="https://img.iamghf.top/md/202312271505023.png" alt="image-20231227150509116"></p><p>速度感人，20分钟才出结果。电脑配置不行放弃治疗。。。</p><p>mac优化：</p><pre><code>将/ChatGLM3/composite_demo/client.py中的第140行左右中的device_map = “auto”改为device_map = “mps”</code></pre><p>环境变量：</p><p>export MODEL_PATH=本地模型路径。指定从本地加载模型</p><p>Jupyter 内核，可以通过 <code>export IPYKERNEL=&lt;kernel_name&gt;</code> 来指定。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chatglm3 </tag>
            
            <tag> MacBook M1 Pro </tag>
            
            <tag> chatgpt </tag>
            
            <tag> 大模型 </tag>
            
            <tag> chatglm3-6b </tag>
            
            <tag> 本地部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装配置conda</title>
      <link href="/an-zhuang-pei-zhi-conda.html"/>
      <url>/an-zhuang-pei-zhi-conda.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装配置conda环境"><a href="#安装配置conda环境" class="headerlink" title="安装配置conda环境"></a>安装配置conda环境</h1><h2 id="关于conda"><a href="#关于conda" class="headerlink" title="关于conda"></a>关于conda</h2><pre><code>conda是一个配置隔离python环境的工具因为有些时候我们需要不同版本的python或不同版本的pip模块（比如你需要跑两个从github上下下来的代码，他们的tensorflow版本一个要求1.0一个要求2.0）conda既可以实现pip模块不同版本共存，也可以实现python不同版本共存conda只是一个工具，它有两种发行版，分别是Anaconda和Miniconda    anaconda是一个大而全的工具集合，包括了非常多常用的pip模块（如numpy、pandas、scipy、matplotlib等），它还有图形化的管理工具等    miniconda是一个单纯的conda工具，仅自带极少的python必要的包，干净纯粹，可以按照自己的需求构建任意环境    miniconda比anaconda小非常多，可以实现全部日常需求，只不过需要自己动手</code></pre><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>miniconda下载地址: <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a></p><p>anaconda下载地址: <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a> </p><p>MacOs为例，下载当前最新的安装包<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2023.09-0-MacOSX-arm64.pkg" target="_blank" rel="noopener">Anaconda3-2023.09-0-MacOSX-arm64.pkg</a></p><p>双击执行安装即可。</p><h2 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h2><pre class=" language-shell"><code class="language-shell">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes</code></pre><p>原理是修改在～目录下的.condarc里的配置，直接打开此文件复制进去也可以。</p><p>修改后若想换回原来的源，执行命令：</p><pre class=" language-shell"><code class="language-shell">conda config --remove-key channels</code></pre><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><pre class=" language-shell"><code class="language-shell">conda create -n xxxx python=3.5   #创建python3.5的，名字为xxxx的虚拟环境</code></pre><p>示例：</p><pre class=" language-shell"><code class="language-shell"># 创建版本为2.7的名为venv27conda create --name venv27 python=2.7# 查看已有的虚拟环境conda env list# 进入venv27虚拟环境conda activate venv27# 查看python版本python -V# 退出此虚拟环境（默认进去base环境）conda deactivate# 退出base 环境 到达点击默认环境conda deactivate</code></pre><h2 id="查看环境"><a href="#查看环境" class="headerlink" title="查看环境"></a>查看环境</h2><pre class=" language-shell"><code class="language-shell">conda env list</code></pre><h2 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h2><pre class=" language-shell"><code class="language-shell">conda activate xxx</code></pre><h2 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h2><pre><code>conda remove -n xxxx --all   #删除xxxx虚拟环境conda clean -p      #删除没有用的包 conda clean -t      #删除无用的tar包 conda clean -y --all #删除所有的安装包及cache</code></pre><h2 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h2><pre><code>#pip 安装本地包 pip install   ～/Downloads/a.whl #conda 安装本地包 conda install --use-local  ~/Downloads/a.tar.bz2conda list         #查看已安装的包conda list  -n xxx       #指定查看xxx虚拟环境下安装的包conda update xxx   #更新xxx包 conda uninstall xxx   #卸载xxx包</code></pre><p>参考:</p><p><a href="https://zhuanlan.zhihu.com/p/378258193" target="_blank" rel="noopener">1</a> </p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> conda </tag>
            
            <tag> anaconda </tag>
            
            <tag> miniconda </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小红书引流</title>
      <link href="/xiao-hong-shu-yin-liu.html"/>
      <url>/xiao-hong-shu-yin-liu.html</url>
      
        <content type="html"><![CDATA[<p>正常来说，小红书发链接是无法点击的！<br>所以无法通过链接去引流！<br>但是，小红书自家的域名却可以点击！<br>于是，就有了一次大胆的尝试~</p><p>小红书有一个严重的bug，就是他识别的并不是根域名，而是只要二级域名包含了<a href="http://www.xiaohongshu.com/" target="_blank" rel="noopener">www.xiaohongshu.com</a>就是一个可以点击的链接！</p><p>实现方式简单来说就是：*<em>小红书域名+自己的域名 *</em></p><p>自己的域名： abc.com</p><p>小红书的域名：<a href="http://www.xionghongshu.com" target="_blank" rel="noopener">www.xionghongshu.com</a></p><p>在域名解析中增加一条记录 <a href="http://www.xionghongshu.com.abc.com" target="_blank" rel="noopener">www.xionghongshu.com.abc.com</a></p><p>然后发送到小红书，就是一个可以点击的链接！</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>改成你二维码图片地址<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">max-width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wechat-enable-text-zoom-em<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html; charset<span class="token punctuation">=</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>color-scheme<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>light dark<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width,initial-scale<span class="token punctuation">=</span>1.0,maximum-scale<span class="token punctuation">=</span>1.0,user-scalable<span class="token punctuation">=</span>0,viewport-fit<span class="token punctuation">=</span>cover<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token comment" spellcheck="true">// 这里是跳转到微信的Url Scheme</span>        <span class="token comment" spellcheck="true">// 自己看微信小程序开发文档生成</span>    location<span class="token punctuation">.</span>href<span class="token operator">=</span><span class="token string">"weixin://dl/business/?t=xxx"</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>以上示例代码，就是你自定义的一个页面，然后小红书打开，显示二维码并且跳转到微信小程序暂时你的微信二维码就实现了引流了！</p><p><strong>这样玩可能会封你小红书，仅供学习~</strong></p><p><a href="https://www.52pojie.cn/thread-1860887-1-1.html" target="_blank" rel="noopener"><em>摘自</em></a></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小红书 </tag>
            
            <tag> 引流 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google搜索技巧</title>
      <link href="/google-sou-suo-ji-qiao.html"/>
      <url>/google-sou-suo-ji-qiao.html</url>
      
        <content type="html"><![CDATA[<p>知识爆炸时代，如何快速从海量信息中，获取到自己需要的信息。推荐以下常用的Google搜索小技巧。</p><h2 id="“”"><a href="#“”" class="headerlink" title="“”"></a>“”</h2><p>限定关键字。用法：”关键字”。 在搜索中输入关键字，但搜索出来的结果可能是分词后的结果，使用”“后，搜索结果是不会分词。</p><p><img src="https://img.iamghf.top/md/202311031048344.png" alt="image-20231103104819214"></p><h2 id="intitle"><a href="#intitle" class="headerlink" title="intitle"></a>intitle</h2><p>限定标题。用法：intitle: 关键字。 搜索出来的结果，标题中会包含关键字。</p><p><img src="https://img.iamghf.top/md/202311031050171.png" alt="image-20231103105037636"></p><h2 id="allintitle"><a href="#allintitle" class="headerlink" title="allintitle"></a>allintitle</h2><p>限定标题多个关键字.用法： allintitle:关键字1 关键字2</p><p><img src="https://img.iamghf.top/md/202311031052754.png" alt="image-20231103105231011"></p><h2 id="intext"><a href="#intext" class="headerlink" title="intext"></a>intext</h2><p>限定内容关键字。用法：intext:关键字。</p><p><img src="https://img.iamghf.top/md/202311031054943.png" alt="image-20231103105403448"></p><h2 id="site"><a href="#site" class="headerlink" title="site"></a>site</h2><p>搜索制定网站的内容，用法：关键字 site: 网站。如：Linux site:iamghf.top</p><p><img src="https://img.iamghf.top/md/202311031034138.png" alt="image-20231103103435927"></p><h2 id="filetype"><a href="#filetype" class="headerlink" title="filetype"></a>filetype</h2><p>指定文件类型。用法filetype:文件类型。如filetype:pdf。搜素出来的结果都是pdf文件。</p><p><img src="https://img.iamghf.top/md/202311031057895.png" alt="image-20231103105702293"></p><h2 id="imagesize"><a href="#imagesize" class="headerlink" title="imagesize"></a>imagesize</h2><p>限定图片尺寸。用法imagesize: 图片尺寸。如imagesize:1920X1080, 搜索结果为1920X1080尺寸大小的图片。</p><p><img src="https://img.iamghf.top/md/202311031059426.png" alt="image-20231103105920376"></p><p><strong>ps.</strong>  以上条件可以进行自由组合。如 intext:”2023财富报告”。</p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> 信息获取 </tag>
            
            <tag> 搜索条件 </tag>
            
            <tag> 用法 </tag>
            
            <tag> intitle </tag>
            
            <tag> filetype </tag>
            
            <tag> site </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Costco 代购店推荐</title>
      <link href="/costco-dai-gou-dian-tui-jian.html"/>
      <url>/costco-dai-gou-dian-tui-jian.html</url>
      
        <content type="html"><![CDATA[<p>推荐一家Costco代购店。</p><p><a href="https://m.tb.cn/h.5R0VbX0" target="_blank" rel="noopener">苏小小CostcoSAM甄选</a></p><p><img src="https://img.iamghf.top/md/202311021658337.png" alt="https://gqrcode.alicdn.com/img?type=cs&amp;shop_id=113760037&amp;seller_id=1742218004&amp;w=360&amp;h=360&amp;el=q&amp;v=1"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> costco </tag>
            
            <tag> 开市客 </tag>
            
            <tag> 代购 </tag>
            
            <tag> 淘宝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建一个拖垮公司的技术架构</title>
      <link href="/ru-he-da-jian-yi-ge-tuo-kua-gong-si-de-ji-zhu-jia-gou.html"/>
      <url>/ru-he-da-jian-yi-ge-tuo-kua-gong-si-de-ji-zhu-jia-gou.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统主链路尽可能单点"><a href="#系统主链路尽可能单点" class="headerlink" title="系统主链路尽可能单点"></a>系统主链路尽可能单点</h2><p>单点系统，就像苏伊士运河一样，一旦航道出故障，整个运输系统都瘫痪，非常酸爽。</p><p><strong>单点就像单身，开始的时候滋味不好受，但是不用担心，因为后面你就习惯了</strong>。</p><h2 id="程序中多用循环"><a href="#程序中多用循环" class="headerlink" title="程序中多用循环"></a>程序中多用循环</h2><p>无限死循环，是老K最爱用的编程技巧之一，当你看到CPU利用率百分百的时候，你就知道应该甩锅给运维了。</p><p>这年头，没点特长技能还真不行。<strong>比如我，玩得一手好乐器—-退堂鼓，打得特好</strong>。</p><h2 id="系统间增加依赖"><a href="#系统间增加依赖" class="headerlink" title="系统间增加依赖"></a>系统间增加依赖</h2><p>在系统里增加内部依赖、外部依赖、第三方依赖。总之，能依赖的，决不自己动手写。</p><p>有今天的成就，主要是因为我的动手能力强，<strong>我这辈子只有两件事不会：这也不会，那也不会</strong>。</p><h2 id="不做服务补偿"><a href="#不做服务补偿" class="headerlink" title="不做服务补偿"></a>不做服务补偿</h2><p>很多东西，错过就是错过，没法补偿，这就是人生。</p><p>作为架构师，要有哲学高度。</p><p>所以说小伙子，<strong>你只看到了第二层，而你把我只想成了第一层，实际上我是第五层</strong>，你知道我讲的是什么意思吗？</p><h2 id="不做幂等设计"><a href="#不做幂等设计" class="headerlink" title="不做幂等设计"></a>不做幂等设计</h2><p>凭啥后端接口要做幂等性设计？前端提交的时候不做判断吗？全都丢给后端开发做？</p><p>大家都是打工人，<strong>人要脸，树要皮，电线杆子要水泥</strong>。</p><h2 id="不设置超时"><a href="#不设置超时" class="headerlink" title="不设置超时"></a>不设置超时</h2><p>连接超时、读超时，有多大设置多大，不管内部调用还是外部调用，都设置成60分钟。</p><p>只要努力搞，没有时间搞不砸的事情。做不成时间的朋友，就做时间的炮友。</p><h2 id="不控制流量"><a href="#不控制流量" class="headerlink" title="不控制流量"></a>不控制流量</h2><p>让流量来得猛烈一些吧，千万别限流，什么漏桶算法、令牌桶算法，<strong>那都不如啤酒桶算法—-喝完就睡，爱谁谁</strong>。</p><p>还控制啥流量啊？你连体重都控制不了，趁早放弃吧。你看看八戒，<strong>走了十万八千里也没见瘦下来，而且，他还吃素</strong>。</p><h2 id="不做监控预警"><a href="#不做监控预警" class="headerlink" title="不做监控预警"></a>不做监控预警</h2><p>大家都是职场成年人，做好分内事，别多管闲事。</p><p>工作几年以后，我明白一个道理：<strong>熟练的运用“关我屁事”和“关你屁事”，可以省下人生80%的时间</strong>。</p><h2 id="没有重试策略"><a href="#没有重试策略" class="headerlink" title="没有重试策略"></a>没有重试策略</h2><p>服务调用失败，你还想重试？我可不是随便的接口。</p><p><strong>人生不能重来，更不能乱来</strong>。</p><p>不信？<strong>你让医生，给你开点后悔药，再来杯忘情水，医生立马送你去精神病院</strong>。</p><h2 id="不做系统隔离"><a href="#不做系统隔离" class="headerlink" title="不做系统隔离"></a>不做系统隔离</h2><p>千万别做系统隔离，要挂一起挂。</p><p>什么是真正的兄弟？<strong>就是当兄弟需要女人的时候，挺身而出做他的女人</strong>。</p><p>面对困<strong>男</strong>，要排除万<strong>男</strong>，迎<strong>男</strong>而上。</p><h2 id="代码同步调用"><a href="#代码同步调用" class="headerlink" title="代码同步调用"></a>代码同步调用</h2><p>做系统就要步调一致、讲究和谐，尽量同步调用，多写bug。</p><p><strong>通常我写bug的时候，喜欢中午写，知道为什么吗？因为早晚会有报应</strong>。</p><h2 id="不做热数据缓存"><a href="#不做热数据缓存" class="headerlink" title="不做热数据缓存"></a>不做热数据缓存</h2><p>RPC的意义是什么？就是被调用啊。疯狂地调用，是对一个服务最起码的尊重。</p><p>你知道为什么大项目上线都要选个好日子吗？<strong>这么说吧，你认为上线以后还会有好日子吗？</strong></p><h2 id="不做系统分级"><a href="#不做系统分级" class="headerlink" title="不做系统分级"></a>不做系统分级</h2><p>对系统要一视同仁，不要区分核心系统、非核心系统，你有考虑过系统的感受吗？</p><p>如果你被分门别类，你会开心吗？回想起来，<strong>小时候我们都很快乐，就是因为那个时候的我们，丑和穷得都还不是那么明显</strong>。</p><h2 id="没有服务降级"><a href="#没有服务降级" class="headerlink" title="没有服务降级"></a>没有服务降级</h2><p>服务降级就low了，就算宕机也要一起扛。</p><p><strong>人生没有白走的路，如果有，那就是微信运动出bug了</strong>。</p><h2 id="无灰度和回滚方案"><a href="#无灰度和回滚方案" class="headerlink" title="无灰度和回滚方案"></a>无灰度和回滚方案</h2><p>上线全凭运气，没有回滚方案！就是那么自信。</p><p>我这个人，长这么大没学到别的本事，就掌握了一项特殊技能，<strong>白天不用安眠药也能安眠，晚上不用兴奋剂也能兴奋</strong>。</p><p>论熬夜发布，我从来没服过谁。</p><h2 id="程序多做远程调用"><a href="#程序多做远程调用" class="headerlink" title="程序多做远程调用"></a>程序多做远程调用</h2><p>能远程调用的，绝不本地调用，都5G时代了，网络延迟那点事不算什么。</p><p>再说了，做人要有点耐心，女朋友约会迟到一小时，你敢发火吗？</p><h2 id="不做熔断机制"><a href="#不做熔断机制" class="headerlink" title="不做熔断机制"></a>不做熔断机制</h2><p>炒股炒昏头了吧，做啥熔断机制？你问过韭零后吗？基金都绿成啥样了，他喊熔断了吗？</p><p><strong>作为韭菜，学费还是要交的，趁年轻的时候多交点，这样到老了再交你就习惯了</strong>。</p><h2 id="不做代码扫描"><a href="#不做代码扫描" class="headerlink" title="不做代码扫描"></a>不做代码扫描</h2><p>要有工匠精神，自己代码自己review，机器哪里懂得欣赏你的代码艺术？</p><p>我那骚气的注释、奇妙的函数、神乎其技的Copy/Paste。<strong>每次看代码，都被自己的才华吓到</strong>。</p><h2 id="不做线上压测"><a href="#不做线上压测" class="headerlink" title="不做线上压测"></a>不做线上压测</h2><p>上线就完了，后面的事情交给菩萨吧。</p><p>一分耕耘，一分收获。<strong>天下没有免费的午餐，所以我一般都睡到下午才起床</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统一事件管理</title>
      <link href="/tong-yi-shi-jian-guan-li.html"/>
      <url>/tong-yi-shi-jian-guan-li.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzU2MDcwNg==&mid=2247484022&idx=1&sn=d2b9ccd50d9146c642059a4ac9228168&chksm=ceb8fe1bf9cf770d110051a9d70cfb5420a7c7975158a49202a43427f5c1be13aee8992d8589&scene=132&exptype=timeline_recommend_article_extendread_extendread_for_notrec#wechat_redirect" target="_blank" rel="noopener">转载</a></p><p>在生活中，我的衣柜里永远只有深蓝、黑色和灰色三种颜色的衣服。我很少改变，总是给人一种中规中矩的印象。</p><p>在工作中，我不喜欢墨守成规，而是喜欢接受新事物、新方法和新技术，以打破和优化现有的管理、流程、制度和技术等。我持怀疑的、辩证的态度去看待所研发的产品，以更好、更有效率的方式去支持业务的数字化转型。</p><p>我写这篇文章的原因是发现我们的客户、我们自身以及竞争对手等仍在使用十多年前的流程和思想来思考业务和产品的未来。这样所做的产品是没有任何生命力的。做产品必须明确该产品未来的业务发展方向，否则研发出的东西只是应对当前可见的客户需求（项目需求而非产品需求）。只有精准把握业务未来的方向，才能设计出长期、分阶段、持续可销售且有价值产品。</p><p>本文，我将从统一事件管理的过去、现在和未来进行分析，探讨统一事件管理的未来发展趋势，主要包括：</p><ul><li><p>单一告警管理</p></li><li><p>统一告警管理</p></li><li><p>统一事件（incident）管理</p></li><li><p>智能事件（incident）分析及处置</p></li><li><p>总结</p></li></ul><h2 id="单一告警管理"><a href="#单一告警管理" class="headerlink" title="单一告警管理"></a>单一告警管理</h2><p><strong>面临问题</strong></p><p>在这个阶段，由于所运维系统架构简单，而且数据比较少，运维团队还能够很好地应对系统进行运维，并无任何不适。</p><p><strong>主要特征</strong></p><p>本阶段的告警管理大约可以追溯到15年前，相关特征可总结如下：</p><ul><li><p>技术上：大多数系统都是单体应用，系统复杂性非常低，在这个阶段不同的监控工具监控不同的专业领域（机房环境、主机、网络等）。</p></li><li><p>告警种类：比较单一，一般只有有限一种或几种，因此告警的处理也比较简单，很容易让人掌握。</p></li><li><p>人员组成：由于告警的种类单一，对人员的学习成本就会比较低。各不同应用厂商会提供对系统运维的日常手册，出了问题运维团队不需要太多的技术能力和专业技能，只要能够按照手册进行处理即可，如果不能解决只能升级到厂商即可。</p></li><li><p>组织流程：由于分散的监控工具，需要一个统一的地方和流程能够配合进行告警的分配和处置，</p><p>因此早期阶段会采用工单系统。产生告警后进入手工流程或工单系统（较大型组织），进行告警工单的分派和流转，流程通常都比较短，这时处置会比较高效。</p></li></ul><p><strong>业务功能范围</strong></p><p><img src="https://img.iamghf.top/md/202311021537530.png" alt="图片"></p><p>主要业务功能包括：</p><ul><li>监控系统生成异常事件：监控源配置阈值或异常检测算法，生成异常事件(event)。</li><li>对告警进行源端压缩：在配置告警策略时，会一并配置针对告警对象在一定时间范围内连续达到多少次异常之后会生成告警。</li><li>生成告警：生成告警并存储。</li><li>告警通知：会配置相应的通知模板、通知策略并完成对告警的通知。</li><li>告警中心：会有一个告警中心，针对当前监控源产生的告警进行统一存放。</li><li>同步工单：一些流程化比较规范的组织，会通过一些工单类的系统完成对告警转工单的开立，由工单来驱动告警的处置。</li></ul><h2 id="统一告警管理"><a href="#统一告警管理" class="headerlink" title="统一告警管理"></a>统一告警管理</h2><p><strong>面临问题</strong></p><p>在进行统一告警的建设之前，我们发现如下问题：</p><ul><li>告警量大：由于云战略和数字化转型，导致系统的复杂性、应用的数量增加，使得监控对象、监控方法工具等产生的告警量成倍增长。</li><li>人员增长：由于告警量的增大，以及不同领域的组件问题突出，造成人员规模的增长。</li><li>成本增加：人员的增长直接导致成本的巨大支出。</li><li>告警噪音：虽然人员的增长很大，但是依旧不能处理所有的告警，很多告警是无效的，需要对告警进行有效的降噪处理。</li><li>工具重复建设：告警的处理流程基本是一致的，但是因为监控工具的分散，导致不同的流程需要在不同的监控工具进行落地，如：告警工作台、告警分析处置、告警数据的丰富、告警的通知等，不同工具的相同功能重复建设。</li></ul><p><strong>主要特征</strong></p><p>本阶段大约在7年前，相关的特征可总结如下：</p><ul><li>技术上：基于SOA和分布式系统架构的复杂系统已经成为常态。系统变得越来越复杂，因此需要越来越多的监控工具，例如应用监控、用户体验监控、基础设置监控、数据库监控、存储设备、中间件、交易链路等，监控工具不断丰富。</li><li>告警种类：由于技术复杂性的提高，需要更多的监控工具，进而产生越来越多的告警种类和告警。</li><li>人员组成：不同的技术组件以及系统架构的复杂性，要求具有不同领域的专家来专职负责本领域的运维工作，如ORACLE DBA、存储、网络、应用领域的专家等。对应本领域内的专家仅专攻本领域内的问题分析及处置，因此随着系统复杂性的增加，运维团队也需要成倍增加。</li><li>组织流程：随着人员规模的增加，管理方面迫切需要一些有效的流程来协调人员、加速决策效率。以下列出两种不同的做法，它们在不同的流程选择上所带来的系统研发成本、人力投入成本、管理成本、流程线路拉长程度是完全不同的：<ul><li>方法一：我们看到一些南方小城商行采取的做法是，在告警生成后第一时间发出通知，然后完成与工单系统的集成，将告警同步到工单系统中。接下来，工单系统将驱动告警的分派、确认、指派、分析、处置和关闭等操作。运维人员在接收到告警后，还需要登录工单系统进行认领。在分析处置环节，需要登录统一告警查看告警基本信息、登录监控源查看指标曲线以验证告警是否真实，然后再登录自动化平台手动执行一些代码或脚本，容易出错。总结如下缺点：</li></ul></li></ul><p><img src="https://img.iamghf.top/md/202311021537521.png" alt="图片"></p><ul><li><p>流程过长：不利于快速处理告警。</p></li><li><p>集成成本高：需要建立同工单系统的双向信息同步。</p></li><li><p>调查分析效率低：由于工单系统本身是一套流程性的平台，不适合进行调查和分析。这就导致当人们接收到工单后，无法从一个统一的界面完成告警的调查、分析、处置等操作，导致效率过低。</p></li><li><p>方法二：我们也观察到很多银行和头部的券商企业并不会墨守成规，会对流程进行适当的调整。为了快速处置告警并恢复生产，他们会进行以下优化：</p></li></ul><p><img src="https://img.iamghf.top/md/202311021537674.png" alt="图片"></p><ul><li>缩短流程：由于每个告警都已经明确指定了负责处理的运维团队，因此一旦告警产生，相应的运维人员会在第一时间得到通知。运维人员可以立即登录到统一告警平台，并利用该平台的集成能力获取推荐的信息和知识进行分析，以提高排障效率。对于严重的告警，生产恢复后会在工单系统中补充工单以备审计，整个流程非常高效。</li><li>调查分析速度快：统一告警定位为运维人员的日常工作平台，完成了与指标、日志、trace等的集成，并提供了一些自动化或智能化的数据分析功能，帮助运维人员快速分析和处置告警，加速生产恢复。</li><li>集成信息：为了满足运维人员分析和处理告警的需求，统一告警平台与指标、日志、trace、变更单、知识库等进行了集成。</li></ul><ul><li>依赖告警平台提供的信息及集成能力：还有一些南方的小银行表示他们的二线从来不会登录告警平台，只进工单系统。我认为本质原因是他们没有认识到工单系统仅仅是一个流程平台，而对于告警的分析和处理，他们已经习惯了用最笨的方法——登录不同的平台去查信息、手动分析告警。而不思考通过工具系统提高信息收集和分析的效率，以及将分析结果提供给人来做决策，从而提高效率。</li></ul><h2 id="业务功能范围"><a href="#业务功能范围" class="headerlink" title="业务功能范围"></a>业务功能范围</h2><p><img src="https://img.iamghf.top/md/202311021537270.png" alt="图片"></p><p>主要业务功能包括：</p><ul><li>集成：拥有不同监控源告警的集成、变更、自动化平台、指标、日志等的集成能力。</li><li>数据清洗及标准化：企业为了后续告警的分析、处置需求，通常会制定统一的告警数据模型规范。该系统可以针对不同厂商的监控源系统所产生的告警进行统一的数据清洗及标准化操作，然后将数据存入统一告警管理平台。</li><li>数据丰富：由于监控源为了保障快速对接入的指标进行监控的需求，一般只会抛出告警对象、发生时间、发生了什么问题、什么指标发生的问题这四个重要信息，但为了满足对告警的通知、分析、处理需求，需要通过一些数据源完成告警数据的丰富。</li><li>过滤及维护期：针对被运维人员识别为告警噪音的告警需要进行过滤处理。对于在变更阶段所产生的告警，不需要进行通知，这就需要维护期管理的能力。</li><li>压缩降噪：是该系统的核心能力。它可以针对同一告警对象、同一时间段的多个重复告警进行压缩，以降低告警噪音量。</li><li>通知：针对压缩之后的告警，按合适的时间、通过合适的渠道、通知给正确的人进行处置。</li><li>告警工作台是运维人员的统一告警管理工作平台。它可以查看权限控制范围内的告警列表、详情、压缩的原始告警列表、自动收集近期变更及日志和指标信息并展示相关曲线，以及针对告警的认领、指派、关闭、恢复、静默等操作的能力。</li></ul><h2 id="统一事件管理"><a href="#统一事件管理" class="headerlink" title="统一事件管理"></a>统一事件管理</h2><p><strong>面临问题</strong></p><p>在进入本阶段之前，仍然存在以下问题：</p><ul><li>告警量大：尽管在统一告警阶段已经对告警进行了统一的管理、过滤和压缩治理，但要处理的告警量仍然很大，需要一种方法能够更进一步地完成告警的收敛。</li><li>关系复杂：难以识别相互之间的影响。</li><li>人员增长：为了应对数字化转型带来的压力，人员规模持续增长。</li><li>协作不畅：传统的团队分工以及基于工单的流程系统导致相互之间的协作不畅。每次出现事件，需要不同团队之间反复沟通以确认业务上技术上的影响范围，然后再通过工单流系统发起工单，效率低下。</li></ul><p><strong>主要特征</strong></p><p>本阶段的主要特征类似于统一告警管理阶段，但在管理对象、业务流程、组织结构等方面发生了很大的变化：</p><p><img src="https://img.iamghf.top/md/202311021537067.png" alt="图片"></p><ul><li>技术方面：由于数字化转型的需求，对研发效率、系统稳定性、快速满足客户需求等方面提出了更高的要求。大型企业要同时面对老旧的系统架构和新的分布式架构所带来的挑战。即使是规模较小的新创业团队也会采用复杂的分布式应用来保障应用程序的灵活性和高开发效率。</li><li>组织结构方面：一切皆服务。服务所有权模型是一种用于管理现代IT系统的有效模型。它能够将运维团队、开发团队和测试团队连接起来，促进协作，快速响应所运维的IT服务设施，并按服务方式对业务系统的模块进行细粒度的拆分和管理。这种模型更符合现代分布式架构的研发及运维一体化团队组成结构。（后续我会整理针对传统IT架构下的服务所有权模型如何自治建模，以及在应急及事件处置场景下如何替代CMDB使之更容易落地）</li><li>管理及处置对象：由传统的告警转变为事件 (incident)。当发生告警时，可以按照告警路由规则路由到不同的服务模型，对告警进行进一步的收敛生成事件。并将收敛后的事件信息通过各种通知渠道通知给所在的运维团队。其所带来的价值改变如下图所示：</li></ul><p><img src="https://img.iamghf.top/md/202311021538320.png" alt="图片"></p><ul><li><p>人员：由于推行了一系列有效的管理手段、服务所有权模型、告警收敛为事件，人员规模不再像统一告警阶段那样无限制地增长。</p></li><li><p>流程：通过实行服务所有权，业务服务和技术服务得以有效结合。客户的业务投诉和内部用户的电话或工单报障会首先同步到统一事件管理平台，并根据客户投诉所在的业务服务自动创建相应的事件，驱动分析和处理。当事件处理完成后，最新的结果和状态信息会同步给客户服务渠道和工单系统，然后由客户服务团队通知最终用户，避免中间工单环节流转来流转去，加快效率。</p></li></ul><p><strong>业务功能范围</strong></p><p><img src="https://img.iamghf.top/md/202311021538048.png" alt="图片"></p><p>统一事件管理平台在统一告警管理平台的基础上增强了以下能力：</p><ul><li>服务模型管理：服务模型管理是统一事件管理平台的一个增强能力。服务模型除了兼容传统技术架构，可以对业务系统的模块进行细粒度的拆分和管理，还能更好地适应分布式微服务架构，很好地表达服务之间的相互依赖关系。通过服务模型管理，无论是业务服务还是技术服务出现问题，都能更快地定位问题，快速恢复服务，提高系统的稳定性和可靠性。</li><li>服务可视化及影响分析：可以通过可视化的方式展示业务服务由哪些技术服务组件构成，以及它们之间的依赖关系。并可以通过可视化的方式来展示服务之间的关联关系。当发生问题时，通过服务可视化及影响分析，可以追踪一个事件的起源以及它的上下游的影响情况，帮助企业快速了解问题的规模和范围，并采取相应的措施。</li><li>告警关联生成事件（incident）：处理的对象不再是告警，而是有关联关系的事件。可以通过多种方式（如下图所示）将相互之间有关联关系或影响关系的告警组合成事件。运维人员在处理事件时，可以提供更丰富的告警上下文信息，并可以有效降低要处理的告警数量，加速对事件的分析及恢复过程。</li></ul><p><img src="https://img.iamghf.top/md/202311021538434.png" alt="图片"></p><ul><li>用户组绑定服务模型：通过用户组的管理方式将开发、测试、运维团队形成对服务的所有权管理模式，构建开发、运维一体化团队，确保每一个服务都有对应的用户组进行运维。当发生问题时，初级问题由用户组内部的运维团队负责解决，而高级问题则可以直接由测试或开发人员来完成，增强协作效率。</li><li>通知事件（incident）而非告警：通过单个告警会形成大量的噪音干扰，而对最终的运维团队而言，更想知道发生了什么业务、什么服务、什么系统在什么时间发生了什么问题。例如：[二代支付系统]的[跨行转帐服务(1000089)]交易缓慢，支持该业务的3台应用服务器出现GCCOUNT、CPU使用率等5种类型的告警，共计33条关联告警。事件编码:INC202308281535401001，发生时间:2023年08月28日15:35:40。</li><li>事件（incident）管理工作台：形成统一的事件管理工作台，不同的用户群组可以根据自己的数据权限查看相应的事件，并在该工作台上完成对事件的调查、分析和处理操作。</li></ul><h2 id="智能事件分析及处置"><a href="#智能事件分析及处置" class="headerlink" title="智能事件分析及处置"></a>智能事件分析及处置</h2><p><strong>面临问题</strong></p><p>在进入本阶段的设计之前，主要存在如下问题：</p><ul><li>历史处置方案及知识难以有效借鉴。</li><li>占用大量的专家资源，专家经验难以工具化。</li><li>处置效率慢，缺乏自动化排查及分析手段，无法快速定位并修复问题。</li><li>难以从历史事件中获取更深入的洞见。</li></ul><p>…</p><p><strong>主要特征</strong></p><ul><li>积极推行SRE的运维文化：SRE文化的核心是通过事后的复盘分析找到问题的根本原因，通过工程的方法将问题彻底解决，防止下次再次发生，或不能彻底杜绝的情况下可以通过自动化的手段来再次捕捉问题，并进行自动化的响应。通过该文化的落地使运维团队不断治理发现的事件，从而使开发运维团队从告警噪音中解放出来，有更多的时间和精力放到如何优化现有的工具、系统，为客户创造更大的价值上。</li><li>专家经验需要沉淀：通过管理流程和技术手段相结合的方式，使专家对事件的处置经验沉淀到系统中。当再次发生类似的事件时，可以快速借鉴之前类似事件的分析过程和处置方案，加速业务恢复过程。</li><li>可编排的自动化能力：不同情境下的事情是变化的，但是针对人类进行问题排查的过程是相同的。因此，需要一套可编排的自动化排查系统（产品级的），能够根据不同事件情境进行参数化配置。通过按照运维人员针对不同情境的事件变化配置不同的排查策略，当事件发生时能够快速触发排查并产生结论报告，以节省大量的人力，提高排查分析及自动化处置的效率。例如：<ul><li>验证告警与实际情况是否相符：当数据库主机DOWN机时，主机管理员通常会首先使用ping方法进行主机探活操作，以验证是否误报。通过自动化的方法，可以大大降低这类告警的噪音，同时会节省人工排查的时间成本。</li><li>某行二代支付系统故障排查：当发现二代支付系统故障时，首先需要根据告警信息来判断是来报异常、往报异常、渠道异常等情况。如果是来报异常，则可以判断是行外系统异常而非行内系统。这时需要排查前置机是否出现异常。如果前置机未出现异常，则会认为是他行给到的交易出现了问题。重点排查哪个银行发来的交易引起了问题。</li><li>…</li></ul></li><li>推行智能化：包括智能化的根因推荐、智能化的相似事件识别、已知事件的识别和判断、以及针对事件推送相应的知识和处置建议。同时，结合可编排的自动化能力，最终实现数据中心的自治和自愈能力。</li><li>人员规模：由于SRE运维文化的导入，自动化和智能化的普及，团队规模的工作负载会越来越少。</li><li>成为企业数字化转型必不可少的基础设施：智能事件分析及处置平台将成为企业数字化转型必不可少的基础设施。通过该中心，可以链接监控源、变更管理、自动化平台、知识库、通知渠道、客户服务团队、IT服务团队、测试及开发团队，驱动协调整个体系使其高效运转，从而将IT风险最小化。</li></ul><h2 id="业务功能范围-1"><a href="#业务功能范围-1" class="headerlink" title="业务功能范围"></a>业务功能范围</h2><p><img src="https://img.iamghf.top/md/202311021538039.png" alt="图片"></p><p>在统一事件管理平台的基础上提供了如下能力：</p><p><strong>相似事件识别</strong></p><p>在事件处理完成后，需要将事件的分析处理过程记录到智能事件分析和处置平台。当下次类似事件发生时，智能算法会根据事件的特征识别出来，并推荐历史上针对该类事件的处置策略，从而加速事件处理过程。</p><p><strong>可编排的自动化分析能力</strong></p><p>可编排的自动化分析能力是实现AIOPS的最后一公里的关键。在2018年，PAGERDUTY以1亿美金收购了RUNDECK，splunk以3.5亿美金收购了Phantom，以加强其可编排的自动能力。这种能力是智能化运维的核心组件。下面我们看一个主机down机的用例，来看一下该产品所具备的能力：</p><p><img src="https://img.iamghf.top/md/202311021538893.png" alt="图片"></p><ul><li>首先，设置一个触发器来捕捉告警或事件。在这个例子中，我们针对服务器宕机告警进行配置。如上图中圈1位置所示，当告警产生时，如果alert_source=’zabbix’且alert_title=’SERVER_DOWN’，则触发该分析流程。</li><li>进入流程逻辑处理层：<ul><li>第一步：如上图圈2所示，先执行ping指令进行主机探活。执行完成后，解析脚本执行的结果，并生成针对该步骤的中间变量存放在上图圈5所在的位置，以供全局流程使用。</li><li>第二步：如上图圈3所示，执行主机探活返回结果状态的判断。如果STATUS=TRUE，则表示当前主机处于活动状态。</li><li>第三步：如上图圈4所示，如果主机可以ping通，则表明当前告警为误报，需要执行“告警操作”中的“告警关闭”，这样就不会产生告警噪音的通知。如果主机ping不通，则表明主机确实已经down机，当前流程即结束。</li></ul></li></ul><p><img src="https://img.iamghf.top/md/202311021538741.png" alt="图片"></p><ul><li>其它功能说明：<ul><li>配置触发条件支持：<ul><li>捕捉告警或事件进行触发</li><li>通过数据库创建某些记录、更新记录来触发</li><li>定时触发：比较适用于定时对告警进行清理或其它一些特殊的批量操作</li></ul></li></ul></li></ul><p><img src="https://img.iamghf.top/md/202311021538508.png" alt="图片"></p><ul><li>配置执行逻辑：<ul><li>支持条件判断</li><li>支持对数据集的逐条处理逻辑</li><li>支持调用其它的分析流程，如之前创建了一个针对WEBLOGIC告警的排查逻辑，当业务系统发生问题时，也同时要排障WEBLOGIC，这时就可以直接调用其它排查流程。</li><li>等待时间比较适合对告警进行延时类的操作，如延时等待恢复信号再进行通知的流程。</li></ul></li></ul><p><strong>根因推荐</strong></p><p><img src="https://img.iamghf.top/md/202311021539245.png" alt="图片"></p><p>当完成告警聚合为事件后，事件中可能包含多个告警的异常信号。为了找到问题是由什么告警所引起的，系统需要推荐可能的根因，将其推送到运维人员的事件详情页面上以协助其进行判断。运维人员进行分析后，会将结果反馈给系统，算法将重新优化算法的推荐结果。</p><p><strong>已知事件识别</strong></p><p><img src="https://img.iamghf.top/md/202311021539658.png" alt="图片"></p><p>在事件处理过程中，运维人员会总结出大量规律，形成已知事件。针对这些已知事件，会配置快速恢复策略。当出现这种问题时，会触发全自动化或半自动化的处置策略。例如：</p><ul><li>示例1：当 WEBLOGIC 出现 FULLGC 告警，并且在同一时间段出现应用交易响应时间过长的告警时，应该针对该告警主机上 WEBLOGIC 进行的DUPMP 信息收集和服务重启操作，以快速解决该事件。</li><li>示例2：某交易的处理时间变长，且在同一时段出现了该交易的某台AP主机打开文件句柄超限的告警。如果出现这两种类型的告警，则需要对该AP主机进行重启操作。</li><li>…</li></ul><p>在识别出已知事件之后，可以向运维人员推荐处理动作，如上图所示，由运维人员经过判断之后手动触发执行。</p><p><strong>处置方案推荐</strong></p><p>如上图所示，针对已知事件识别之后可以推荐其处置方案。</p><p><strong>知识推荐</strong></p><p>如上图所示，针对已知事件识别之后可以推荐其相关知识和手册。</p><p><strong>自动化处置库管理</strong></p><p>在进行自动化处置时，必须将每个对象类型及其可执行的操作关联起来。这样，在出现已知故障或运维人员分析之后，可以快速锁定针对告警对象可执行的操作列表。可执行的操作一般由自动化平台、云管平台等同步过来，并进行有效的分类管理。真正的执行操作由统一事件管理平台调用自动化平台或云管平台提供的API完成最终的执行动作。</p><p><img src="https://img.iamghf.top/md/202311021539983.png" alt="图片"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>统一事件管理平台的建设非常重要：它是企业数字化转型的基础设施，可以连接监控源、变更管理、自动化平台、知识库、通知渠道、客户服务团队、IT服务团队、测试及开发团队。通过对产生的风险事件进行有效管理，可以驱动整个体系高效运转，最小化IT风险。</li><li>对统一事件管理的认识也非常重要：不论是国内的厂商还是客户，都需要打破固化的思维以及老旧的ITSM流程规范，采用新科技、新方法、新流程和新工具来武装自己，不断优化事件处理流程，从而使数据中心高效运转。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 告警 </tag>
            
            <tag> 事件 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macbook彩虹圈卡顿问题解决</title>
      <link href="/macbook-cai-hong-quan-qia-dun-wen-ti-jie-jue.html"/>
      <url>/macbook-cai-hong-quan-qia-dun-wen-ti-jie-jue.html</url>
      
        <content type="html"><![CDATA[<p>手头MacBook Pro M1 14寸的电脑自从系统升级到13后，就经常出现转彩虹圈圈，而且一旦卡顿开始，除非重启，否则问题不会有所好转。电话咨询了技术支持后，重启，出现 LOGO 之前按住 shift 键进入安全模式，一周内没有出现问题，但后面又频繁出现。一周内至少两次。最近系统又升级到最新的14，问题依然存在。网上翻阅资料，出现卡顿后，在活动监视器把中文输入法强行关闭，就不卡了，也不会转圈。推断是中文输入法导致iCloud卡住，从而导致系统卡顿。</p><p>终极解决方案：</p><ol><li><p>将系统回退到12。</p></li><li><p>或者删除自带的中文输入法，使用第三方输入法。</p></li></ol><p>希望苹果能尽快解决这个bug。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacBook pro </tag>
            
            <tag> m1 </tag>
            
            <tag> 卡顿 </tag>
            
            <tag> 中文输入法 </tag>
            
            <tag> 彩虹圈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>m1 mac上openvpn无法连接排查</title>
      <link href="/mac-shang-openvpn-wu-fa-lian-jie-pai-cha.html"/>
      <url>/mac-shang-openvpn-wu-fa-lian-jie-pai-cha.html</url>
      
        <content type="html"><![CDATA[<p>最近公司openvpn突然连不上了，最开始以为是网络调整导致了。等了几天后发现还不行，让同事在window上连接，发现并没有问题，自己用命令行连接也没问题。简单排查后，最后发现是柠檬清理导致的。<br>只需要，把openvpn相关的服务启动打开就行了。</p><p><img src="https://img.iamghf.top/md/202310242209350.png" alt="image-20231024220925380"></p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> openvpn </tag>
            
            <tag> MacBook m1 </tag>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用Java部署运行脚本</title>
      <link href="/tong-yong-java-yun-xing-jiao-ben.html"/>
      <url>/tong-yong-java-yun-xing-jiao-ben.html</url>
      
        <content type="html"><![CDATA[<p>记录下jar 部署发布脚本。</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash# 主类APP_NAME="$1"APP_MAINCLASS="jxict-digitalvillage-modules-$APP_NAME"# 服务jar包位置和日志位置APP_FILE_PATH="/data/app/$APP_NAME/$APP_MAINCLASS.jar"# 进程ID文件PID_FILE="/data/app/$APP_NAME/$APP_NAME.pid"# 获取进程ID，如果进程不存在则返回0getpid() {   if [ -f "$PID_FILE" ]; then       psid=$(cat "$PID_FILE")   else       psid=0   fi}# 函数：检查进程是否存在# 参数 $1：要检查的进程号# 返回值：如果进程存在，返回 0，否则返回 1checkPid(){    local pid_to_check="$1"    if ps -p "$pid_to_check" > /dev/null; then        return 0  # 进程存在    else        return 1  # 进程不存在    fi}start() {   echo "Starting $APP_MAINCLASS..."   if [ -f "$PID_FILE" ]; then       echo "$APP_NAME is already running."   else       nohup java -jar "$APP_FILE_PATH" --spring.profiles.active=mobile >> "/data/app/$APP_NAME/nohup.log" 2>&1 &       echo "$!" > "$PID_FILE"       echo "Started $APP_NAME. PID: $!"   fi}stop() {   getpid   if [ $psid -ne 0 ]; then       echo "Stopping $APP_MAINCLASS..."       kill "$psid"       rm "$PID_FILE"   else       echo "$APP_NAME is not running."   fi}restart() {     getpid   local jpid=$psid   checkPid $jpid   local flag=$?   stop   while [ $flag -ne 0 ]; do       sleep 1       checkPid $jpid       flag=$?   done   sleep 2   start}method="$2"case "$method" in    "start")        start        ;;    "stop")        stop        ;;    "restart")        restart        ;;    *)        echo "Usage: $0 <app_name> <start|stop|restart>"        exit 1        ;;esac</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> shell </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装MinIO</title>
      <link href="/an-zhuang-minio.html"/>
      <url>/an-zhuang-minio.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装Minio"><a href="#安装Minio" class="headerlink" title="安装Minio"></a>安装Minio</h1><p><strong>下载地址</strong>：<a href="https://minio.org.cn/download.shtml#/linux" target="_blank" rel="noopener">https://minio.org.cn/download.shtml#/linux</a></p><p><strong>编辑启动脚本</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/shexport MINIO_ROOT_USER=adminexport MINIO_ROOT_PASSWORD=admin123nohup /hldata/soft/minio/bin/minio server --address=0.0.0.0:32000 --console-address 0.0.0.0:32001 --config-dir /data/soft/minio /data/soft/minio/data >/data/soft/minio/logs/minio.log 2>&1&</code></pre><pre class=" language-shell"><code class="language-shell">## 添加服务./bin/mc config host add minio http://127.0.0.1:32000 admin admin123## 查看服务列表./bin/mc config host list</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> minio </tag>
            
            <tag> 分布式文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgersql主从配置</title>
      <link href="/pg-zhu-cong.html"/>
      <url>/pg-zhu-cong.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><p>pg版本：10.12.1</p><p>主：172.20.0.231</p><p>备：172.20.0.152</p><p>安装目录：PGHOME = /home/nh/pg/pgsql/</p><p>data目录：PGDATA =  /nhdata/busi_db/</p><h2 id="主数据库"><a href="#主数据库" class="headerlink" title="主数据库"></a>主数据库</h2><p>修改<strong>postgresql.conf</strong>文件</p><pre class=" language-shell"><code class="language-shell">wal_level = hot_standby   #WAL日志信息的输出级别，minimal、replica、logical三种模式synchronous_commit = off    #只能为off，否则主库会一直等待备机响应，备机故障时主机也会出问题max_wal_senders = 10            #默认为10，一个流复制备库通常只需要消耗流复制主库一个WAL 发送进程，必须小于max_connectionswal_keep_segments = 512        #越大越好，根据归档存储空间定，默认单个WAL文件大小为16M，此处512×16MB=8GBhot_standby = on                #开启流复制logging_collector = on        #开启日志log_directory = 'pg_log'    #开启日志路径log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'    #开启日志文件名</code></pre><p>创建<strong><em>replication用户</em></strong></p><pre class=" language-shell"><code class="language-shell">./psql -U postgrescreate user repli replication LOGIN password '123456';</code></pre><p>配置<strong>pg_hba.conf</strong>文件</p><p>添加以下配置，考虑到主备角色互换，建议pg_hba.conf主备完全一样</p><pre class=" language-shell"><code class="language-shell">host    replication      repli      172.20.0.231/32            md5host    replication      repli      172.20.0.152/32            md5</code></pre><p><strong>重启数据库</strong></p><pre class=" language-shell"><code class="language-shell">pg_ctl -D $PGDATA restart</code></pre><h2 id="备数据库"><a href="#备数据库" class="headerlink" title="备数据库"></a>备数据库</h2><p><strong>1)</strong> <strong>测试从服务器能否连接主服务器数据库</strong></p><pre class=" language-shell"><code class="language-shell">psql -h 172.20.0.231 -U postgres#连接成功后停掉从库的服务,清空从节点数据rm –rf $PGDATA/*</code></pre><p><strong>2)</strong> <strong>从主节点拷贝数据到从节点</strong></p><pre class=" language-shell"><code class="language-shell">#pg_basebackup -h 10.251.9.39 -U repli -D $PGDATA -X stream –P ./pgsql/bin/pg_basebackup -D $PGDATA -Fp -Xs -v -P -h 172.20.0.231 -U repli</code></pre><p><strong>3)</strong>  修改<strong>recovery.conf</strong>文件</p><p>复制share目录(pgsql/share/postgresql/recovery.conf.sample)下的recovery.conf.sample文件</p><pre class=" language-shell"><code class="language-shell">cp $PGHOME/share/recovery.conf.sample $PGDATA/recovery.conf</code></pre><p>修改以下配置</p><pre class=" language-shell"><code class="language-shell">standby_mode='on'recovery_target_timeline = 'latest'#配置主机的ip、用户、端口等，repli即主库创建的用于流复制的用户primary_conninfo='host=172.20.0.231 port=5432 user=repli password=123456'trigger_file='/nhdata/busi_db/trigger'</code></pre><p><strong>重启备库</strong></p><pre class=" language-shell"><code class="language-shell">pg_ctl -D $PGDATA restart</code></pre><h2 id="查看主备状态"><a href="#查看主备状态" class="headerlink" title="查看主备状态"></a>查看主备状态</h2><ol><li><p>通过进程查看 ps -aux | grep postgres</p><p>主库为wal sender</p><p>备库为wal receiver</p></li><li><p>执行SQL</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>  client_addr<span class="token punctuation">,</span>sync_stat  <span class="token keyword">from</span> pg_stat_replication<span class="token punctuation">;</span><span class="token comment" spellcheck="true">--说明client_addr服务器是从节点，在接收流，而且是异步流复制</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> pg_is_in_recovery<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">--主库是false 备库是true</span></code></pre></li><li><p>通过建表、插入数据测试即可</p></li></ol><h2 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h2><h3 id="文件触发方式"><a href="#文件触发方式" class="headerlink" title="文件触发方式"></a>文件触发方式</h3><p>1、配置备库recovery.conf文件trigger_file参数</p><p>2、关闭主库</p><pre class=" language-shell"><code class="language-shell">$ pg_ctl stop -m fast</code></pre><p>3、 在备库上创建trigger_file，</p><pre class=" language-shell"><code class="language-shell">$ touch $PGDATA/trigger</code></pre><p>触发器文件名称和路径需和recovery.conf配置文件trigger_file保持一致，再次查看recovery文件时，发现后辍由原来的.conf变成了.done，表示备库切换为主库成功。</p><p>4、老的主库切换成备库</p><p>拷贝老的备库recovery.done(recovery.conf)文件到新备库，修改IP地址为新主库IP</p><pre class=" language-shell"><code class="language-shell">primary_conninfo='host=172.20.0.152 port=5432 user= repli password=123456'</code></pre><p>5、启动新备库</p><pre class=" language-shell"><code class="language-shell">$ pg_ctl -D $PGDATA start</code></pre><h3 id="pg-ctl-promote方式"><a href="#pg-ctl-promote方式" class="headerlink" title="pg_ctl promote方式"></a>pg_ctl promote方式</h3><p>1、关闭主库</p><pre class=" language-shell"><code class="language-shell">$ pg_ctl stop -m fast</code></pre><p>2、在备库上执行pg_ctl prompt命令激活备库，如果recovery.conf变成recovery.done表示备库已切换成为主库。</p><p>3、 老的主库切换成备库</p><p>拷贝老的备库recovery.done(recovery.conf)文件到老主库，修改IP地址为新主库IP</p><pre class=" language-shell"><code class="language-shell">primary_conninfo='host=172.20.0.152 port=5432 user= repli password=123456'</code></pre><p>4、观察主、备库是否正常</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 主从复制 </tag>
            
            <tag> 主从切换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络IO模型</title>
      <link href="/wang-luo-io-mo-xing.html"/>
      <url>/wang-luo-io-mo-xing.html</url>
      
        <content type="html"><![CDATA[<p>同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，我先限定一下本文的上下文。</p><p>  本文讨论的背景是<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I/O Models ”，Stevens在这节中详细说明了各种IO的特点和区别，如果英文够好的话，推荐直接阅读。Stevens的文风是有名的深入浅出，所以不用担心看不懂。本文中的流程图也是截取自参考文献。</p><p>  Stevens在文章中一共比较了五种IO Model：<br>  * blocking IO<br>  * nonblocking IO<br>  * IO multiplexing<br>  * signal driven IO<br>  * asynchronous IO<br>  由signal driven IO在实际中并不常用，所以主要介绍其余四种IO Model。<br>  再说一下IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：<br>  1）等待数据准备 (Waiting for the data to be ready)<br>  2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)<br>  记住这两点很重要，因为这些IO模型的区别就是在两个阶段上各有不同的情况。<br>  1、阻塞IO（blocking IO）</p><p>  在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081339.jpg" alt="img"></p><p>图1 阻塞IO</p><p>  当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>  <strong>所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。</strong></p><p>  几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv() 等接口开始的，这些接口都是阻塞型的。使用这些接口可以很方便的构建服务器/客户机的模型。下面是一个简单地“一问一答”的服务器。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081232.jpg" alt="图 1. 简单的一问一答的服务器 / 客户机模型"></p><p>图2 简单的一问一答的服务器/客户机模型</p><p>  我们注意到，大部分的socket接口都是阻塞型的。所谓阻塞型接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。<br>  实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用send()的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。</p><p>  一个简单的改进方案是在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。具体使用多进程还是多线程，并没有一个特定的模式。<strong>传统意义上，进程的开销要远远大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问，则进程较为安全。</strong>通常，使用pthread_create ()创建新线程，fork()创建新进程。<br>  我们假设对上述的服务器 / 客户机模型，提出更高的要求，即让服务器同时为多个客户机提供一问一答的服务。于是有了如下的模型。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081233.jpg" alt="图 2. 多线程的服务器模型"></p><p>图3 多线程的服务器模型</p><p>  在上述的线程 / 时间图例中，主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。<br>  很多初学者可能不明白为何一个socket可以accept多次。实际上socket的设计者可能特意为多客户机的情况留下了伏笔，让accept()能够返回一个新的socket。下面是 accept 接口的原型：<br>   int accept(int s, struct sockaddr <em>addr, socklen_t <em>addrlen);<br>  输入参数s是从socket()，bind()和listen()中沿用下来的socket句柄值。执行完bind()和listen()后，<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener">操作系统</a>已经开始在指定的端口处监听所有的连接请求，如果有请求，则将该连接请求加入请求队列。调用accept()接口正是从 socket s 的请求队列抽取第一个连接信息，创建一个与s同类的新的socket返回句柄。新的socket句柄即是后续read()和recv()的输入参数。如果请求队列当前没有请求，则accept() 将进入阻塞状态直到有请求进入队列。<br>  上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。<br>  很多程序员可能会考虑使用</em></em>“线程池”或“连接池”<strong>。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">数据库</a>等。但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，</strong>所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。**<br>  对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</p><p>  <strong>2、非阻塞IO（non-blocking IO</strong>）<br>  Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081438.jpg" alt="img"></p><p>图4 非阻塞IO</p><p>  从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br>  <strong>所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。</strong></p><p>  非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。使用如下的函数可以将某句柄fd设为非阻塞状态。<br>  fcntl( fd, F_SETFL, O_NONBLOCK );<br>  下面将给出只用一个线程，但能够同时从多个连接中检测数据是否送达，并且接受数据的模型。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-81234.jpg" alt="图 3. 使用非阻塞的接收数据模型"></p><p>图5 使用非阻塞的接收数据模型</p><p>  在非阻塞状态下，recv() 接口在被调用后立即返回，返回值代表了不同的含义。如在本例中，<br>  * recv() 返回值大于 0，表示接受数据完毕，返回值即是接受到的字节数；<br>  * recv() 返回 0，表示连接已经正常断开；<br>  * recv() 返回 -1，且 errno 等于 EAGAIN，表示 recv 操作还没执行完成；<br>  * recv() 返回 -1，且 errno 不等于 EAGAIN，表示 recv 操作遇到系统错误 errno。<br>  可以看到服务器线程可以通过循环调用recv()接口，可以在单个线程内实现对所有连接的数据接收工作。但是上述模型绝不被推荐。因为，<strong>循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。</strong><br>  <strong>3、多路复用IO（IO multiplexing）</strong><br>  IO multiplexing这个词可能有点陌生，但是如果我说select/epoll，大概就都能明白了。有些地方也称这种IO方式为<strong>事件驱动IO</strong>(event driven IO)。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081518.jpg" alt="img"></p><p>图6 多路复用IO</p><p>  当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>  这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句：所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>  <strong>在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。</strong>只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似。</p><p>  大部分Unix/Linux都支持select函数，该函数用于探测多个文件句柄的状态变化。下面给出select接口的原型：<br>  FD_ZERO(int fd, fd_set* fds)<br>  FD_SET(int fd, fd_set* fds)<br>  FD_ISSET(int fd, fd_set* fds)<br>  FD_CLR(int fd, fd_set* fds)<br>  int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,<br>  struct timeval *timeout)<br>  这里，fd_set 类型可以简单的理解为按 bit 位标记句柄的队列，例如要在某 fd_set 中标记一个值为16的句柄，则该fd_set的第16个bit位被标记为1。具体的置位、验证可使用 FD_SET、FD_ISSET等宏实现。在select()函数中，readfds、writefds和exceptfds同时作为输入参数和输出参数。如果输入的readfds标记了16号句柄，则select()将检测16号句柄是否可读。在select()返回后，可以通过检查readfds有否标记16号句柄，来判断该“可读”事件是否发生。另外，用户可以设置timeout时间。<br>  下面将重新模拟上例中从多个客户端接收数据的模型。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081234.jpg" alt="图 4. 使用 select() 的接收数据模型"></p><p>图7 使用select()的接收数据模型</p><p>  述模型只是描述了使用select()接口同时从多个客户端接收数据的过程；由于select()接口可以同时对多个句柄进行读状态、写状态和错误状态的探测，所以可以很容易构建为多个客户端提供独立问答服务的服务器系统。如下图。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-81237.jpg" alt="图 5. 使用 select() 接口的基于事件驱动的服务器模型"></p><p>图8 使用select()接口的基于事件驱动的服务器模型</p><p>  这里需要指出的是，客户端的一个 connect() 操作，将在服务器端激发一个“可读事件”，所以 select() 也能探测来自客户端的 connect() 行为。<br>  上述模型中，最关键的地方是如何动态维护select()的三个参数readfds、writefds和exceptfds。作为输入参数，readfds应该标记所有的需要探测的“可读事件”的句柄，其中永远包括那个探测 connect() 的那个“母”句柄；同时，writefds 和 exceptfds 应该标记所有需要探测的“可写事件”和“错误事件”的句柄 ( 使用 FD_SET() 标记 )。<br>  作为输出参数，readfds、writefds和exceptfds中的保存了 select() 捕捉到的所有事件的句柄值。程序员需要检查的所有的标记位 ( 使用FD_ISSET()检查 )，以确定到底哪些句柄发生了事件。<br>  上述模型主要模拟的是“一问一答”的服务流程，所以如果select()发现某句柄捕捉到了“可读事件”，服务器程序应及时做recv()操作，并根据接收到的数据准备好待发送数据，并将对应的句柄值加入writefds，准备下一次的“可写事件”的select()探测。同样，如果select()发现某句柄捕捉到“可写事件”，则程序应及时做send()操作，并准备好下一次的“可读事件”探测准备。下图描述的是上述模型中的一个执行周期。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081235.jpg" alt="图 6. 一个执行周期"></p><p>图9 多路复用模型的一个执行周期</p><p>  这种模型的特征在于每一个执行周期都会探测一次或一组事件，一个特定的事件会触发某个特定的响应。我们可以将这种模型归类为“<strong>事件驱动模型</strong>”。<br>  相比其他模型，使用select() 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。<br>  但这个模型依旧有着很多问题。<strong>首先select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。</strong>很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/dev/poll，…。如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难。<br>  <strong>其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。</strong>如下例，庞大的执行体1的将直接导致响应事件2的执行体迟迟得不到执行，并在很大程度上降低了事件探测的及时性。</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081236.jpg" alt="图 7. 庞大的执行体对使用 select() 的事件驱动模型的影响"></p><p>图10 庞大的执行体对使用select()的事件驱动模型的影响</p><p>  幸运的是，有很多高效的事件驱动库可以屏蔽上述的困难，常见的事件驱动库有<strong>libevent库</strong>，还有作为libevent替代者的<strong>libev库</strong>。这些库会根据操作系统的特点选择最合适的事件探测接口，并且加入了信号(signal) 等技术以支持异步响应，这使得这些库成为构建事件驱动模型的不二选择。下章将介绍如何使用libev库替换select或epoll接口，实现高效稳定的服务器模型。</p><p>  实际上，Linux内核从2.6开始，也引入了支持异步响应的IO操作，如aio_read, aio_write，这就是异步IO。</p><p>  <strong>4、异步IO（Asynchronous I/O）</strong><br>  Linux下的asynchronous IO其实用得不多，从内核2.6版本才开始引入。先看一下它的流程：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081559.jpg" alt="img"></p><p>图11 异步IO</p><p>  用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>  用异步IO实现的服务器这里就不举例了，以后有时间另开文章来讲述。异步IO是真正非阻塞的，它不会对请求进程产生任何的阻塞，因此对高并发的网络服务器实现至关重要。<br>  到目前为止，已经将四个IO模型都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。<br>先回答最简单的这个：blocking与non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还在准备数据的情况下会立刻返回。<br>  在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：<br>  * A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>  * An asynchronous I/O operation does not cause the requesting process to be blocked;<br>  两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个系统调用。<strong>non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的。</strong>而asynchronous IO则不一样，当进程发起IO操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p>  还有一种不常用的signal driven IO，即信号驱动IO。总的来说，UNP中总结的<strong>IO模型有5种之多：阻塞IO，非阻塞IO，IO复用，信号驱动IO，异步IO</strong>。前四种都属于同步IO。阻塞IO不必说了。非阻塞IO ，IO请求时加上O_NONBLOCK一类的标志位，立刻返回，IO没有就绪会返回错误，需要请求进程主动轮询不断发IO请求直到返回正确。IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。信号驱动IO，调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间，这一步是阻塞的。<br>异步IO，如定义所说，不会因为IO操作阻塞，IO操作全部完成才通知请求进程。<br>  各个IO Model的比较如图所示：</p><p><img src="https://img.iamghf.top/blog/2020-09-18-081645.jpg" alt="img"></p><p>图12 各种IO模型的比较</p><p>  经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor模式</title>
      <link href="/reactor-mo-shi.html"/>
      <url>/reactor-mo-shi.html</url>
      
        <content type="html"><![CDATA[<h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><h2 id="什么是-Reactor-模式"><a href="#什么是-Reactor-模式" class="headerlink" title="什么是 Reactor 模式"></a>什么是 Reactor 模式</h2><p>wiki：</p><blockquote><p>“The reactor design pattern is an event handling pattern for handling service requests delivered concurrently by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to associated request handlers.”</p></blockquote><h2 id="为什么会有-Reactor-呢"><a href="#为什么会有-Reactor-呢" class="headerlink" title="为什么会有 Reactor 呢"></a>为什么会有 Reactor 呢</h2><p>对于应用程序而言，CPU 的处理速度是远远快于 IO 的速度的。如果CPU为了IO操作（例如从Socket读取一段数据）而阻塞显然是不划算的。好一点的方法是分为多进程或者线程去进行处理，但是这样会带来一些进程切换的开销，试想一个进程一个数据读了500ms，期间进程切换到它3次，但是CPU却什么都不能干，就这么切换走了，是不是也不划算？</p><p>这时先驱们找到了事件驱动，或者叫回调的方式，来完成这件事情。这种方式就是，应用业务向一个中间人注册一个回调（event handler），当IO就绪后，就这个中间人产生一个事件，并通知此handler进行处理。这种回调的方式，也体现了“好莱坞原则”（Hollywood principle）-“Don’t call us, we’ll call you”，在我们熟悉的IoC中也有用到。看来软件开发真是互通的！</p><h2 id="Reactor-应用场景"><a href="#Reactor-应用场景" class="headerlink" title="Reactor 应用场景"></a>Reactor 应用场景</h2><p>Reactor 核心是解决多请求问题。一般来说，Thread-Per-Connection 的应用场景并发量不是特别大，如果并发量过大，会导致线程资源瞬间耗尽，导致服务陷入阻塞，这个时候就需要 Reactor 模式来解决这个问题。Reactor 通过多路复用的思想大大减少线程资源的使用。</p><h2 id="Reactor-结构"><a href="#Reactor-结构" class="headerlink" title="Reactor 结构"></a>Reactor 结构</h2><p><img src="https://img.iamghf.top/blog/2020-09-16-095816.jpg" alt="结构"></p><p>上图是 Reactor 模型，主要涉及的类：</p><ul><li><code>Initiation Dispatcher</code>：EventHandler 的容器，用来注册、移除 EventHandler 等；另外，它作为 Reactor 模式的入口调用 Synchronous Event Demultiplexer 的 select 方法以阻塞等待事件的返回，当阻塞事件返回时，将事件发生的 Handle 分发到相应的 EvenHandler 处理。</li><li><code>Even Handler</code>：定义了事件处理的方法。</li><li><code>Handle</code>：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。</li><li><code>Synchronous Event Demultiplexer</code>：使用一个事件循环 ，以阻止所有的资源。当可以启动一个同步操作上的资源不会阻塞，多路分解器发送资源到分发器。</li></ul><h2 id="Reactor-时序图"><a href="#Reactor-时序图" class="headerlink" title="Reactor 时序图"></a>Reactor 时序图</h2><p><img src="https://img.iamghf.top/blog/2020-09-16-095916.jpg" alt="时序图"></p><ol><li>初始化 InitationDispatcher，并初始化一个Handle到EventHandler的Map。</li><li>注册 EvenHandler 到 InitationDispatcher，每个 EventHandler 包含对相应 Handle 的引用，从而建立Handle到EventHandler的映射（Map）。</li><li>调用 InitiationDispatcher 的 handle_events() 方法以启动 Event Loop。在 Event Loop 中，调用 select()方法（Synchronous Event Demultiplexer）阻塞等待Event发生。</li><li>当某个或某些 Handle 的 Event 发生后，select() 方法返回，InitiationDispatcher 根据返回的Handle找到注册的 EventHandler ，并回调该 EventHandler 的 handle_events() 方法。</li><li>在 EventHandler 的 handle_events() 方法中还可以向 InitiationDispatcher 中注册新的 Eventhandler，比如对 AcceptorEventHandler 来说，当有新的 client 连接时，它会产生新的 EventHandler 以处理新的连接，并注册到 InitiationDispatcher 中。</li></ol><h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><h3 id="单线程-Reactor-模式"><a href="#单线程-Reactor-模式" class="headerlink" title="单线程 Reactor 模式"></a>单线程 Reactor 模式</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-100001.jpg" alt="reactor单线程"></p><p><strong>简单来说，接收请求和处理请求是同一线程中处理。</strong></p><p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发或大数据量的应用场景却不合适，主要原因如下： ① 一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的读取和发送； ② 当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</p><h3 id="多线程-Reactor-模式"><a href="#多线程-Reactor-模式" class="headerlink" title="多线程 Reactor 模式"></a>多线程 Reactor 模式</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-100045.jpg" alt="reactor多线程"></p><p><strong>简单来说，接收请求和处理请求是不同线程中处理。</strong></p><p>mainReactor 一般只有一个，主要负责接收客户端的连接并将其传递给 subReactor。subReactor  一般会有多个，主要负责处理与客户端的通信。</p><p>注意：上图使用了<code>Thread Pool</code>来处理耗时的业务逻辑，提高Reactor线程的I/O响应，不至于因为一些耗时的业务逻辑而延迟对后面I/O请求的处理。</p><h2 id="Reactor-的优缺点"><a href="#Reactor-的优缺点" class="headerlink" title="Reactor 的优缺点"></a>Reactor 的优缺点</h2><p>优点：</p><ol><li>大多数设计模式的共性：解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制等。</li><li>更为显著的是对性能的提升，即不需要每个 Client 对应一个线程，减少线程的使用。</li></ol><p>缺点：</p><ol><li>相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。</li><li>Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。</li><li>Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。</li></ol><p>【<a href="https://juejin.im/post/6844903688780120078" target="_blank" rel="noopener">原文</a>】</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> reactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn常用命令</title>
      <link href="/svn-chang-yong-ming-ling.html"/>
      <url>/svn-chang-yong-ming-ling.html</url>
      
        <content type="html"><![CDATA[<h1 id="svn常用命令"><a href="#svn常用命令" class="headerlink" title="svn常用命令"></a>svn常用命令</h1><h2 id="checkout代码"><a href="#checkout代码" class="headerlink" title="checkout代码"></a>checkout代码</h2><pre class=" language-shell"><code class="language-shell">svn co svn://svnbucket.com/xxx/xxx</code></pre><h2 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h2><pre class=" language-shell"><code class="language-shell">svn up</code></pre><h2 id="添加新文件到版本库"><a href="#添加新文件到版本库" class="headerlink" title="添加新文件到版本库"></a>添加新文件到版本库</h2><pre class=" language-shell"><code class="language-shell">svn add filename#添加当前目录下所有java文件svn add *.java# 递归添加当前目录下的所有新文件svn add . --no-ignore --force</code></pre><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><pre class=" language-shell"><code class="language-shell">svn commit -m "提交描述"</code></pre><h2 id="查看log"><a href="#查看log" class="headerlink" title="查看log"></a>查看log</h2><pre class=" language-shell"><code class="language-shell"># 查看指定文件的所有logsvn log Test.java# 查看指定版本号的logsvn log -r 100</code></pre><h2 id="撤销本地文件的修改"><a href="#撤销本地文件的修改" class="headerlink" title="撤销本地文件的修改"></a>撤销本地文件的修改</h2><pre class=" language-shell"><code class="language-shell"># 撤销本地文件的修改（还没提交的）svn revert Test.javasvn revert -r 目录名# 撤销目录下所有本地修改svn revert --recursive 目录名</code></pre><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><pre class=" language-shell"><code class="language-shell"># 查看当前工作区的所有改动svn diff# 查看当前工作区文件与最新版本的差异svn diff Test.java# 指定版本号比较差异svn diff -r 200:201 Test.java# 查看当前工作区和版本301中bin目录的差异svn diff -r 301 bin</code></pre><h2 id="查看当前工作区的状态"><a href="#查看当前工作区的状态" class="headerlink" title="查看当前工作区的状态"></a>查看当前工作区的状态</h2><pre class=" language-shell"><code class="language-shell">svn status</code></pre><h2 id="查看svn信息"><a href="#查看svn信息" class="headerlink" title="查看svn信息"></a>查看svn信息</h2><pre class=" language-shell"><code class="language-shell">svn info</code></pre><h2 id="查看文件列表"><a href="#查看文件列表" class="headerlink" title="查看文件列表"></a>查看文件列表</h2><pre class=" language-shell"><code class="language-shell"># 查看文件列表，可以指定-r查看，查看指定版本号的文件列表svn ls svn ls -r 100</code></pre><h2 id="显示文件的每一行最后是谁修改的"><a href="#显示文件的每一行最后是谁修改的" class="headerlink" title="显示文件的每一行最后是谁修改的"></a>显示文件的每一行最后是谁修改的</h2><pre class=" language-shell"><code class="language-shell">svn blame Test.java</code></pre><h2 id="查看指定版本的文件内容"><a href="#查看指定版本的文件内容" class="headerlink" title="查看指定版本的文件内容"></a>查看指定版本的文件内容</h2><pre class=" language-shell"><code class="language-shell"># 查看指定版本的文件内容，不加版本号就是查看最新版本的svn cat Test.java -r 2</code></pre><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><pre class=" language-shell"><code class="language-shell">svn cleanup</code></pre><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><pre class=" language-shell"><code class="language-shell"># 若想创建了一个文件夹，并且把它加入版本控制，但忽略文件夹中的所有文件的内容svn mkdir spool svn propset svn:ignore '*' spool svn ci -m 'Adding "spool" and ignoring its contents.'# 若想创建一个文件夹，但不加入版本控制，即忽略这个文件夹mkdir spool svn propset svn:ignore 'spool' . svn ci -m 'Ignoring a directory called "spool".'</code></pre><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><pre class=" language-shell"><code class="language-shell"># 切换当前项目到指定分支。服务器上更新新版本我们经常就用这个命令来把当前代码切换到新的分支svn switch svn://svnbucket.com/test/branches/online1.0</code></pre><h2 id="重定向仓库地址"><a href="#重定向仓库地址" class="headerlink" title="重定向仓库地址"></a>重定向仓库地址</h2><pre class=" language-shell"><code class="language-shell"># 重定向仓库地址到新地址svn switch --relocate 原svn地址 新svn地址</code></pre><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><pre class=" language-shell"><code class="language-shell"># 创建分支，从主干创建一个分支保存到branches/online1.0svn cp -m "描述内容" http://svnbucket.com/repos/trunk http://svnbucket.com/repos/branches/online1.0</code></pre><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><pre class=" language-shell"><code class="language-shell"># 合并主干上的最新代码到分支上cd branches/online1.0svn merge http://svnbucket.com/repos/trunk # 分支合并到主干svn merge --reintegrate http://svnbucket.com/repos/branches/online1.0# 删除分支svn rm http://svnbucket.com/repos/branches/online1.0</code></pre><h2 id="查看SVN帮助"><a href="#查看SVN帮助" class="headerlink" title="查看SVN帮助"></a>查看SVN帮助</h2><pre class=" language-shell"><code class="language-shell"># 查看SVN帮助svn help# 查看指定命令的帮助信息svn help commit</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac查看jdk实际位置</title>
      <link href="/mac-cha-kan-jdk.html"/>
      <url>/mac-cha-kan-jdk.html</url>
      
        <content type="html"><![CDATA[<h2 id="mac查看jdk位置"><a href="#mac查看jdk位置" class="headerlink" title="mac查看jdk位置"></a>mac查看jdk位置</h2><p>1、打开终端，输入：/usr/libexec/java_home -V</p><p>   注意：输入命令参数区分大小写(-v是不对的，必须是-V)</p><p>如图：3个红框内依次为：输入命令； 当前Mac已安装jdk目录； Mac默认使用的jdk版本；</p><p><img src="https://img.iamghf.top/blog/2020-05-12-101635.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发分布式架构演进之路</title>
      <link href="/jia-gou-yan-jin-zhi-lu.html"/>
      <url>/jia-gou-yan-jin-zhi-lu.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>本文以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。</p><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><p>在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍：</p><ul><li><strong>分布式</strong><br>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上</li><li><strong>高可用</strong><br>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性</li><li><strong>集群</strong><br>一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性</li><li><strong>负载均衡</strong><br>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的</li><li><strong>正向代理和反向代理</strong><br>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。</li></ul><h2 id="3-架构演进"><a href="#3-架构演进" class="headerlink" title="3. 架构演进"></a>3. 架构演进</h2><h3 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070027.png" alt="img"></p><p>以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往<a href="http://www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。" target="_blank" rel="noopener">www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。</a></p><blockquote><p>随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务</p></blockquote><h3 id="第一次演进：Tomcat与数据库分开部署"><a href="#第一次演进：Tomcat与数据库分开部署" class="headerlink" title="第一次演进：Tomcat与数据库分开部署"></a>第一次演进：Tomcat与数据库分开部署</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-70032.png" alt="img"></p><p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。</p><blockquote><p>随着用户数的增长，并发读写数据库成为瓶颈</p></blockquote><h3 id="第二次演进：引入本地缓存和分布式缓存"><a href="#第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="第二次演进：引入本地缓存和分布式缓存"></a>第二次演进：引入本地缓存和分布式缓存</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070029.png" alt="img"></p><p>在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p><blockquote><p>缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢</p></blockquote><h3 id="第三次演进：引入反向代理实现负载均衡"><a href="#第三次演进：引入反向代理实现负载均衡" class="headerlink" title="第三次演进：引入反向代理实现负载均衡"></a>第三次演进：引入反向代理实现负载均衡</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-70030.png" alt="img"></p><p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。</p><blockquote><p>反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈</p></blockquote><h3 id="第四次演进：数据库读写分离"><a href="#第四次演进：数据库读写分离" class="headerlink" title="第四次演进：数据库读写分离"></a>第四次演进：数据库读写分离</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070030.png" alt="img"></p><p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p><blockquote><p>业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能</p></blockquote><h3 id="第五次演进：数据库按业务分库"><a href="#第五次演进：数据库按业务分库" class="headerlink" title="第五次演进：数据库按业务分库"></a>第五次演进：数据库按业务分库</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070031.png" alt="img"></p><p>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p><blockquote><p>随着用户数的增长，单机的写库会逐渐会达到性能瓶颈</p></blockquote><h3 id="第六次演进：把大表拆分为小表"><a href="#第六次演进：把大表拆分为小表" class="headerlink" title="第六次演进：把大表拆分为小表"></a>第六次演进：把大表拆分为小表</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070038.png" alt="img"></p><p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。</p><p>这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。</p><p>目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p><blockquote><p>数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈</p></blockquote><h3 id="第七次演进：使用LVS或F5来使多个Nginx负载均衡"><a href="#第七次演进：使用LVS或F5来使多个Nginx负载均衡" class="headerlink" title="第七次演进：使用LVS或F5来使多个Nginx负载均衡"></a>第七次演进：使用LVS或F5来使多个Nginx负载均衡</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070039.png" alt="img"></p><p>由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。</p><p>此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat，在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。</p><blockquote><p>由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同</p></blockquote><h3 id="第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="第八次演进：通过DNS轮询实现机房间的负载均衡"></a>第八次演进：通过DNS轮询实现机房间的负载均衡</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070032.png" alt="img"></p><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。" target="_blank" rel="noopener">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。</a></p><blockquote><p>随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求</p></blockquote><h3 id="第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="第九次演进：引入NoSQL数据库和搜索引擎等技术"></a>第九次演进：引入NoSQL数据库和搜索引擎等技术</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070033.png" alt="img"></p><p>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。</p><p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p><blockquote><p>引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难</p></blockquote><h3 id="第十次演进：大应用拆分为小应用"><a href="#第十次演进：大应用拆分为小应用" class="headerlink" title="第十次演进：大应用拆分为小应用"></a>第十次演进：大应用拆分为小应用</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070034.png" alt="img"></p><p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。</p><blockquote><p>不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级</p></blockquote><h3 id="第十一次演进：复用的功能抽离成微服务"><a href="#第十一次演进：复用的功能抽离成微服务" class="headerlink" title="第十一次演进：复用的功能抽离成微服务"></a>第十一次演进：复用的功能抽离成微服务</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-70035.png" alt="img"></p><p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p><blockquote><p>不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱</p></blockquote><h3 id="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"></a>第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070035.png" alt="img"></p><p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。</p><blockquote><p>业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难</p></blockquote><h3 id="第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"><a href="#第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理" class="headerlink" title="第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"></a>第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070036.png" alt="img"></p><p>目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。</p><p>在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在3.14节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。</p><blockquote><p>使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低</p></blockquote><h3 id="第十四次演进：以云平台承载系统"><a href="#第十四次演进：以云平台承载系统" class="headerlink" title="第十四次演进：以云平台承载系统"></a>第十四次演进：以云平台承载系统</h3><p><img src="https://img.iamghf.top/blog/2020-09-16-070037.png" alt="img"></p><p>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p><p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：</p><ul><li><strong>IaaS</strong>：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；</li><li><strong>PaaS</strong>：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；</li><li><strong>SaaS</strong>：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</li></ul><blockquote><p>至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论</p></blockquote><h2 id="4-架构设计总结"><a href="#4-架构设计总结" class="headerlink" title="4. 架构设计总结"></a>4. 架构设计总结</h2><ul><li><strong>架构的调整是否必须按照上述演变路径进行？</strong><br>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</li><li><strong>对于将要实施的系统，架构应该设计到什么程度？</strong><br>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。</li><li><strong>服务端架构和大数据架构有什么区别？</strong><br>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。</li><li>有没有一些架构设计的原则？<ul><li>N+1设计。系统中的每个组件都应做到没有单点故障；</li><li>回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本；</li><li>禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；</li><li>监控设计。在设计阶段就要考虑监控的手段；</li><li>多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；</li><li>采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难；</li><li>资源隔离设计。应避免单一业务占用全部资源；</li><li>架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题；</li><li>非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；</li><li>使用商用硬件。商用硬件能有效降低硬件故障的机率；</li><li>快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；</li><li>无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</li></ul></li></ul><p>【<a href="https://segmentfault.com/a/1190000018626163" target="_blank" rel="noopener">原文</a>】</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux防火墙</title>
      <link href="/linux-fang-huo-qiang.html"/>
      <url>/linux-fang-huo-qiang.html</url>
      
        <content type="html"><![CDATA[<p>Linux中有两种防火墙软件，CentOS7.0以上使用的是firewall，CentOS7.0以下使用的是iptables</p><h2 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h2><ul><li>开启防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl start firewalld</code></pre><ul><li>关闭防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl stop firewalld</code></pre><ul><li>查看防火墙状态：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl status firewalld</code></pre><ul><li>设置开机启动：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl enable firewalld</code></pre><ul><li>禁用开机启动：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl disable firewalld</code></pre><ul><li>重启防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">firewall-cmd --reload</code></pre><ul><li>开放端口（修改后需要重启防火墙方可生效）：</li></ul><pre class=" language-shell"><code class="language-shell">firewall-cmd --zone=public --add-port=8080/tcp --permanent</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094056.jpg" alt="展示图片"></p><ul><li>查看开放的端口：</li></ul><pre class=" language-shell"><code class="language-shell">firewall-cmd --list-ports</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094329.jpg" alt="展示图片"></p><ul><li>关闭端口：</li></ul><pre class=" language-shell"><code class="language-shell">firewall-cmd --zone=public --remove-port=8080/tcp --permanent</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094414.jpg" alt=""></p><h2 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>由于CenterOS7.0以上版本并没有预装Iptables,我们需要自行装。</p></blockquote><ul><li><p>安装前先关闭firewall防火墙</p><p><img src="https://img.iamghf.top/blog/2020-09-23-094504.jpg" alt=""></p></li><li><p>安装iptables:</p></li></ul><pre class=" language-shell"><code class="language-shell">yum install iptables</code></pre><ul><li>安装iptables-services:</li></ul><pre class=" language-shell"><code class="language-shell">yum install iptables-services</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>开启防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl start iptables.service</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094545.jpg" alt=""></p><ul><li>关闭防火墙：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl stop iptables.service</code></pre><ul><li>查看防火墙状态：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl status iptables.service</code></pre><ul><li>设置开机启动：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl enable iptables.service</code></pre><ul><li>禁用开机启动：</li></ul><pre class=" language-shell"><code class="language-shell">systemctl disable iptables.service</code></pre><ul><li>查看filter表的几条链规则(INPUT链可以看出开放了哪些端口)：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -L -n</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094621.jpg" alt=""></p><ul><li>查看NAT表的链规则：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -t nat -L -n</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094653.jpg" alt=""></p><ul><li>清除防火墙所有规则：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -Fiptables -Xiptables -Z</code></pre><ul><li>给INPUT链添加规则（开放8080端口）：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094720.jpg" alt=""></p><ul><li>查找规则所在行号：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -L INPUT --line-numbers -n</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094800.jpg" alt=""></p><ul><li>根据行号删除过滤规则（关闭8080端口）：</li></ul><pre class=" language-shell"><code class="language-shell">iptables -D INPUT 1</code></pre><p><img src="https://img.iamghf.top/blog/2020-09-23-094933.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> firewall </tag>
            
            <tag> iptables </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装oracle</title>
      <link href="/docker-an-zhuang-oracle.html"/>
      <url>/docker-an-zhuang-oracle.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker安装oracle"><a href="#docker安装oracle" class="headerlink" title="docker安装oracle"></a>docker安装oracle</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><pre class=" language-shell"><code class="language-shell">docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</code></pre><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><pre class=" language-shell"><code class="language-shell">docker run -d -p 1521:1521 --name oracle11 registry.cnhangzhou.aliyuncs.com/helowin/oracle_11g</code></pre><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><pre><code>docker start oracle11</code></pre><p>可能会报以下错</p><blockquote><p>docker: Error response from daemon: OCI runtime create failed: container_linux.go:449；container init caused “write /proc/self/attr/keycreate: permission denied””: unknown.</p></blockquote><p>原因：操作系统已启用SELinux，造成“/proc/self/attr/keycreate” 没有写入权限 使用命令:getenfor查看SELinux运行模式</p><pre class=" language-shell"><code class="language-shell">root@localhost ~]# getenforce#查询SELinux的运行模式Enforcing#当前的SELinux是强制模式[root@localhost ~]# sestatusSELinux status:              enabledSELinuxfs mount:             /selinuxCurrent mode:                enforcingMode from config file:       enforcingPolicy version:              24Policy from config file:     targeted</code></pre><p><strong>解决办法：</strong></p><p><strong>1 永久方法 – 需要重启服务器</strong></p><p>修改/etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。</p><p><strong>2 临时方法 – 设置系统参数</strong></p><p>使用命令setenforce 0</p><p><strong>附：</strong><br>setenforce 1   //设置SELinux 成为enforcing模式<br>setenforce 0   //设置SELinux 成为permissive模式</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><pre class=" language-shell"><code class="language-shell">docker exec -it oracle11 bash</code></pre><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><pre><code>sqlplus /nolog</code></pre><p>可能会报 bash: sqlplus: command not found</p><p>解决方法：</p><ol><li><p>切换到root用户 (密码helowin)</p><pre class=" language-shell"><code class="language-shell">su root</code></pre></li><li><p>编辑profile文件配置ORACLE环境变量</p><pre class=" language-shell"><code class="language-shell">vi /etc/profile</code></pre><p>文件最后添加以下内容</p><pre class=" language-shell"><code class="language-shell">export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2export ORACLE_SID=helowinexport PATH=$ORACLE_HOME/bin:$PATH</code></pre></li><li><p>创建软连接</p><pre class=" language-shell"><code class="language-shell">ln -s $ORACLE_HOME/bin/sqlplus /usr/bin</code></pre></li><li><p>切换到oracle 用户</p><pre class=" language-shell"><code class="language-shell">su - oracle</code></pre></li></ol><h2 id="登录sqlplus并修改sys、system用户密码"><a href="#登录sqlplus并修改sys、system用户密码" class="headerlink" title="登录sqlplus并修改sys、system用户密码"></a>登录sqlplus并修改sys、system用户密码</h2><pre class=" language-shell"><code class="language-shell">sqlplus /nologconn /as sysdba</code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">user</span> system identified <span class="token keyword">by</span> system<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">user</span> sys identified <span class="token keyword">by</span> sys<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 添加用户</span><span class="token keyword">create</span> <span class="token keyword">user</span> test identified <span class="token keyword">by</span> <span class="token number">123456</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 赋权</span><span class="token keyword">grant</span> <span class="token keyword">connect</span><span class="token punctuation">,</span>resource<span class="token punctuation">,</span><span class="token number">dba</span> <span class="token keyword">to</span> test<span class="token punctuation">;</span></code></pre><p>有可能报：database not open</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">database</span> <span class="token keyword">open</span><span class="token punctuation">;</span></code></pre><p>还可能报： ORA-01507: database not mounted</p><p>解决办法：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">database</span> mount<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">database</span> <span class="token keyword">open</span><span class="token punctuation">;</span></code></pre><p> 成功修改数据库密码后执行</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> PROFILE <span class="token keyword">DEFAULT</span> <span class="token keyword">LIMIT</span> PASSWORD_LIFE_TIME UNLIMITED<span class="token punctuation">;</span></code></pre><h2 id="客户端登陆"><a href="#客户端登陆" class="headerlink" title="客户端登陆"></a>客户端登陆</h2><p>容器内查看oracle 的 lsnrctl 服务</p><pre><code>lsnrctl status</code></pre><p><img src="https://img.iamghf.top/blog/2020-08-17-064402.png" alt="img"></p><p>看到两个Service，任选其一，修改 <strong>tnsnames.ora的 service_name=helowinXDB</strong></p><p>tns样例：</p><pre><code>docker_oracle11 = (DESCRIPTION =   (ADDRESS_LIST =     (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.30.31)(PORT =1521))   )   (CONNECT_DATA =     (SERVICE_NAME = helowinXDB)   ))</code></pre><p><strong><em>附</em></strong></p><p>docker 启动容器报错</p><blockquote><h1 id="iptables-failed-iptables-–wait-t-nat-A-DOCKER-p-tcp-d-0-0-–dport-3000-j-DNAT-–to-destination-172-17-0-3-3000-i-docker0-iptables-No-chain-target-match-by-that-name"><a href="#iptables-failed-iptables-–wait-t-nat-A-DOCKER-p-tcp-d-0-0-–dport-3000-j-DNAT-–to-destination-172-17-0-3-3000-i-docker0-iptables-No-chain-target-match-by-that-name" class="headerlink" title="iptables failed: iptables –wait -t nat -A DOCKER -p tcp -d 0/0 –dport 3000 -j DNAT –to-destination 172.17.0.3:3000 ! -i docker0: iptables: No chain/target/match by that name."></a>iptables failed: iptables –wait -t nat -A DOCKER -p tcp -d 0/0 –dport 3000 -j DNAT –to-destination 172.17.0.3:3000 ! -i docker0: iptables: No chain/target/match by that name.</h1></blockquote><p>解决方法</p><p>重启docker服务</p><pre class=" language-shell"><code class="language-shell">sudo systemctl restart docker</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非root安装docker</title>
      <link href="/fei-root-an-zhuang-docker.html"/>
      <url>/fei-root-an-zhuang-docker.html</url>
      
        <content type="html"><![CDATA[<h1 id="非root安装docker"><a href="#非root安装docker" class="headerlink" title="非root安装docker"></a>非root安装docker</h1><h2 id="添加docker组"><a href="#添加docker组" class="headerlink" title="添加docker组"></a>添加docker组</h2><pre class=" language-shell"><code class="language-shell">cat /etc/group |grep dockersudo groupadd dockersudo gpasswd -a 用户名 docker</code></pre><h2 id="下载docker源码"><a href="#下载docker源码" class="headerlink" title="下载docker源码"></a>下载docker源码</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/static/stable/x86_64/docker-18.09.0.tgz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/static/stable/x86_64/docker-18.09.0.tgz</a></p><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><pre class=" language-shell"><code class="language-shell">tar -zxvf docker-18.09.0.tgzsudo cp docker/* /usr/bin/#docker有关指令的所属用户和所属组(必做,不然非root用户使用docker指令报错:权限不够)sudo chown root:docker /usr/bin/docker*sudo chown root:docker /usr/bin/containerd*sudo chown root:docker /usr/bin/runcsudo chown root:docker /usr/bin/ctr</code></pre><p>查看下</p><p><img src="https://img.iamghf.top/blog/2020-08-17-063405.png" alt="img"></p><h2 id="设置docker服务"><a href="#设置docker服务" class="headerlink" title="设置docker服务"></a>设置docker服务</h2><p>新建</p><pre class=" language-shell"><code class="language-shell">sudo vi /etc/systemd/system/docker.service</code></pre><p>内容如下：</p><pre><code>[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target[Service]Type=notifyExecStart=/usr/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPIDLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityTimeoutStartSec=0Delegate=yesKillMode=processRestart=on-failureStartLimitBurst=3StartLimitInterval=60s[Install]WantedBy=multi-user.target</code></pre><p>添加权限</p><pre class=" language-shell"><code class="language-shell">sudo chmod a+x /etc/systemd/system/docker.servicesudo systemctl daemon-reload</code></pre><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>新建</p><pre class=" language-shell"><code class="language-shell">sudo vi /etc/docker/daemon.json </code></pre><p>添加以下内容</p><pre><code>{&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}</code></pre><h2 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h2><pre class=" language-shell"><code class="language-shell">sudo systemctl start docker</code></pre><p>附</p><pre><code>启/停/重启/查看状态sudo systemctl  start/stop/restart/status</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos安装Postgresql</title>
      <link href="/centos-an-zhuang-postgresql.html"/>
      <url>/centos-an-zhuang-postgresql.html</url>
      
        <content type="html"><![CDATA[<h1 id="centos-离线安装Postgresql"><a href="#centos-离线安装Postgresql" class="headerlink" title="centos 离线安装Postgresql"></a>centos 离线安装Postgresql</h1><h2 id="本机上传压缩包"><a href="#本机上传压缩包" class="headerlink" title="本机上传压缩包"></a>本机上传压缩包</h2><pre class=" language-shell"><code class="language-shell">scp ./postgresql-10.12-1-linux-x64-binaries.tar.gz 用户名@远程主机:/home/dbdev/postgreSql</code></pre><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><pre class=" language-shell"><code class="language-shell">tar -zxvf postgresql-10.12-1-linux-x64-binaries.tar.gz</code></pre><h2 id="创建数据库数据目录"><a href="#创建数据库数据目录" class="headerlink" title="创建数据库数据目录"></a>创建数据库数据目录</h2><pre class=" language-shell"><code class="language-shell">mkdir data</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre class=" language-shell"><code class="language-shell">./pgsql/bin/initdb -U postgres -D pgsql/data</code></pre><p>可能会报以下错误：</p><blockquote><p>initdb: invalid locale settings; check LANG and LC_* environment variables</p></blockquote><pre class=" language-shell"><code class="language-shell">./pgsql/bin/initdb -U postgres -D pgsql/data --locale=zh_CN.UTF-8 -E UTF-8</code></pre><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><pre><code>vi pgsql/data/postgresql.conf</code></pre><p> #listen_addresses = ‘localhost’,去掉注释，改为listen_addresses = ‘*’</p><p> #port = 5432，去掉注释</p><pre class=" language-shell"><code class="language-shell">vi pgsql/data/pg_hba.conf</code></pre><p>将IPv4 的trust改为md5</p><p>并且在下面新增一行</p><p>host  all       all       0.0.0.0/0        md5</p><p><img src="https://img.iamghf.top/blog/2020-08-17-062837.png" alt="image-20200812162036467"></p><h2 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h2><pre class=" language-shell"><code class="language-shell">./pgsql/bin/pg_ctl -D pgsql/data/ start</code></pre><h2 id="设置superuser密码"><a href="#设置superuser密码" class="headerlink" title="设置superuser密码"></a>设置superuser密码</h2><p>./pgsql/bin/psql -U postgres</p><p>postgres#= \password postgres</p><p>修改完\q退出</p><h2 id="重启数据库"><a href="#重启数据库" class="headerlink" title="重启数据库"></a>重启数据库</h2><pre class=" language-shell"><code class="language-shell">./pgsql/bin/pg_ctl -D pgsql/data/ restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
            <tag> centos </tag>
            
            <tag> linux </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非root安装mysql</title>
      <link href="/centos-an-zhuang-mysql.html"/>
      <url>/centos-an-zhuang-mysql.html</url>
      
        <content type="html"><![CDATA[<h1 id="非root安装mysql"><a href="#非root安装mysql" class="headerlink" title="非root安装mysql"></a>非root安装mysql</h1><h2 id="本机上传压缩包"><a href="#本机上传压缩包" class="headerlink" title="本机上传压缩包"></a>本机上传压缩包</h2><pre class=" language-shell"><code class="language-shell">scp mysql-5.7.29-linux-glibc2.12-x86_64.tar.gz 用户名@远程主机:/home/dbdev/mysql</code></pre><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><pre class=" language-shell"><code class="language-shell">tar -zxvf mysql-5.7.29-linux-glibc2.12-x86_64.tar.gzmv mysql-5.7.29-linux-glibc2.12-x86_64 mysql</code></pre><h2 id="创建实例数据目录"><a href="#创建实例数据目录" class="headerlink" title="创建实例数据目录"></a>创建实例数据目录</h2><pre class=" language-shell"><code class="language-shell">mkdir data log</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre class=" language-shell"><code class="language-shell">./mysql/bin/mysqld --initialize --user=dbdev --basedir=/home/dbdev/mysql/mysql --datadir=/home/dbdev/mysql/data</code></pre><p>可能报以下错：</p><pre><code>error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory</code></pre><p>解决方法：</p><ol><li>查看是否安装 rpm -qa|grep libaio  </li><li>yum install  libaio （需要root权限）</li></ol><p>初始化成功后记下这个随机密码，后面要用到</p><p><img src="https://img.iamghf.top/blog/2020-08-14-074754.png" alt="image-20200813093635999"></p><h2 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h2><p>vi ./mysql/mysql.cnf</p><pre><code>[client]port=3306socket=/home/dbdev/mysql/mysql/mysql.sock[mysqld]port=3306#设置mysql的安装目录basedir=/home/dbdev/mysql/mysql# 设置mysql数据库的数据的存放目录datadir=/home/dbdev/mysql/datapid-file=/home/dbdev/mysql/mysql/mysql.pidsocket=/home/dbdev/mysql/mysql/mysql.socklog_error=/home/dbdev/mysql/log/error.logcollation_server=utf8_general_ci# 服务端使用的字符集默认为8比特编码的latin1字符集character_set_server=utf8log-bin=/home/dbdev/mysql/log/mysql-binserver-id=100</code></pre><h2 id="mysqld-safe模式启动数据库"><a href="#mysqld-safe模式启动数据库" class="headerlink" title="mysqld_safe模式启动数据库"></a>mysqld_safe模式启动数据库</h2><pre class=" language-shell"><code class="language-shell">./mysql/bin/mysqld_safe --defaults-file=/home/dbdev/mysql/mysql/mysql.cnf --user=dbdev &</code></pre><h2 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h2><p>登陆mysql</p><pre class=" language-shell"><code class="language-shell">./mysql/bin/mysql -u root -p</code></pre><p>可能会报以下错：</p><pre><code>ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)</code></pre><p><img src="https://img.iamghf.top/blog/2020-08-14-074755.png" alt="image-20200813094110879"></p><p>解决方法：</p><pre><code>ln -s /home/dbdev/mysql/mysql/mysql.sock /tmp/mysql.sock</code></pre><p>或者</p><pre class=" language-shell"><code class="language-shell">./mysql/bin/mysql -u root -p -S /home/dbtest/mysql/mysql/mysql.sock</code></pre><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><pre class=" language-shell"><code class="language-shell">set password for 'root'@'localhost' = password('nh123456');flush privileges;</code></pre><h2 id="开启远程控制"><a href="#开启远程控制" class="headerlink" title="开启远程控制"></a>开启远程控制</h2><pre class=" language-shell"><code class="language-shell">grant all privileges on 数据库名.表名 to 创建的用户名(root)@"%" identified by "密码"; # 数据库名.表名 如果写成*.*代表授权所有的数据库 # grant all privileges on *.* to root@"113.64.243.1" identified by "123456789";# grant all privileges on *.* to 'root'@'%' identified by 'nh123456' with grant option;flush privileges;</code></pre><p>@ 后面是访问mysql的客户端IP地址（或是 主机名） % 代表任意的客户端，如果填写 localhost 为本地访问（那此用户就不能远程访问该mysql数据库了）。</p><p>同时也可以为现有的用户设置是否具有远程访问权限。</p><h2 id="停止mysqld-safe模式改为正常启动"><a href="#停止mysqld-safe模式改为正常启动" class="headerlink" title="停止mysqld_safe模式改为正常启动"></a>停止mysqld_safe模式改为正常启动</h2><pre class=" language-shell"><code class="language-shell">ps -ef|grep mysql kill -9 30379./mysql/bin/mysqld --defaults-file=/home/dbdev/mysql/mysql/mysql.cnf  --user=dbdev &</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下Cornerstone添加外部对比工具Beyond Compare</title>
      <link href="/cornerstone.html"/>
      <url>/cornerstone.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下Cornerstone添加外部对比工具Beyond-Compare"><a href="#Mac下Cornerstone添加外部对比工具Beyond-Compare" class="headerlink" title="Mac下Cornerstone添加外部对比工具Beyond Compare"></a>Mac下Cornerstone添加外部对比工具Beyond Compare</h1><h2 id="Beyond-Compare-安装命令行工具"><a href="#Beyond-Compare-安装命令行工具" class="headerlink" title="Beyond Compare 安装命令行工具"></a>Beyond Compare 安装命令行工具</h2><p>点击 Beyond Compare-》安装命令行工具</p><p><img src="https://img.iamghf.top/blog/2020-06-08-072826.png" alt="image-20200605103951242"></p><h2 id="创建shell脚本"><a href="#创建shell脚本" class="headerlink" title="创建shell脚本"></a>创建shell脚本</h2><pre class=" language-shell"><code class="language-shell">vim bc.sh</code></pre><p>内容如下：</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashoriginal_path="$1"modified_path="$3"/usr/local/bin/bcompare"$original_path" "$modified_path"</code></pre><p>授权可执行 <strong>chmod +x bc.sh</strong></p><h2 id="Cornerstone-添加脚本"><a href="#Cornerstone-添加脚本" class="headerlink" title="Cornerstone 添加脚本"></a>Cornerstone 添加脚本</h2><p>prefrences-&gt;general-&gt;external compare tool-&gt;open script foder</p><p>将bc.sh文件移动到此目录</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
            <tag> Cornerstone </tag>
            
            <tag> byond compare </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeyondCompare</title>
      <link href="/beyondcompare.html"/>
      <url>/beyondcompare.html</url>
      
        <content type="html"><![CDATA[<h1 id="苹果系统白嫖BeyondCompare"><a href="#苹果系统白嫖BeyondCompare" class="headerlink" title="苹果系统白嫖BeyondCompare"></a>苹果系统白嫖BeyondCompare</h1><h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><p><a href="https://www.scootersoftware.com/download.php" target="_blank" rel="noopener">官网下载</a></p><p>解压缩 拖至应用程序目录</p><h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><p>打开终端进入安装好的Beyond Compare目录</p><pre class=" language-shell"><code class="language-shell">cd /Applications/Beyond Compare.app/Contents/MacOS</code></pre><h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><p>修改启动程序文件BCompare为BCompare.real</p><pre><code>mv BCompare BCompare.real</code></pre><h2 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h2><p>当前目录下新建一个文件BCompare</p><pre><code>vim BCompare</code></pre><h2 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h2><p>输入以下内容</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashrm "/Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat""`dirname "$0"`"/BCompare.real $@</code></pre><h2 id="step6"><a href="#step6" class="headerlink" title="step6"></a>step6</h2><p>修改文件权限</p><pre class=" language-shell"><code class="language-shell">chmod a+x /Applications/Beyond\ Compare.app/Contents/MacOS/BCompare</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> beyondcompare </tag>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet 工作原理</title>
      <link href="/servlet-gong-zuo-yuan-li.html"/>
      <url>/servlet-gong-zuo-yuan-li.html</url>
      
        <content type="html"><![CDATA[<h2 id="从-Servlet-容器说起"><a href="#从-Servlet-容器说起" class="headerlink" title="从 Servlet 容器说起"></a>从 Servlet 容器说起</h2><p>要介绍 Servlet 必须要先把 Servlet 容器说清楚，Servlet 与 Servlet 容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。虽然它们是彼此依存的，但是又相互独立发展，这一切都是为了适应工业化生产的结果。从技术角度来说是为了解耦，通过标准化接口来相互协作。既然接口是连接 Servlet 与 Servlet 容器的关键，那我们就从它们的接口说起。</p><p>前面说了 Servlet 容器作为一个独立发展的标准化产品，目前它的种类很多，但是它们都有自己的市场定位，很难说谁优谁劣，各有特点。例如现在比较流行的 Jetty，在定制化和移动领域有不错的发展，我们这里还是以大家最为熟悉 Tomcat 为例来介绍 Servlet 容器如何管理 Servlet。Tomcat 本身也很复杂，我们只从 Servlet 与 Servlet 容器的接口部分开始介绍，关于 Tomcat 的详细介绍可以参考我的另外一篇文章《 Tomcat 系统架构与模式设计分析》。</p><p>Tomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式。</p><h5 id="图-1-Tomcat-容器模型"><a href="#图-1-Tomcat-容器模型" class="headerlink" title="图 1 . Tomcat 容器模型"></a>图 1 . Tomcat 容器模型</h5><p><img src="https://img.iamghf.top/blog/20200421150709.png" alt="Tomcat 容器模型"></p><p>从上图可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程，在 Tomcat 的配置文件中可以很容易发现这一点，如下：</p><h5 id="清单-1-Context-配置参数"><a href="#清单-1-Context-配置参数" class="headerlink" title="清单 1 Context 配置参数"></a>清单 1 Context 配置参数</h5><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Context</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/projectOne <span class="token punctuation">"</span></span> <span class="token attr-name">docBase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>D:\projects\projectOne<span class="token punctuation">"</span></span>         <span class="token attr-name">reloadable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>下面详细介绍一下 Tomcat 解析 Context 容器的过程，包括如何构建 Servlet 的过程。</p><h3 id="Servlet-容器的启动过程"><a href="#Servlet-容器的启动过程" class="headerlink" title="Servlet 容器的启动过程"></a>Servlet 容器的启动过程</h3><p>Tomcat7 也开始支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，我们还可以通过这个对象来增加和修改 Tomcat 的配置参数，如可以动态增加 Context、Servlet 等。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。</p><h5 id="清单-2-给-Tomcat-增加一个-Web-工程"><a href="#清单-2-给-Tomcat-增加一个-Web-工程" class="headerlink" title="清单 2 . 给 Tomcat 增加一个 Web 工程"></a>清单 2 . 给 Tomcat 增加一个 Web 工程</h5><pre class=" language-java"><code class="language-java">Tomcat tomcat <span class="token operator">=</span> <span class="token function">getTomcatInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> File appDir <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token function">getBuildDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"webapps/examples"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tomcat<span class="token punctuation">.</span><span class="token function">addWebapp</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"/examples"</span><span class="token punctuation">,</span> appDir<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tomcat<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ByteChunk res <span class="token operator">=</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token string">"http://localhost:"</span> <span class="token operator">+</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                         <span class="token string">"/examples/servlets/servlet/HelloWorldExample"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">assertTrue</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"&lt;h1>Hello World!&lt;/h1>"</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 1 的代码是创建一个 Tomcat 实例并新增一个 Web 应用，然后启动 Tomcat 并调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。</p><p>Tomcat 的 addWebapp 方法的代码如下：</p><h5 id="清单-3-Tomcat-addWebapp"><a href="#清单-3-Tomcat-addWebapp" class="headerlink" title="清单 3 .Tomcat.addWebapp"></a>清单 3 .Tomcat.addWebapp</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Context <span class="token function">addWebapp</span><span class="token punctuation">(</span>Host host<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> String path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">silence</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        Context ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">setPath</span><span class="token punctuation">(</span> url <span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">setDocBase</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>defaultRealm <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">initSimpleAuth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ctx<span class="token punctuation">.</span><span class="token function">setRealm</span><span class="token punctuation">(</span>defaultRealm<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">addLifecycleListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultWebXmlListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ContextConfig ctxCfg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ContextConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">addLifecycleListener</span><span class="token punctuation">(</span>ctxCfg<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctxCfg<span class="token punctuation">.</span><span class="token function">setDefaultWebXml</span><span class="token punctuation">(</span><span class="token string">"org/apache/catalin/startup/NO_DEFAULT_XML"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>host <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            host<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ctx<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>前面已经介绍了一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径，这个两个参数与清单 1 中的两个参数是一致的。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作，后面将会详细介绍。最后将这个 Context 容器加到父容器 Host 中。</p><p>接下去将会调用 Tomcat 的 start 方法启动 Tomcat，如果你清楚 Tomcat 的系统架构，你会容易理解 Tomcat 的启动逻辑，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener），关于这个设计模式可以参考《 Tomcat 的系统架构与设计模式，第二部分：设计模式》。Tomcat 启动的时序图可以用图 2 表示。</p><h5 id="图-2-Tomcat-主要类的启动时序图（查看大图）"><a href="#图-2-Tomcat-主要类的启动时序图（查看大图）" class="headerlink" title="图 2. Tomcat 主要类的启动时序图（查看大图）"></a>图 2. Tomcat 主要类的启动时序图（<a href="https://img.iamghf.top/blog/20200421151241.png" target="_blank" rel="noopener">查看大图</a>）</h5><p><img src="https://img.iamghf.top/blog/20200421151241.png" alt="图 2. Tomcat 主要类的启动时序图"></p><p>上图描述了 Tomcat 启动过程中，主要类之间的时序关系，下面我们将会重点关注添加 examples 应用所对应的 StandardContext 容器的启动过程。</p><p>当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用清单 3 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。</p><p>ContextConfig 的 init 方法将会主要完成以下工作：</p><ol><li>创建用于解析 xml 配置文件的 contextDigester 对象</li><li>读取默认 context.xml 配置文件，如果存在解析它</li><li>读取默认 Host 配置文件，如果存在解析它</li><li>读取默认 Context 自身的配置文件，如果存在解析它</li><li>设置 Context 的 DocBase</li></ol><p>ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：</p><ol><li>创建读取资源文件的对象</li><li>创建 ClassLoader 对象</li><li>设置应用的工作目录</li><li>启动相关的辅助类如：logger、realm、resources 等</li><li>修改启动状态，通知感兴趣的观察者（Web 应用的配置）</li><li>子容器的初始化</li><li>获取 ServletContext 并设置必要的参数</li><li>初始化“load on startup”的 Servlet</li></ol><h3 id="Web-应用的初始化工作"><a href="#Web-应用的初始化工作" class="headerlink" title="Web 应用的初始化工作"></a>Web 应用的初始化工作</h3><p>Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。</p><p>Tomcat 首先会找 globalWebXml 这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。接着会找 hostWebXml 这个文件可能会在 System.getProperty(“catalina.base”)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。如果当前应用支持 Servlet3.0，解析还将完成额外 9 项工作，这个额外的 9 项工作主要是为 Servlet3.0 新增的特性，包括 jar 包中的 META-INF/web-fragment.xml 的解析以及对 annotations 的支持。</p><p>接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。下面是解析 Servlet 的代码片段：</p><h5 id="清单-4-创建-Wrapper-实例"><a href="#清单-4-创建-Wrapper-实例" class="headerlink" title="清单 4. 创建 Wrapper 实例"></a>清单 4. 创建 Wrapper 实例</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>ServletDef servlet <span class="token operator">:</span> servlets<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Wrapper wrapper <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">createWrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String jspFile <span class="token operator">=</span> servlet<span class="token punctuation">.</span><span class="token function">getJspFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>jspFile <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">setJspFile</span><span class="token punctuation">(</span>jspFile<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getLoadOnStartup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getLoadOnStartup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">setEnabled</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">booleanValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            wrapper<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getServletName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> params <span class="token operator">=</span> servlet<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> params<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">addInitParameter</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            wrapper<span class="token punctuation">.</span><span class="token function">setRunAs</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getRunAs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>SecurityRoleRef<span class="token operator">></span> roleRefs <span class="token operator">=</span> servlet<span class="token punctuation">.</span><span class="token function">getSecurityRoleRefs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>SecurityRoleRef roleRef <span class="token operator">:</span> roleRefs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">addSecurityReference</span><span class="token punctuation">(</span> roleRef<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> roleRef<span class="token punctuation">.</span><span class="token function">getLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            wrapper<span class="token punctuation">.</span><span class="token function">setServletClass</span><span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getServletClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            MultipartDef multipartdef <span class="token operator">=</span> servlet<span class="token punctuation">.</span><span class="token function">getMultipartDef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>multipartdef <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>multipartdef<span class="token punctuation">.</span><span class="token function">getMaxFileSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                        multipartdef<span class="token punctuation">.</span><span class="token function">getMaxRequestSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                        multipartdef<span class="token punctuation">.</span><span class="token function">getFileSizeThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    wrapper<span class="token punctuation">.</span><span class="token function">setMultipartConfigElement</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MultipartConfigElement</span><span class="token punctuation">(</span>                            multipartdef<span class="token punctuation">.</span><span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Long<span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>multipartdef<span class="token punctuation">.</span><span class="token function">getMaxFileSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Long<span class="token punctuation">.</span><span class="token function">parseLong</span><span class="token punctuation">(</span>multipartdef<span class="token punctuation">.</span><span class="token function">getMaxRequestSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span> multipartdef<span class="token punctuation">.</span><span class="token function">getFileSizeThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    wrapper<span class="token punctuation">.</span><span class="token function">setMultipartConfigElement</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MultipartConfigElement</span><span class="token punctuation">(</span>                            multipartdef<span class="token punctuation">.</span><span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>servlet<span class="token punctuation">.</span><span class="token function">getAsyncSupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                wrapper<span class="token punctuation">.</span><span class="token function">setAsyncSupported</span><span class="token punctuation">(</span>                        servlet<span class="token punctuation">.</span><span class="token function">getAsyncSupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">booleanValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            context<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>这段代码清楚的描述了如何将 Servlet 包装成 Context 容器中的 StandardWrapper，这里有个疑问，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象。这里 StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。</p><p>除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。</p><h2 id="创建-Servlet-实例"><a href="#创建-Servlet-实例" class="headerlink" title="创建 Servlet 实例"></a>创建 Servlet 实例</h2><p>前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。</p><h3 id="创建-Servlet-对象"><a href="#创建-Servlet-对象" class="headerlink" title="创建 Servlet 对象"></a>创建 Servlet 对象</h3><p>如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。</p><p>创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。</p><p>创建 Servlet 对象的相关类结构图如下：</p><h5 id="图-3-创建-Servlet-对象的相关类结构"><a href="#图-3-创建-Servlet-对象的相关类结构" class="headerlink" title="图 3. 创建 Servlet 对象的相关类结构"></a>图 3. 创建 Servlet 对象的相关类结构</h5><p><img src="https://img.iamghf.top/blog/20200421151712.png" alt="图 3. 创建 Servlet 对象的相关类结构"></p><h3 id="初始化-Servlet"><a href="#初始化-Servlet" class="headerlink" title="初始化 Servlet"></a>初始化 Servlet</h3><p>初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。</p><p>如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。</p><p>这样 Servlet 对象就初始化完成了，事实上 Servlet 从被 web.xml 中解析到完成初始化，这个过程非常复杂，中间有很多过程，包括各种容器状态的转化引起的监听事件的触发、各种访问权限的控制和一些不可预料的错误发生的判断行为等等。我们这里只抓了一些关键环节进行阐述，试图让大家有个总体脉络。</p><p>下面是这个过程的一个完整的时序图，其中也省略了一些细节。</p><h5 id="图-4-初始化-Servlet-的时序图（查看大图）"><a href="#图-4-初始化-Servlet-的时序图（查看大图）" class="headerlink" title="图 4. 初始化 Servlet 的时序图（查看大图）"></a>图 4. 初始化 Servlet 的时序图（<a href="https://img.iamghf.top/blog/20200421151808.png" target="_blank" rel="noopener">查看大图</a>）</h5><p><img src="https://img.iamghf.top/blog/20200421151808.png" alt="图 4. 初始化 Servlet 的时序图"></p><h2 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h2><p>我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。</p><h5 id="图-5-Servlet-顶层类关联图"><a href="#图-5-Servlet-顶层类关联图" class="headerlink" title="图 5.Servlet 顶层类关联图"></a>图 5.Servlet 顶层类关联图</h5><p><img src="https://img.iamghf.top/blog/20200421151900.png" alt="图 5.Servlet 顶层类关联图"></p><p>从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。</p><p>ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？</p><p>下图是 ServletConfig 和 ServletContext 在 Tomcat 容器中的类关系图。</p><h5 id="图-6-ServletConfig-在容器中的类关联图"><a href="#图-6-ServletConfig-在容器中的类关联图" class="headerlink" title="图 6. ServletConfig 在容器中的类关联图"></a>图 6. ServletConfig 在容器中的类关联图</h5><p><img src="https://img.iamghf.top/blog/20200421151937.png" alt="图 6. ServletConfig 在容器中的类关联图"></p><p>上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类。所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。</p><p>同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。</p><p>通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。</p><p>Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？</p><h5 id="图-7-Request-相关类结构图"><a href="#图-7-Request-相关类结构图" class="headerlink" title="图 7.Request 相关类结构图"></a>图 7.Request 相关类结构图</h5><p><img src="https://img.iamghf.top/blog/20200421152021.png" alt="图 7.Request 相关类结构图"></p><p>上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示：</p><h5 id="图-8-Request-和-Response-的转变过程"><a href="#图-8-Request-和-Response-的转变过程" class="headerlink" title="图 8.Request 和 Response 的转变过程"></a>图 8.Request 和 Response 的转变过程</h5><p><img src="https://img.iamghf.top/blog/20200421152101.png" alt="图 8.Request 和 Response 的转变过程"></p><h2 id="Servlet-如何工作"><a href="#Servlet-如何工作" class="headerlink" title="Servlet 如何工作"></a>Servlet 如何工作</h2><p>我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。</p><p>当用户从浏览器向服务器发起一个请求，通常会包含如下信息：<a href="http://hostname" target="_blank" rel="noopener">http://hostname</a>: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？</p><p>Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。</p><h5 id="图-9-Request-的-Mapper-类关系图"><a href="#图-9-Request-的-Mapper-类关系图" class="headerlink" title="图 9.Request 的 Mapper 类关系图"></a>图 9.Request 的 Mapper 类关系图</h5><p><img src="https://img.iamghf.top/blog/20200421152145.png" alt="图 9.Request 的 Mapper 类关系图"></p><p>可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 :</p><h5 id="清单-5-MapperListener-init"><a href="#清单-5-MapperListener-init" class="headerlink" title="清单 5. MapperListener.init"></a>清单 5. MapperListener.init</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">findDefaultHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Engine engine <span class="token operator">=</span> <span class="token punctuation">(</span>Engine<span class="token punctuation">)</span> connector<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        engine<span class="token punctuation">.</span><span class="token function">addContainerListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Container<span class="token punctuation">[</span><span class="token punctuation">]</span> conHosts <span class="token operator">=</span> engine<span class="token punctuation">.</span><span class="token function">findChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Container conHost <span class="token operator">:</span> conHosts<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Host host <span class="token operator">=</span> <span class="token punctuation">(</span>Host<span class="token punctuation">)</span> conHost<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>LifecycleState<span class="token punctuation">.</span>NEW<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                host<span class="token punctuation">.</span><span class="token function">addLifecycleListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">registerHost</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。</p><h5 id="图-10-Request-在容器中的路由图"><a href="#图-10-Request-在容器中的路由图" class="headerlink" title="图 10.Request 在容器中的路由图"></a>图 10.Request 在容器中的路由图</h5><p><img src="https://img.iamghf.top/blog/20200421152255.png" alt="图 10.Request 在容器中的路由图"></p><p>上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。</p><p>接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。</p><p>Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。</p><p>当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。</p><h2 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h2><p>前面我们已经说明了 Servlet 如何被调用，我们基于 Servlet 来构建应用程序，那么我们能从 Servlet 获得哪些数据信息呢？</p><p>Servlet 能够给我们提供两部分数据，一个是在 Servlet 初始化时调用 init 方法时设置的 ServletConfig，这个类基本上含有了 Servlet 本身和 Servlet 所运行的 Servlet 容器中的基本信息。根据前面的介绍 ServletConfig 的实际对象是 StandardWrapperFacade，到底能获得哪些容器信息可以看看这类提供了哪些接口。还有一部分数据是由 ServletRequest 类提供，它的实际对象是 RequestFacade，从提供的方法中发现主要是描述这次请求的 HTTP 协议的信息。所以要掌握 Servlet 的工作方式必须要很清楚 HTTP 协议，如果你还不清楚赶紧去找一些参考资料。关于这一块还有一个让很多人迷惑的 Session 与 Cookie。</p><p>Session 与 Cookie 不管是对 Java Web 的熟练使用者还是初学者来说都是一个令人头疼的东西。Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态。它们有各自的优点也有各自的缺陷。然而具有讽刺意味的是它们优点和它们的使用场景又是矛盾的，例如使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如 Cookie 占用 200 个字节，如果一天的 PV 有几亿的时候，它要占用多少带宽。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用。</p><p>不管 Session 和 Cookie 有什么不足，我们还是要用它们。下面详细讲一下，Session 如何基于 Cookie 来工作。实际上有三种方式能可以让 Session 正常工作：</p><ol><li>基于 URL Path Parameter，默认就支持</li><li>基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的</li><li>基于 SSL，默认不支持，只有 connector.getAttribute(“SSLEnabled”) 为 TRUE 时才支持</li></ol><p>第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 SessionCookieName 重写到用户请求的 URL 参数中，它的传递格式如 /path/Servlet;name=value;name2=value2? Name3=value3，其中“Servlet；”后面的 K-V 对就是要传递的 Path Parameters，服务器会从这个 Path Parameters 中拿到用户配置的 SessionCookieName。关于这个 SessionCookieName，如果你在 web.xml 中配置 session-config 配置项的话，其 cookie-config 下的 name 属性就是这个 SessionCookieName 值，如果你没有配置 session-config 配置项，默认的 SessionCookieName 就是大家熟悉的“JSESSIONID”。接着 Request 根据这个 SessionCookieName 到 Parameters 拿到 Session ID 并设置到 request.setRequestedSessionId 中。</p><p>请注意如果客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。</p><p>如果是第三种情况的话将会根据 javax.servlet.request.ssl_session 属性值设置 Session ID。</p><p>有了 Session ID 服务器端就可以创建 HttpSession 对象了，第一次触发是通过 request. getSession() 方法，如果当前的 Session ID 还没有对应的 HttpSession 对象那么就创建一个新的，并将这个对象加到 org.apache.catalina. Manager 的 sessions 容器中保存，Manager 类将管理所有 Session 的生命周期，Session 过期将被回收，服务器关闭，Session 将被序列化到磁盘等。只要这个 HttpSession 对象存在，用户就可以根据 Session ID 来获取到这个对象，也就达到了状态的保持。</p><h5 id="图-11-Session-相关类图"><a href="#图-11-Session-相关类图" class="headerlink" title="图 11.Session 相关类图"></a>图 11.Session 相关类图</h5><p><img src="https://img.iamghf.top/blog/20200421152346.png" alt="图 11.Session 相关类图"></p><p>上从图中可以看出从 request.getSession 中获取的 HttpSession 对象实际上是 StandardSession 对象的门面对象，这与前面的 Request 和 Servlet 是一样的原理。下图是 Session 工作的时序图：</p><h5 id="图-12-Session-工作的时序图（查看大图）"><a href="#图-12-Session-工作的时序图（查看大图）" class="headerlink" title="图 12.Session 工作的时序图（查看大图）"></a>图 12.Session 工作的时序图（<a href="https://img.iamghf.top/blog/20200421152357.png" target="_blank" rel="noopener">查看大图</a>）</h5><p><img src="https://img.iamghf.top/blog/20200421152357.png" alt="图 12.Session 工作的时序图"></p><p>还有一点与 Session 关联的 Cookie 与其它 Cookie 没有什么不同，这个配置的配置可以通过 web.xml 中的 session-config 配置项来指定。</p><h2 id="Servlet-中的-Listener"><a href="#Servlet-中的-Listener" class="headerlink" title="Servlet 中的 Listener"></a>Servlet 中的 Listener</h2><p>整个 Tomcat 服务器中 Listener 使用的非常广泛，它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。如下图所示：</p><h5 id="图-13-Servlet-中的-Listener"><a href="#图-13-Servlet-中的-Listener" class="headerlink" title="图 13.Servlet 中的 Listener"></a>图 13.Servlet 中的 Listener</h5><p><img src="https://img.iamghf.top/blog/20200421152411.png" alt="图 13.Servlet 中的 Listener"></p><p>它们基本上涵盖了整个 Servlet 生命周期中，你感兴趣的每种事件。这些 Listener 的实现类可以配置在 web.xml 中的 <listener> 标签中。当然也可以在应用程序中动态添加 Listener，需要注意的是 ServletContextListener 在容器启动之后就不能再添加新的，因为它所监听的事件已经不会再出现。掌握这些 Listener 的使用，能够让我们的程序设计的更加灵活。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文涉及到内容有点多，要把每个细节都说清楚，似乎不可能，本文试着从 Servlet 容器的启动到 Servlet 的初始化，以及 Servlet 的体系结构等这些环节中找出一些重点来讲述，目的是能读者有一个总体的完整的结构图，同时也详细分析了其中的一些难点问题，希望对大家有所帮助。</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启用https</title>
      <link href="/qi-yong-https.html"/>
      <url>/qi-yong-https.html</url>
      
        <content type="html"><![CDATA[<p>基于 acme.sh从Let’s Encrypt生成免费的泛域名证书</p><h2 id="安装acme-sh"><a href="#安装acme-sh" class="headerlink" title="安装acme.sh"></a>安装acme.sh</h2><pre class=" language-shell"><code class="language-shell"># 安装依赖环境 yum -y install curl cron socat# 下载并安装acme.sh curl  https://get.acme.sh | shsource ~/.bashrc</code></pre><h2 id="申请域名解析服务商API-token-，完成DNS验证"><a href="#申请域名解析服务商API-token-，完成DNS验证" class="headerlink" title="申请域名解析服务商API token ，完成DNS验证"></a>申请域名解析服务商API token ，完成DNS验证</h2><p>DNS验证的意义在于证明域名的所有人是你，而不是别人。acme.sh不是随随便便就就能操作当前域名的DNS解析记录的，必须通过当前域名的<strong>域名注册服务商</strong>授权才可以。这就需要用到了<code>API token</code></p><ul><li><table><thead><tr><th align="left">服务商名称</th><th align="left">服务商简称</th><th align="left">所需API参数</th><th align="left">获取API参数地址</th></tr></thead><tbody><tr><td align="left">cloudxns</td><td align="left">cx</td><td align="left">export CX_Key=”123456” export CX_Secret=”abcdef”</td><td align="left"><a href="https://www.cloudxns.net/AccountManage/apimanage.html" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">dnspod (cn大陆版)</td><td align="left">dp</td><td align="left">export DP_Id=”123456” export DP_Key=”abcdef”</td><td align="left"><a href="https://www.dnspod.cn/console/user/security" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left"><a href="https://www.vpser.net/go/aliyun" target="_blank" rel="noopener">aliyun</a></td><td align="left">ali</td><td align="left">export Ali_Key=”123456” export Ali_Secret=”abcdef”</td><td align="left"><a href="https://ak-console.aliyun.com/#/accesskey" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">cloudflare</td><td align="left">cf</td><td align="left">export CF_Key=”123456” export CF_Email=”<a href="mailto:abc@example.com">abc@example.com</a>“</td><td align="left"><a href="https://dash.cloudflare.com/profile/api-tokens" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left"><a href="https://www.vpser.net/go/linode" target="_blank" rel="noopener">linode</a></td><td align="left">linode</td><td align="left">export LINODE_API_KEY=”123456”</td><td align="left"><a href="https://manager.linode.com/profile/api" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">he</td><td align="left">he</td><td align="left">export HE_Username=”username” export HE_Password=”password”</td><td align="left"><a href="https://dns.he.net/" target="_blank" rel="noopener">he</a>的用户名密码</td></tr><tr><td align="left"><a href="https://www.vpser.net/go/digitalocean" target="_blank" rel="noopener">digitalocean</a></td><td align="left">dgon</td><td align="left">export DO_API_KEY=”123456”</td><td align="left"><a href="https://cloud.digitalocean.com/settings/applications" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left"><a href="https://www.vpser.net/go/namesilo" target="_blank" rel="noopener">namesilo</a></td><td align="left">namesilo</td><td align="left">export Namesilo_Key=”123456”</td><td align="left"><a href="https://www.namesilo.com/account_api.php" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">aws</td><td align="left">aws</td><td align="left">export AWS_ACCESS_KEY_ID=123456 export AWS_SECRET_ACCESS_KEY=abcdef</td><td align="left"><a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left"><a href="https://www.vpser.net/go/name" target="_blank" rel="noopener">namecom</a></td><td align="left">namecom</td><td align="left">export Namecom_Username=”username” export Namecom_Token=”123456”</td><td align="left"><a href="https://www.name.com/reseller/apply" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">freedns</td><td align="left">freedns</td><td align="left">export FREEDNS_User=”username” export FREEDNS_Password=”password”</td><td align="left"><a href="https://freedns.afraid.org/" target="_blank" rel="noopener">freedns</a>的用户名密码</td></tr><tr><td align="left">godaddy</td><td align="left">gd</td><td align="left">export GD_Key=”123456” export GD_Secret=”abcdef”</td><td align="left"><a href="https://developer.godaddy.com/keys/" target="_blank" rel="noopener">点击访问</a></td></tr><tr><td align="left">yandex</td><td align="left">yandex</td><td align="left">export PDD_Token=”abcdef”</td><td align="left"><a href="https://tech.yandex.com/domain/doc/concepts/access-docpage/" target="_blank" rel="noopener">点击访问</a></td></tr></tbody></table></li></ul><p>我使用的是阿里云，对应的命令为：</p><pre class=" language-shell"><code class="language-shell">export Ali_Key="xxxxxx"export Ali_Secret="xxxxxxxxxxxxxxxxxxxxxxxxxx"</code></pre><h2 id="生成泛域名证书"><a href="#生成泛域名证书" class="headerlink" title="生成泛域名证书"></a>生成泛域名证书</h2><p>多域名，可以使用 -d 参数添加</p><p><code>--keylength ec-256</code> 是签发 ECC 类型的证书，它的安全性更高，删除则使用默认的 RSA 证书</p><pre class=" language-shell"><code class="language-shell">acme.sh --issue --dns dns_ali -d iamghf.top  --keylength ec-256 --standalone</code></pre><h2 id="复制证书"><a href="#复制证书" class="headerlink" title="复制证书"></a>复制证书</h2><p>证书已经签发了，不过默认是保存在 <code>~/.acme.sh/</code> 里</p><pre class=" language-shell"><code class="language-shell">acme.sh --ecc --installcert -d iamghf.top         --key-file /etc/nginx/cert/iamghf.top.key         --fullchain-file /etc/nginx/cert/iamghf.top.cer         --reloadcmd "/usr/sbin/nginx -s reload"</code></pre><p>指定域名，指定证书保存目录，我这里设置在 <code>/etc/nginx/cert/</code>，指定 Nginx 重载命令，如果签发的不是 ECC 证书，把 <code>--ecc</code> 参数去掉</p><p>这样使用 acme.sh 就完成了证书的签发，如果证书快要过期了，脚本会自动更新证书</p><p>脚本自动更新，可以使用以下命令</p><pre class=" language-shell"><code class="language-shell">acme.sh --upgrade --auto-upgrade</code></pre><h2 id="未解决的问题"><a href="#未解决的问题" class="headerlink" title="未解决的问题"></a>未解决的问题</h2><p>启用https后 发现chrome浏览网站时并不是全绿</p><p><img src="https://img.iamghf.top/blog/20200414152144.png" alt=""></p><p>查了下是因为页面还有其他 http 资源，也就是所谓的 <strong>Mixed Content</strong>，开启调试模式看了下是用的图床没启用https，懒得折腾了有空再修复吧。</p><p><img src="https://img.iamghf.top/blog/20200414152649.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acme.sh </tag>
            
            <tag> ssl </tag>
            
            <tag> Let’s Encrypt </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫威宇宙其实也就讲了一件事</title>
      <link href="/man-wei-yu-zhou-qi-shi-ye-jiu-jiang-liao-yi-jian-shi.html"/>
      <url>/man-wei-yu-zhou-qi-shi-ye-jiu-jiang-liao-yi-jian-shi.html</url>
      
        <content type="html"><![CDATA[<p>整个宇宙就好比一个git项目，其中有一群叫做美国队长，钢铁侠，惊奇队长，浩克，索尔等人在维护这个项目，兢兢业业的修理bug。</p><p>某一天出现了一个天才程序员，叫灭霸，也在这个项目中开发，他意识到，这个项目已经很庞大了，光是编译都要几个小时，运行起来负重累累，而服务器资源就这么有限，老板又不给买机器，如果一直继续这么开发下去，这个项目迟早要出现网P0事故的，于是下定决定要把这个项目用面向对象，提取重复代码，业务拆分，算法优化等手段，彻底优化，目标是代码量减少50%。</p><p>美国队长的项目组叫复仇者联盟，发现了灭霸程序员的想法后，阻止并警告灭霸说，：不要轻易去改老代码！！，很容易出bug的，代码能跑就行！！！</p><p>然而，这名叫灭霸的程序员兢兢业业，取得了公司6位大股东（对应6颗宝石）的支持，带领团队996加班1个月，实现代码量减少50%，项目运行起来身轻如燕。</p><p>因为代码量减少了很多，万恶的资本主义也开始了大裁员，星爵项目组，蜘蛛侠，猩红女巫，就连拥有博士学位的奇异博士也被裁员了。</p><p>大裁员之后，美国队长为首的项目组，强忍悲伤，面对生活，继续开发修理bug，但是像雷神索尔，因为不满意公司的做法，开始磨洋工，上班就打游戏喝饮料，等着被公司裁拿补偿金。</p><p>有一天一个叫蚁人的码农，找到了美国队长说，回退是不可能回退的了，但是我们可以把以前的老代码重新merge到master上来呀。</p><p>美国队长作为项目组的组长，想到以前的同事失业，内心很愧疚，于是偷偷摸摸兵分五路请6位大股东喝酒吃饭，威逼利诱，拿到了现网服务器账号！</p><p>代码成功回退，很多之前失业的员工被返聘，像童工蜘蛛侠，外包团队瓦坎达等。</p><p>灭霸发现之后，大怒道，你们这群沉迷老技术的稳定派，我要把整个项目用scala重构，让你们这群渣渣程序员都失业！</p><p>最后，灭霸由于太过激进，在项目中屡次采用新技术，现网屡出事故，项目灭霸的重构项目组被董事会辞退。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漫威 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网线单线复用</title>
      <link href="/wang-xian-dan-xian-fu-yong.html"/>
      <url>/wang-xian-dan-xian-fu-yong.html</url>
      
        <content type="html"><![CDATA[<h1 id="网线单线复用"><a href="#网线单线复用" class="headerlink" title="网线单线复用"></a>网线单线复用</h1><p>家里装修时从弱电箱到客厅只埋了一根网线，家里宽带只有100M的带宽，采取的是将网线一分为二的廉价方式来满足同时使用宽带和IPTV服务。最近电信推出了宽带免费提速的政策，可以提速至200M。本着物尽其用的原则，将家里的线路进行升级改造，实现千兆局域网。</p><p>网络拓扑图如下：</p><p><img src="https://img.iamghf.top/blog/20200325144858.png" alt=""></p><p>vlan交换机设置：</p><p>vlan交换机我用的是网件的GS105E</p><table><thead><tr><th>vlan</th><th>端口1</th><th>端口2</th><th>端口3</th><th>端口4</th><th>端口5</th></tr></thead><tbody><tr><td>1</td><td>U</td><td>U</td><td>U</td><td>U</td><td>U</td></tr><tr><td>45</td><td>T</td><td>U</td><td></td><td></td><td></td></tr><tr><td>12</td><td>T</td><td></td><td>U</td><td>U</td><td>U</td></tr></tbody></table><p>PVID</p><table><thead><tr><th>端口</th><th>PVID值</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>45</td></tr><tr><td>3</td><td>12</td></tr><tr><td>4</td><td>12</td></tr><tr><td>5</td><td>12</td></tr></tbody></table><p>升级后效果：</p><p><img src="https://img.iamghf.top/blog/20200325150715.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VLAN </tag>
            
            <tag> 交换机 </tag>
            
            <tag> 宽带 </tag>
            
            <tag> 电信 </tag>
            
            <tag> 单线复用 </tag>
            
            <tag> 满速带宽 </tag>
            
            <tag> 千兆 </tag>
            
            <tag> 提速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派开箱</title>
      <link href="/shu-mei-pai-kai-xiang.html"/>
      <url>/shu-mei-pai-kai-xiang.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派开箱"><a href="#树莓派开箱" class="headerlink" title="树莓派开箱"></a>树莓派开箱</h1><p>默认密码： pi/raspberry</p><p>sudo apt-get update — 更新软件源</p><p>sudo apt-get upgrade — 根据新的软件源来自动更新本地的包</p><p>sudo reboot</p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>sudo passwd pi</p><h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><p>树莓派自带的vi编辑器用不习惯，so</p><p>sudo apt-get install vim</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>官方一键安装脚本</p><pre class=" language-shell"><code class="language-shell">sudo` `curl -sSL https://get.docker.com | sh</code></pre><p><img src="https://img.iamghf.top/blog/20200318133751.png" alt=""></p><h3 id="无需sudo执行docker"><a href="#无需sudo执行docker" class="headerlink" title="无需sudo执行docker"></a>无需sudo执行docker</h3><pre class=" language-shell"><code class="language-shell"># 创建docker用户组sudo groupadd docker# 把当前用户加入到docker用户组sudo gpasswd -a $USER docker# 更新当前用户组变动（就不用退出并重新登录了）newgrp docker</code></pre><h3 id="安装可视工具portainer"><a href="#安装可视工具portainer" class="headerlink" title="安装可视工具portainer"></a>安装可视工具portainer</h3><pre class=" language-shell"><code class="language-shell">#下载镜像docker pull portainer/portainer</code></pre><pre class=" language-shell"><code class="language-shell">#运行docker run -d -p 9000:9000     --restart=always     -v /var/run/docker.sock:/var/run/docker.sock     -v /data/portainer:/data    --name prtainer    portainer/portainer</code></pre><p>访问页面 <a href="http://ip:9000" target="_blank" rel="noopener">http://ip:9000</a> 设置用户名和密码  选择local模式</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>安装frp</p><p>已有公网服务器 配置如下：</p><p><img src="https://img.iamghf.top/blog/20200324105756.png" alt=""></p><p>下载frp  <a href="https://github.com/fatedier/frp/releases/" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases/</a></p><p>树莓派为arm64版本</p><p>sudo wget frp地址</p><p>解压</p><p>sudo tar xzvf frp_0.16.1_linux_arm.tar.gz</p><p>编辑frpc.ini</p><pre><code>[common]server_addr = 公网frps地址server_port = 7000auth_token = frps设置的token[docker]type = httplocal_port = 9000subdomain = docker</code></pre><p>运行 </p><p>sudo ./frpc -c ./frpc.ini</p><h3 id="配置systemctl来控制frpc"><a href="#配置systemctl来控制frpc" class="headerlink" title="配置systemctl来控制frpc"></a>配置systemctl来控制frpc</h3><p>创建frpc服务</p><p>sudo nano /lib/systemd/system/frpc.service</p><p>往frpc.service里添加以下内容</p><pre><code>[Unit]Description=frpc serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleRestart=on-failureRestartSec=5sExecStart=/etc/frp/frpc -c /etc/frp/frpc.ini[Install]WantedBy=multi-user.target</code></pre><pre class=" language-shell"><code class="language-shell">#启动frpcsudo systemctl start frpc#服务器开机自动启动frpcsudo systemctl enable frpc#查看状态sudo systemctl status frpc#重启frpcsudo systemctl restart frpc#停止frpcsudo systemctl stop frpc</code></pre><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>sudo apt-get install nginx</p><p>sudo /etc/init.d/nginx start</p><p>nginx -v </p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> frp </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> portainer </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装OpenWrt</title>
      <link href="/shu-mei-pai-an-zhuang-openwrt.html"/>
      <url>/shu-mei-pai-an-zhuang-openwrt.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派安装OpenWrt"><a href="#树莓派安装OpenWrt" class="headerlink" title="树莓派安装OpenWrt"></a>树莓派安装OpenWrt</h1><p>开启网卡混杂模式</p><pre class=" language-shell"><code class="language-shell">sudo ip link set eth0 promisc on</code></pre><h2 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h2><pre class=" language-shell"><code class="language-shell">docker network create -d macvlan --subnet=192.168.198.0/24 --gateway=192.168.198.1 -o parent=eth0 macnet</code></pre><p>macvlan 是一种虚拟网卡的解决方案：</p><ul><li><p>macvlan并不创建网络，只创建虚拟网卡。</p></li><li><p>macvlan会<code>共享物理网卡</code>所链接的<code>外部网络</code>，实现的效果跟桥接模式是一样的。</p></li></ul><p>使用 <code>docker network ls</code>命令可以看到网络<code>macnet</code>已建立成功</p><p><img src="https://img.iamghf.top/blog/2020-03-19-031440.jpg" alt=""></p><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>docker pull sulinggg/openwrt:latest</p><h2 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h2><pre class=" language-shell"><code class="language-shell">docker run --restart always --name openwrt -d --network macnet --privileged sulinggg/openwrt:latest /sbin/init</code></pre><p>其中：</p><p><code>--restart always</code>参数表示容器退出时始终重启，使服务尽量保持始终可用；</p><p><code>--name openwrt</code>参数定义了容器的名称；</p><p><code>-d</code>参数定义使容器运行在 Daemon 模式；</p><p><code>--network macnet</code>参数定义将容器加入 <code>maxnet</code>网络；</p><p><code>--privileged</code>参数定义容器运行在特权模式下；</p><p><code>/sbin/init</code>定义容器启动后执行的命令。</p><h2 id="进入容器修改参数"><a href="#进入容器修改参数" class="headerlink" title="进入容器修改参数"></a>进入容器修改参数</h2><p>docker exec -it openwrt bash</p><pre class=" language-shell"><code class="language-shell">vim /etc/config/network</code></pre><pre><code>config interface &#39;loopback&#39;        option ifname &#39;lo&#39;        option proto &#39;static&#39;        option ipaddr &#39;127.0.0.1&#39;        option netmask &#39;255.0.0.0&#39;config interface &#39;lan&#39;        option type &#39;bridge&#39;        option ifname &#39;eth0&#39;        option proto &#39;static&#39;        option ipaddr &#39;192.168.123.100&#39;        option netmask &#39;255.255.255.0&#39;        option ip6assign &#39;60&#39;        option gateway &#39;192.168.123.1&#39;        option broadcast &#39;192.168.123.255&#39;        option dns &#39;192.168.123.1&#39;config interface &#39;vpn0&#39;        option ifname &#39;tun0&#39;        option proto &#39;none&#39;</code></pre><p>所有的 <code>192.168.123.x</code> 需要根据树莓派所处网段修改，<code>option gateway</code>和<code>option dns</code>填写路由器的 IP，若树莓派获得的 IP 为 <code>192.168.2.154</code>，路由器 IP 为<code>192.168.2.1</code>，则需要这样</p><pre><code>config interface &#39;lan&#39;        option type &#39;bridge&#39;        option ifname &#39;eth0&#39;        option proto &#39;static&#39;        option ipaddr &#39;192.168.2.100&#39;        option netmask &#39;255.255.255.0&#39;        option ip6assign &#39;60&#39;        option gateway &#39;192.168.2.1&#39;        option broadcast &#39;192.168.2.255&#39;        option dns &#39;192.168.2.1&#39;</code></pre><p><code>option ipaddr</code>项目定义了 OpenWrt 的 IP 地址，在完成网段设置后，IP最后一段可根据自己的爱好修改（前提是符合规则且不和现有已分配 IP 冲突）。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> raspberry </tag>
            
            <tag> 软路由 </tag>
            
            <tag> openwrt </tag>
            
            <tag> lede </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐私泄露下的数据暗网：大数据广告精准推送原理</title>
      <link href="/da-shu-ju-guang-gao-jing-zhun-tui-song-yuan-li.html"/>
      <url>/da-shu-ju-guang-gao-jing-zhun-tui-song-yuan-li.html</url>
      
        <content type="html"><![CDATA[<p>自打人类进化中出现了商业的那一刻起，营销，就成为了人类钻研的核心。交易的本质是价值交换，但世界上不存在永远对等的价值，所以交换中存在套利空间，这些套利空间，成就了商业的价值。逐利是人的本性，这是刻在基因里的。</p><p>如何把一件产品附加上额外的价值，卖给自己的同类，换回更多的金钱，成了最打动人心的事情，比世界和平还要打动人。毕竟和平是所有人的，而金钱是少数人的。越少越珍贵。纵观人类历史的每一个时代，最先进的技术往往都是最先应用于军事和贸易，而军事，很多时候也都是为贸易所服务的。从古至今皆是如此，大数据年代也不例外。</p><p>在这个人人标签化的数字年代，广告业前所未有的深入到了我们生活的方方面面，影响了我们的各种决策。你以为你做出的购买决策是基于自身的意愿，但现实并不一定如此。作为一个整日与数据标签打交道的风控，反商业作弊也是我的日常工作，如果不懂商业广告的底层逻辑，那么是做不好风控的。</p><p>这篇文章将给大家科普大数据广告的精准推送原理，我想为大家展示一下数据在合理的策略里可以完成多么恐怖的事情，这是真正的改变世界，或者说是掌控世界。这里面有谣言，也有真相，更多的是真相与谣言参半。甚至有时候真相比谣言更加魔幻。</p><p><img src="https://img.iamghf.top/blog/20200320144054.png" alt=""></p><p>让人掏钱，不是一件简单的事情，哪怕是有技术的支持。数据广告推送，本身是一个极为复杂的工程，这里面涉及数据采集，数据清洗，口径对齐，数据关联，模型训练，策略迭代，场景验证，流量分配，成本控制，渠道管理等一系列工作。</p><p>每家合格的数据驱动的营销公司，都会有一只数百到上千人的团队专门做相关的工作，数百个聪明的脑袋996只为做一件事。让你在不知不觉中心甘情愿的掏钱。</p><p>靠一篇文章写全这些，既不太现实，也没必要，所以我决定围绕一个关于大数据广告非常经典的谣言，从辟谣开始，来一步步拆解数据广告推送的基础知识以及对我们生活的影响。</p><p>很多人在网上说自己的的手机被人监听了，原因是自己刚和别人讨论了某个话题，没过多久，手机上就出现了类似信息的广告。例如自己口述了想喝奶茶，打开外卖软件就出现了奶茶推送。自己说想去欧洲旅游，打开网页就出现了旅游广告。自己谈到了某种商品，打开购物APP就出现了类似商品的推送。</p><p>所以很多人觉得自己在被自己手上的APP所监听，然后这些监听依据相关的关键词拆解讲话的意思，然后就推送给自己各种各样的广告，精准不精准不说，着实是吓人一跳。有段时间，整个互联网都在盛传某某APP拿录音权限就是为了实时监控用户，甚至某些APP还在偷偷录像用户云云。</p><p>我得承认大家的想象力是很丰富的，在不懂网络广告推送机制的前提下，提出这些猜想某种程度上也是合理的，但这都是谣言。互联网公司不会用这种方式来做所谓的精准推送。不是他们良心发现，而是这么做没有性价比。商人逐利。</p><p>为什么不用录音做推送？从用户角度思考方案，可能只考虑这件事是否能实现，监听录音从技术上可以实现；但是作为商业公司评估方案，除了需要考虑能不能实现这一点之外，还要综合考虑成本，效率以及风险，马虎不得。商场如战场。</p><p>利用录音做信息收集，然后做广告推送，在当下，是一件成本极高，效率极低，风险极高的事情。不仅要投入大量成本，连毛都赚不回来，还要面临侵犯用户隐私的指控，脑子没冒烟的公司都不会做这件事，即使是冒烟的公司，做到一半就会发现划不来，然后不做了。</p><p>录音牵涉的主要问题如下：</p><ol><li>录音功能会让APP消耗海量手机资源。</li></ol><p>当一个APP在后台持续录音的时候，不仅是APP本身运转会变得迟缓，更多的是会造成手机本身的耗电量和发热大幅增加，一来二去，用户直接就不使用了，因为一用你的APP手机就不好，市场上可选择替代品又太多。</p><p>当年滴滴和快的大战的时候，滴滴在关键时刻胜出靠的就是腾讯支持的1000台服务器以及数百名顶尖工程师，比快的早半个月实现了用户体验的质的飞跃，后面的故事大家都知道了。</p><ol start="2"><li>录音文件本身是占用手机存储空间的，并且占用极大。</li></ol><p>大家可以自己录一段30分钟的录音看看，这个音频文件会有多大，一个APP如果持续录音，在用户重度使用的情况下，可能几天就把手机彻底塞满了。这会造成非常荒谬的后果。</p><ol start="3"><li>录音录下来之后，无法及时处理这些录音数据。</li></ol><p>如果把录音处理模型放在本地APP里，那么一个是APP安装包臃肿，一个是会被竞争对手反编译，商业机密直接透明，把核心能力包在APP本地，是很愚蠢的事情，吃鸡为什么外挂屡禁不止，就是因为运算整体在本地文件，无法抵挡本地篡改，所以本地存储方案不靠谱；</p><p>如果走实时上传，那么传输过程中需要流量，这造成用户的流量损耗极为恐怖，并且很容易就被识别出来上传用户信息；这些数据属于无用数据。</p><ol start="4"><li>录音分析来的数据价值低，且不准确。</li></ol><p>如果手机APP监听录音，那么首先得保障他监听到的是你本人讲的话，因为推荐是要对你本人进行操作的，但是在现实生活中，录音没法保证只录某个人的声音，要录就是一起录音，这就导致录下来的声音也不知道是谁的。</p><p>想想看，我在你身边走过，冲着隔壁的人大喊一声“杜蕾斯”。然后你打开手机给你推荐杜蕾斯，这种沙雕推荐是不是非常魔幻？这就是无差别录音带来的问题。</p><ol start="5"><li>语义分析在目前依然面临无法解决的语言本身的问题。</li></ol><p>人类的语言是一门艺术，汉语更是高阶艺术，而机器尚未破解这一艺术。如果大家试过录音转文字，或者语音输入法，就会发现，机器没有办法完整的识别有效的语言场景。</p><p>我们来做一个语义识别题：</p><p>领导：“你这是什么意思？” 小明：“没什么意思，意思意思。” 领导：“你这就不够意思了。” 小明：“小意思，小意思。” 领导：“你这人真有意思。” 小明：“其实也没有别的意思。” 领导：“那我就不好意思了。” 小明：“是我不好意思。”</p><p>这里面的每一个意思，都是什么意思？机器根本做不到识别这些内容。甚至很多时候你只要讲方言或者讲话一快，机器就根本不知道你在说什么了。精准推送的前提是数据可靠且精准，录音绝不在这种数据中。</p><ol start="6"><li>录音带来的风险，要远远超过收益。</li></ol><p>录音这件事情，本身是非常敏感的，要是哪个APP能被明确抓出来在偷偷录音（目前所有的质疑都只是质疑，没有明确的数据和代码证据），第一个搞他们的不是网民，而是工信部。这种侵犯隐私的行为，正是抓紧去教育的好时机。</p><p>而公司只为求财，不想求进监狱里。</p><p>看到这里，我想很多人对于录音这种谣言已经足够了解了，但是还是有疑惑自己身上发生的神奇的事情，没关系，我们继续讲下去，看看真正的数据推送是怎么做的。我们如何通过巧妙的技术把我们自己困在广告里。</p><p>数据推送是如何实现的？</p><pre><code>    一套最最基础解法是，X+N=Y，这是最简单的公式。X是指的用户特征变量（用户画像），N是指变量应用（算法，策略），Y是指推送效果（用户是否购买）。所有收集来的用户数据，经过标准化ETL（数据处理），再经过特征工程，形成有效的X。有了X之后，N就是如何使用X，让最终结果更接近于Y。</code></pre><p>这里可以利用算法，也可以使用策略包，目前的主流是使用策略包，因为算法的效果随机性比较大。所谓的精准推送，本质上其实就是一个用X和N寻找接近Y的过程，所谓的训练模型，只不过是在已知X和Y的情况下，找寻可以让X更接近Y的算法，找出更好用的N。</p><p>单纯这么说比较抽象，我举一个例子大家就明白了。小A是一个18岁的美少年，曾经在淘宝上买了很多XX品牌的跑鞋，并且经常搜索大体重跑鞋。从广告推送的角度，针对美少年小A的推送会这么做。首先拆解小A身上的标签，做成X。男性，18岁，XX省人，学历XX，跑鞋，大体重，常用购物平台，手机型号，APP来源，手机入网时长，话费消费记录等等，这些标签都是X，来自于各种各样的数据源。</p><p>然后通过过去的购买记录，找到半佛曾经购买过的商品，就是各类跑鞋，做成Y。一个简单的用户画像就出来了：年轻男性，热爱跑步，胖，乐意花钱，有品牌倾向性，喜欢在淘宝购物，多数购物来自于主动搜索。</p><p>那么这时候就可以通过一定的策略，给半佛推荐大量的符合他历史购买习惯的跑鞋（从品牌到型号到价格），如果成交了，就代表算法有效，进一步强化推送；如果没有成交，就弱化部分特征，推送新一批跑鞋，只要成交，就依据成交结果修正算法。最终小A只是无聊刷淘宝，但是最终买了1000双跑鞋回家，然后又挂到了闲鱼上，创造了好几次GMV。</p><p>当然实际应用中会比这个公式要复杂很多，各种变量间的衍生变量，不同用户间的关系网络变量，同一个用户在不同场景中要匹配不同的Y，X作为Y，Y作为X，用户消费心理勾画，产品要素设计等等等等，广告推送可以说是互联网最复杂的应用，可能都没有之一。因为人的购买欲是不稳定的。</p><p>上面举的例子仅仅是复杂度为1的情况，实际在应用中，数据和公式的复杂度基本是10086起。考虑到本文是科普性质，所以我只拿最基本的东西来讲，大家了解这个数据推送的逻辑就可以了，算法本身不是重点。真正的重点在于精准数据的获取，这才是对我们生活影响最大的。数据时代的我们，一切都可以量化。</p><p>很多人所谓的自己偶尔说了什么，然后就收到了相关的广告，所以怀疑自己被录音。我理解这种想法，但我要说实现这样的效果，根本不需要录音这么麻烦，有的是更精准的方法来获取你的X。</p><ol><li>最基础的就是你的主动搜索记录。</li></ol><p>包括你在搜索引擎上的搜索，你在购物网站的搜索，你在各种APP（不一定要是购物）中的搜索，这些你主动搜索的信息，都是高权重的X。</p><p>如果是网页端的搜索，那么浏览器和搜索引擎都会留存你的cookie，即使你有定期清除浏览记录的习惯或者知道每次上完网清cookie也没用，现在云计算的发展已经可以做到实时上传，你清除也没用。</p><ol start="2"><li>除开搜索记录和购物记录外，最精准的数据之一就是你的手机App List以及注册APP列表。</li></ol><p>就是你的手机曾经安装过哪些APP，当前手机安装了什么什么APP，以及每一个APP的打开率，使用时长等等。</p><p>这个通过用户授权直接读取APP列表以及通过短信验证码反推安装注册可以实现，即使是号称IOS，也可以通过APP跳转撞库的方式来撞出至少48个APP。</p><p>每一个APP都是代表了一大串的X，毕竟每个APP都有自己的属性和目标用户，这些特征都是很显著的。你安装了拼多多，可能代表你是一个价格敏感型用户，可以给你推送便宜货；你安装了Bilibili，可能代表你是一个喜欢二次元的用户，可以给你推荐动漫周边；你每天大量时间沉迷在抖音，可能代表你是一个热衷于Kill Time的人，当然头条还会用你在抖音中的浏览记录来更精细化的推荐各种二类电商产品；</p><p>你用什么APP，某种程度上在机器眼中你就是什么人。</p><ol start="3"><li>LBS地理位置是一个非常有用，但是很多人都会忽略的内容。</li></ol><p>很多所谓的谈到奶茶后，打开外卖APP会弹出奶茶店铺广告的案例，其实都是因为使用了LBS推送。大家都知道APP会实时获取用户的地理位置，生成与之相关的X，而外卖店铺，本身也有自己的业务辐射范围。</p><p>当你走入到这个外卖店铺的辐射圈子的地理位置时，就给你推送相关的信息，让你不得不看。</p><p>某著名网红插，就经常喜欢对自己门店2公里内的外卖APP用户进行无差别推送，别管你喝不喝，来了就先看个广告吧。获取LBS的途径有很多，很多时候通过WIFI的固定连接点，也可以识别你是不是在那幢楼办公或者生活，然后围绕这一变量给你进行推送。你在哪里，你就是谁。</p><ol start="4"><li>聊天记录读取，短信读取，这种东西都太寻常了，我要说的是，输入法。</li></ol><p>只要你打字，你的输入法是知道你键入了什么内容的，这部分内容，都会被留存下来，然后作为你特征变量的一部分，这可比录音要好多了，因为百分百是你本人打的字，而且文字表达的含义也更加清晰。</p><p>某些输入法，就在做着这样的事情。输入法既然可以监控你的录入，当然也可以直接读取你的剪贴板，看到你曾经读取过什么。甚至技术厉害一点的，可以直接监控你的键盘轨迹，连你曾经打出来但是又删除掉的内容都拿到。</p><p>哦对了，关于录音，有一点是真的，就是当你用输入法的语音录入功能的时候，他们确实是知道你的录音的，只不过不是读声音，而是通过录音转录文字后的关键词，是读文字。输入法对于用户隐私的监控与泄露，是非常严重的，而且大多数人都无从感知。你忘记的，输入法都记得呢。</p><ol start="5"><li>当然，手机本身，就是一个最大的隐私收集器，在系统厂商和硬件厂商眼中，大家其实都是裸奔的。</li></ol><p>再讲一个恐怖故事，这些从各种APP，各类输入法，各种手机中收集来的用户数据，都是可以交易的，各家公司都在利用这些数据。</p><p>随便举一个例子。用户在今日头条APP中用百度输入法输入【尿不湿】，百度和今日头条都知道用户在今日头条输入了这个【尿不湿】，他们有了这个数据，这个数据并且是直接关联用户手机号的，就是说，大家知道是谁，在什么时间，在哪个APP里，输入了什么。</p><p>而这条精准的用户信息，是可以卖给淘宝或者京东的，淘宝获取了这个信息后，就可以对这个手机号关联的用户去进行相关的推送。这个市场的体量和交易额远远超出所有人的想象，但是知道的人却寥寥无几。</p><p>如果要穷举各种APP各种手机收集和利用用户隐私的案例，可能讲几天几夜也讲不完。我来给大家讲一个基于数据采集的用户画像案例吧，看看我们的一生是如何被数据拆解的。下面的文字部分为正常生活描述，括号内为获取这些数据的途径。</p><p>小明，在广告公司上班（通过短信读取公积金信息，或者支付宝绑定公积金）。28岁，男性（身份证号拆解）。本科学历（学信网接口通过身份证号调用），外地人（身份证号前6位对比工作所在地）。租房（租房APP或者代缴水电费账户名字与本人不同）。贷款买了一辆小车（贷款APP数据，支付宝绑定行驶证，每月短信还款提醒）。平时的消费爱好是买书和拼多多（支付类APP付款记录），以及打手游（游戏类APP以及账号体系）。经常去XX网吧通宵（外卖收货地址，网吧管理软件用户体系）。住在XX小区（快递收货地址，手机LBS活跃圈，WIFI连接热点）。偶尔也去旅游（车票酒店购买记录，异地网红店消费记录）。甚至喜欢看点小电影（浏览器记录，购买付费记录，转发记录）。朋友很多（好友数，日常活跃好友数，通话记录与通讯录的交集），朋友们的消费水平也一般般。收入一般般（短信读取银行到账短信，手机话费余额消费账单）。有一个女朋友小红（聊天记录，通讯录，通话详单），已经同居（购买大量女性生活用品）。女朋友公司在XXX（基于小明除家里以外的收货地址，关联一些女性物品交易记录）。快要结婚了（网上搜索大量与结婚有关的信息，下载了婚礼类APP）。最近可能要当父亲了（查看婴儿用品，网上搜索很多育儿经）。最近手头有点紧（下载了很多借款APP，读取短信可以知道有些下款了，外部可以采购到他的多头负债情况）。等等等等等等等（10086个等等）。</p><p>如果你是广告商，你拿到了这些数据，你可以非常精准的在小明人生的每一个阶段，都恰恰好推送一些恰恰好的广告，很多人可能光看描述就已经在构思营销方案了。</p><p>而且，这还只是小明一个人的数据，如果再加上小红的数据，小明朋友的数据，小明父母的数据，最终就会成为一张关系网。例如当小红在搜索孕妇装的时候，其实就可以给小明推荐奶粉和婴幼儿保险了。例如小明在搜索各种片子的时候，其实就可以给小红推荐一些情趣用品了。</p><p>这种关联多如漫天繁星。星空下是我们平凡的人生。如戏一般的人生，剧本不在我们手中。我们只是一颗棋子。</p><p>斯诺登的棱镜事件大家都还记得吧，美国政府在全世界范围搞监听。但要我说，棱镜那个东西，在大数据多维交叉验证面前，只是上个世纪的玩具。通过数据挖掘和收集，我知道你的爱好，知道你的活动范围，知道你的详细信息，知道你的社交圈，知道你可能要做的事情，知道你的一切。我比你还要懂你。</p><p>为什么我国政府近几年特别重视个人隐私，对于各种滥用隐私行为都是严厉的打击，每年都有大量数据从业者被送进去？因为当企业知道用户的一切的时候，某种程度上，就可以通过推送，来影响用户的一切。</p><p>这个影响可以是精准推送赚钱，也可以是做的更多。</p><p>还记得美国大选的时候，FaceBook直接倒卖用户数据来监控舆情，甚至通过精准推送来影响大选的结果？这是一种超越国界的能力。不仅仅是改变世界，甚至是掌控世界。</p><p>而回到我们自己。我们的一切，在公司眼中，只是一个个数据标签，是达到他们目的的必要生产资料而已。他们做的就是把我们做成数据，然后向我们灌输数据，从我们身上得到他们想要的东西。</p><p>我们一生的欢笑与泪水，开心与难过，认真的思考，谨慎的决策，最终都不过是一组数据，都是可以被拿来利用的。他们甚至都不屑于支配我们，你会去冲着一堆数据使劲儿吗？他们只需要调整参数就可以达到目的。</p><p>现在巨头们已经完成了数据的合围，然后通过交易来垄断这些数据。我们的一切都透明了，再技术飞速进步的年代，钱和权力都无法阻止这一切发生，除了死亡外，人类在大数据面前也是平等的。</p><p>这一切都不是秘密，完全是公开的事情，甚至那些卖数据的公司都恨不得自己去打广告找到更多的买家来买，因为卖的人太多了，市场竞争过于激烈，数据量过于饱和。这魔幻又现实。</p><p>我们的一生的故事都在里面，爱也在，恨也在。</p><p>大数据的发展确实给生活增加了便利，这无可否认。但如何掌握数据采集和数据应用的度？这是一个很大的问题。更大的问题在于，这种被设计好的生活，真的是我们想要的吗？我还没有答案，你呢？</p><p>【<a href="https://www.you85.com/thread-1000049-1-1.html" target="_blank" rel="noopener">原文地址</a>】</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 隐私泄露 </tag>
            
            <tag> 精准推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有哪些大家不说，但需要知道的社会规则？</title>
      <link href="/she-hui-gui-ze.html"/>
      <url>/she-hui-gui-ze.html</url>
      
        <content type="html"><![CDATA[<h1 id="有哪些大家不说，但需要知道的社会规则？"><a href="#有哪些大家不说，但需要知道的社会规则？" class="headerlink" title="有哪些大家不说，但需要知道的社会规则？"></a>有哪些大家不说，但需要知道的社会规则？</h1><p><img src="https://img.iamghf.top/blog/20200410140845.png" alt="img"></p><p>1、女人都以为男人说的“我养你”，是可以让她在家看看书、练练瑜伽、养养花、遛遛狗，下午再出去和姐妹逛逛街、喝个下午茶、做个美甲、敷个脸的那种“我养你”；</p><p>而男人所理解的“我养你”，是让你在家洗衣、做饭、带孩子、孝敬父母。</p><p><strong>2、没有详细询问你的需求，就拒绝你请求的人，其实是一开始就预设了立场，压根就不想帮你。</strong></p><p>比如你想问他借钱，他还没问你具体要借多少，就说自己最近手头紧；比如你想请他帮你写个材料，他还没问什么材料多少字，就说现在这两天很忙。</p><p>3、和别人聊天的时候，不要一直说那些只有你自己感兴趣的事情，对方可能既不关心也不了解。</p><p>比如你对着一个女生大谈意大利足球的悲情印记，你滔滔不绝的说了半天，自己痛快的很，可是对方就会很尴尬，因为人家可能连一支足球队几个人都不知道。</p><p><strong>4、借别人的钱，要告诉对方什么时候能把钱还人家，最好是一个明确的时间节点。</strong></p><p>如果你自己都不知道什么时候能攒够这些钱，那你还是不要借别人的钱了。</p><p>5、不要不打招呼的站到别人身后，还偷着看别人的电脑屏幕和手机屏幕！</p><p>大家都有隐私好么！</p><p>另外，别人给你看手机里某张照片的时候，不代表你可以左滑右滑。</p><p>6、微信和邮件都没有消息已读的提示，所以对方给你发消息以后，尽量回复一下。</p><p>哪怕不知道应该回复什么，也回一个“OK”、“收到”、“好的”。</p><p>至少可以让对方知道你看到了。</p><p>7、单身的时候，你可以和异性好朋友保持任何关系，暧昧不暧昧的都无所谓，但是对方谈恋爱以后，请你自觉与ta保持距离。</p><p>你可以做到问心无愧，但是对方的那个ta做不到不在意。</p><p>8、别人帮了你一个忙，只要对方付出了劳动，就不要只是在嘴上说谢谢，能表示的要表示。</p><p><strong>不是因为对方图你那点东西，是大家都愿意帮那些懂得感激的人。</strong></p><p>9、如果不打算与人分享，就不要主动向别人炫耀你的好东西。</p><p>10、不太交底的朋友请你吃饭，让你挑地方的时候，要慎重选择，尤其不要选贵的地方，可能超出了对方的预算。</p><p>最好的方法是让对方选地方。</p><p>11、如果小便池还有空着的，就不要去紧挨着一个人小便，<strong>图个啥？比大小？</strong></p><p>12、想让大家都喜欢你，你可以靠自己的能力给大家提供很多帮助。</p><p>但是最好的方式还是你可以为他们提供一些资源或者赚钱的机会。</p><p>最省事儿的方式，是你颜值抗打，别人看了自然会心情舒畅。</p><p>当然，实在不行的话就做个逗比，也算给大家带来快乐了。</p><p><strong>什么都提供不了，还想让别人都喜欢你，有点难。</strong></p><p>13、对方向你哭诉的时候，并不是想通过<strong>你指出他的错误</strong>来解决问题，大多只是需要你的认同。</p><p>14、见利忘义自古以来为人所不耻，但现实是钱的的确确可以解决大多数问题，剩下的那些问题，也可以通过钱来间接解决。</p><p>可能有人告诉你钱很重要，但是你总会慢慢发现，你好像还是低估了钱的重要性。</p><p>15、善良，其实是一种个人选择。</p><p>这种选择并不一定会让你赚到多大便宜，但是会让人的生活充满阳光，积极向上，有幸福感和获得感。</p><p>就比如这个回答，有的人看完觉得对自己有帮助，就点了个赞。从纯功利的角度来说，这个赞并不会给他本人带来什么好处，但是这种善良的行为做多了，你就会慢慢发现，自己越来越幸福了。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些改写历史的古代饭局</title>
      <link href="/na-xie-gai-xie-li-shi-de-gu-dai-fan-ju.html"/>
      <url>/na-xie-gai-xie-li-shi-de-gu-dai-fan-ju.html</url>
      
        <content type="html"><![CDATA[<h1 id="那些改写历史的古代饭局"><a href="#那些改写历史的古代饭局" class="headerlink" title="那些改写历史的古代饭局"></a>那些改写历史的古代饭局</h1><p>吃饭就是吃饭，一天吃三顿饭，目的是为了吃饱。吃饭一但成了“局”，解饿便成了次要的，里面就充满了故事性、目的性乃至阴谋性。中国历史上有许多著名的饭局，有的饭局甚至改写了历史。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093543.png" alt="image-20200111173543183"></p><p>古代宴会场景 </p><h2 id="宴会买心，得忠心"><a href="#宴会买心，得忠心" class="headerlink" title="宴会买心，得忠心"></a>宴会买心，得忠心</h2><p>俗话说酒越喝越厚，说起利用宴会收买人心的事，最著名的当属春秋时期楚庄王组织的一次宴会。 </p><p>当时楚庄王刚刚平息了一次暴乱，开庆功会。让他最宠爱的妃子给众臣敬酒，突然一阵风吹来，将灯吹灭了，一位将军喝多了酒，趁着黑暗吃楚王妃子的“豆腐”。而楚妃恼羞成怒之时，将这位“好色之徒”的帽顶之樱顺手摘了下来献给楚庄王。楚庄王得知实情之后，命令不要点灯，所有大臣都把帽子摘下来继续饮酒，并没有追查戏耍楚妃之人。这位“好色”的大将为了报楚王的宽容之恩，在后来的一次战役中奋勇当先立下大功，楚王因宽容得一誓死效忠他的猛将，此会在史上被称为绝樱会。 </p><h2 id="宴会杀人，几人亡"><a href="#宴会杀人，几人亡" class="headerlink" title="宴会杀人，几人亡"></a>宴会杀人，几人亡</h2><p>但宴会也会成为杀人的场所，人们常常将有阴谋的宴会称为鸿门宴。 </p><p>鸿门宴是历史上最著名的杀人宴会，项羽的谋士范曾想利用这次宴会杀死刘邦，让项庄舞剑。没想到项羽的叔叔项伯早已私下与刘邦结交，舞剑保护刘邦。最重要的是，耳软心活有妇人之仁的项羽并没有想杀死刘邦，所以这次宴会，刘邦逃出生天。鸿门宴有杀人的动机，但并没有完成杀人的使命。后来刘邦在战争中击败项羽，没有妇人之仁，项羽被逼自尽。  </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093347.jpg" alt="img"><br>鸿门宴 </p><p>跟鸿门宴刘邦的幸运比起来，春秋战国时期公子光请吴王僚吃饭的宴会就成了杀人的战场，吴王僚没有刘邦幸运，公子光是势在必得，一心想杀死吴王僚的。他事先请专诸在鱼肚子藏好的鱼肠剑，借上菜之机猛然从鱼肚子取出鱼藏剑，一击即中，刺杀了王僚。这就是专诸刺王僚的故事，鱼藏剑也因此成为一代名剑。专诸命丧当场，公子光成功夺取王位，就是吴王阖闾。 </p><p>齐国国相晏婴更狠，他杀人不用刀子，借宴会的两个桃子就杀了他想的人，借刀杀人的本事可谓天下无双。公孙接、田开疆、古冶子是侍卫齐景公的三个能力搏猛虎的勇士，但同时又是恃功自傲威胁国君统治的人。晏婴动了杀机，想除掉“三杰”，于是在一次宴会上，设了一个局，盘中只有两个桃子，请国君下旨谁功劳最大谁吃桃子。这“三杰”果然上了当，公孙接先吃了一个，古冶子吃了一个，田开疆无桃可吃，觉得功劳很大没桃吃当众受辱，挥剑自杀，公孙接看田开疆自杀，觉得自己功劳小而吃桃，无颜活在世上，也挥剑自杀了。古冶子看二人自杀，觉得三人结为兄弟誓同生死，二位兄弟因桃而死，自己也不能苟活，所以也自杀了。这就是二桃杀三士的故事。 </p><h2 id="宴会谋略，巧施计"><a href="#宴会谋略，巧施计" class="headerlink" title="宴会谋略，巧施计"></a>宴会谋略，巧施计</h2><p>许多宴会，其实是巧施谋略成大事的饭局。三国里面这样的宴会非常多。比如曹操设的饭局，青梅煮酒论英雄，其实是曹操怀疑刘备，考察刘备呢。而刘备在这个宴会上装傻非常成功，最后曹操点破了他，刘备还以怕雷掩饰瞒过了曹操。曹操何等的雄才大略，被刘备借兵五万去打袁术，不但跑了，还骗走了五万兵，杀了曹操一员大将。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093345.jpg" alt="img"><br>二桃杀三士 </p><p>另一场宴会是吕布设的饭局，他请刘备三兄弟与袁术的大将纪灵赴宴，为的是解除双方的刀兵相见。但纪灵并不同意与刘备和平解决争端，于是吕布说和平与战争，全靠“天意”，而这所谓的“天意”，便是他箭射一百五十步以外的方天画戟小枝，射中双方罢兵和平，射不中双方开战。吕布的谋略在于，他心中有数，天意就是人意。肯定能射中。而纪灵同意这个建议的原因是，他并不知道吕布有这么高的射技。结果吕布如期射中，辕门射戟的故事流传至今。 </p><p>最有名的谋略宴会，是三国赤壁大战前夕的“群英会”，曹操派蒋干过江说服他的老同学周瑜投降，周瑜早已看出蒋干的心思，假装喝醉，让蒋干偷走了假情报。曹操依据蒋干偷回的假情报，错杀了水军都督蔡瑁、张允。这为赤壁大战周瑜的胜利奠定了基础。 </p><h2 id="宴会夺权，一杯无"><a href="#宴会夺权，一杯无" class="headerlink" title="宴会夺权，一杯无"></a>宴会夺权，一杯无</h2><p>利用一场宴会不动一刀一枪就收回兵权，是宋朝开国皇帝赵匡胤干的最聪明睿智的事，史书命名“杯酒释兵权”。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093346.jpg" alt="img"><br>杯酒释兵权 </p><p>赵匡胤是靠陈桥兵变取得的江山，他怕其他将军也象他一样夺权，日日担忧，所以他设了一个饭局，请开国元勋们去赴宴，请他心中真实的想法说了出来。开国元勋们听到皇帝心中的想法很害怕，担心遭受杀身之祸，第二天全部请辞，主动交出了兵权。赵匡胤倒也没有为难他们，赏给他们大量的金钱，还与他们很多人结成了儿女亲家，和平解决了骄兵悍将问题。 </p><p>同赵匡胤相比，刘邦与朱元璋就没这么聪明了，这二位皇帝不得不大杀开国功臣，解除开国元勋对朝廷的威胁。尤其是朱元璋，几乎杀尽了开国功臣，到朱棣靖难之役时，建文帝无将可派，这可能也是朱元璋没想到的。传说中的“火烧庆功楼”，是与赵匡胤“杯酒释兵权”完全相反的一个酒宴，但这个事只是传说，历史中是没有的。 </p><h2 id="宴会鼓气，河山壮"><a href="#宴会鼓气，河山壮" class="headerlink" title="宴会鼓气，河山壮"></a>宴会鼓气，河山壮</h2><p>利用宴会壮行鼓气，最著名的是晋朝的“新亭会”。 </p><p>晋朝经过八王之乱，进行五胡乱华时期，北方大片国土被胡人占据，史称十六国。而大量的汉人“衣冠南渡”，在新亭会宴会上，众人纷纷哀叹世事难料，“风景不殊，举目有江河之异”，唯有名士王导挺身而出，说道“当共戮力王室，克服神州，何至作楚囚相对泣邪”。王导的话激励了众人，众人戮力同心，东晋王朝在这次宴会之后建立起来。而王导被后人称为“江左自有管夷吾”。 </p><h2 id="宴会庆功，千叟忙"><a href="#宴会庆功，千叟忙" class="headerlink" title="宴会庆功，千叟忙"></a>宴会庆功，千叟忙</h2><p>历史上的宴会，庆功大会有很多。但最盛大的，当属乾隆皇帝摆的满汉全席，参加者都是老人，最大的一百四十一岁了，因为人数众多，有几千人，所以名叫“千叟宴”。其实千叟宴是从康熙皇帝开始摆的，共举行的四次，乾隆皇帝摆的宴，规模最为宏大。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-093348.jpg" alt="img"><br>千叟宴 </p><p>据史料记载，康熙皇帝举行的第一次千叟宴参加人数不下七千人，而乾隆皇帝第二次千叟宴，参加人数又起过了他的爷爷，列名参席者3056人，列名邀赏者尚5000人，加起来八千多人。岁数最大的郭钟岳据说141岁了，乾隆皇帝与纪晓岚送他一副对联：花甲重开，外加三七岁月；古稀双庆，内多一个春秋。堪称绝对。 </p><p>清朝以孝治国，千叟宴是皇帝以孝治国、尊老敬老最成功的一个案例。 </p><h2 id="宴会文友，有诗赋"><a href="#宴会文友，有诗赋" class="headerlink" title="宴会文友，有诗赋"></a>宴会文友，有诗赋</h2><p>文中饮酒，最盛大的一次宴会，当属唐朝长安城中的“饮中八仙”聚会。 </p><p>这八仙是：诗仙李白、诗人贺知章、书法家张旭、汝阳王李琎、左相李适之、美少年崔宗之、素食主义者苏晋、辩论高手焦遂。当然喝酒的可能还有其他人，但有名的是这八人，被后世称为饮中八仙。其中最有名的是李白、贺知章与张旭。杜甫为这次聚会专门做了一首诗，因此饮中八仙名闻天下。大家最熟知的李白，其诗曰：李白斗酒诗百篇，长安市上酒家眠。天子呼来不上船，自言臣是酒中仙。而草圣张旭，也有“张旭三杯草圣传，脱帽露顶王公前，挥毫落纸如云烟”流传后世。 </p><p>对酒饮愁，情谊长<br>美人饮酒，最有名的杨贵妃。史称“贵妃醉酒”。 </p><p><img src="https://img.iamghf.top/blog/2020-01-11-93349.jpg" alt="img"><br>饮中八仙 </p><p>杨贵妃为什么喝醉了呢？她本是寿王妃，被公公李隆基召进宫当了贵妃，三千宠幸于一身。但有一天，正当她摆酒迎接李隆基打算侍寝时，李隆基却到了梅妃的宫中去睡觉了。于是杨贵妃独自饮酒，这酒是吃醋的酒，嫉妒的酒，嗔怒的酒。杨贵妃的醉态更加美丽，更加风騒，旁边伺候的高力士及其他宫女都看呆了。喝完酒的杨贵妃没有等来李隆基，只得在太监的搀扶下独自睡觉去了。估计第二天李隆基知道杨贵妃因为等他喝醉了酒，会更加疼爱杨贵妃了吧。<br>历史上还有许多有名的饭局故事，比如“秦国和赵国的渑池会”，蔺相如为赵国争了光；关羽与鲁肃的“单刀赴会”，至今还有争议，到底是关羽还是鲁肃持着单刀赴那个英雄会；比如唐朝的郭子仪过个生日，引出了“打金枝”的故事；比如刘伶去杜康家喝了三碗酒，一醉醉了三年还活着，至今有款名酒叫刘伶醉……</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 饭局 </tag>
            
            <tag> 历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>所有优秀背后，都是苦行僧般的自律！</title>
      <link href="/zi-lu.html"/>
      <url>/zi-lu.html</url>
      
        <content type="html"><![CDATA[<h1 id="所有优秀背后，都是苦行僧般的自律！"><a href="#所有优秀背后，都是苦行僧般的自律！" class="headerlink" title="所有优秀背后，都是苦行僧般的自律！"></a>所有优秀背后，都是苦行僧般的自律！</h1><p> <img src="https://img.iamghf.top/blog/2020-01-11-092359.jpg" alt="img"><br> <strong>所有优秀背后，都是苦行僧般的自律。</strong><br>   胸中藏有大志的人，往往是一个很自律的人。 重庆谈判中，蒋介石曾对秘书陈布雷说：“毛不可轻视。他嗜烟如命，但他知道我不吸烟后，在同我谈话期间，竟绝不抽一支。对他的决心和精神，不可小视！” 自律的人，既可怕，又可敬。如果是伙伴，你要跟他学会律己；如果是对手，你要做好足够的心理准备。 以前总觉得，人生苦短，应及时行乐。今朝有酒今朝醉，人不风流枉少年。直到后来，我渐渐发现：每一个不自律的行为，都会给你带来更大的痛苦。不要做欲望的奴隶，自律可以令我们活得更高级。 自由的本质不是放纵自己，不是无所不为，而是自律之后的舒畅，是有所为，有所不为！</p><h2 id="——（壹）——"><a href="#——（壹）——" class="headerlink" title="——（壹）——"></a><strong>——（壹）——</strong></h2><p>   人为什么要自律？ 人为什么要自律？ 很多时候，我们只看到了别人优秀的样子，却往往忽略了他们为此付出了近乎自虐般的努力。 一个自律到骨子里的人，看上去大多是无趣的。 在别人出去玩乐的时候，一个人窝在那里看书；在别人享用着美食的时候，在健身房里挥汗如雨；周末的时光，很多人慵懒地睡到中午，他依旧雷打不动的早起、跑步、看书、工作… 这样的人，不仅看起来无趣，甚至感觉有自虐倾向，活得一点都不洒脱和自由。 但真实情况是，自律的人比不自律的人要自由得多。 如果你总是随心所欲，讲究及时行乐，不知道努力，别人玩你也玩，别人努力你还在玩，依旧放纵自己。 那么如此不自律的你，现在看似是自由的，但你会发现自己越活越没有自由，没有选择的资本。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092408.jpg" alt="img"><br>   康德说，所谓自由，不是随心所欲，而是自我主宰。 越自律，越有话语权，身体和人生都是如此。 一天两天看不出来，一个月两个月也许还是看不出来，但是一年两年，甚至十年二十年，自律的人和不自律的人，终将走上截然不同的道路。 付出和回报是成正比的，量变足够了才可能促成质变。 这就是一个人为什么要自律的原因，和梦想沾不上边，就是简简单单地为自己以后能真正自由一点，身体和人生都自由一点。 是啊。 越是自律的人越明白自己真正想要的是什么，所以才不会把时间和精力白白浪费在无意义的事情上，而是真的把碎片化时间都利用起来成长自己。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092415.jpg" alt="img">  </p><h2 id="——（贰）——"><a href="#——（贰）——" class="headerlink" title="——（贰）——"></a><strong>——（贰）——</strong></h2><p>   所有优秀 背后都有苦行僧般的自律 说要自律的人很多，可坚持自律的人很少，就像爬一座险峻的高山，越临近山顶，能够咬牙坚持往前走的人越少。 好的坚持，本身就是一种自律。 还记得去年的时候，一位名叫沈华的96岁老爷爷走红网络，健身26年的他体格健壮，完全不向一个近百岁的老人，大家都喊他“华仔”、“华叔”。 沈老每天的作息时间非常规律，从不超过晚上十点睡觉，早晨四点多就起床活动身体，每天下午到健身房报到。 他的同龄人很多都已经不在了，沈老说：“现在健身和运动是我最好的朋友”。 七十多岁的沈华最初进健身房，总遭遇很多白眼，很多人都觉得他一把年纪，肯定坚持不了多久，可现实是，很多年轻人只是健身房的过客，沈华却用二十年变成了为人熟知的“肌肉爷爷”。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092420.jpg" alt="img"><br>   日本作家村上春树从30岁开始写作，至今已快有40个年头，创作出了大量的作品，经典又高产。 村上春树写作有个习惯，他每天只写4000字，400字一页的纸，每天写到10页就停下来。 另外，他每天都会拿出一个小时出来跑步，雷打不动，正是这种高度自律，让他有精力能够持续产出优秀的作品出来。 商业大佬们的自律性更是可怕，李嘉诚那么成功的人士，依旧坚持每天晚饭后看英文电视，不仅看，还跟着大声说出来，怕自己落伍；每天临睡前坚持看书阅读。 同李嘉诚一样自律的商界大佬很多，世界首富比尔盖茨几十年来坚持每周至少看两本书。 很多时候，不是优秀才自律，而是你自律了，才会变得优秀。而那些自律的人，往往连老天爷都不忍心辜负他们。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092425.jpg" alt="img">   </p><h2 id="——（叁）——"><a href="#——（叁）——" class="headerlink" title="——（叁）——"></a><strong>——（叁）——</strong></h2><p>   越自律，越优秀 《认知突围》中有句话说：所有的懒惰、放纵、自制力不足，根源都在于认知能力受限。 越自律，认知能力越强，人和人的差距，就是这样逐渐拉开的。 一个人的自律中，藏着无限的可能性，你自律的程度，决定着你人生的高度。 每个人都有权利选择怎样活着，有人认为人生苦短，要及时行乐，没有问题，但我想告诉你，自律的人生其实更加美好，因为当你知道自己想要去哪儿并且全力以赴奔跑的时候，全世界都会为你让路。<br>   <img src="https://img.iamghf.top/blog/2020-01-11-092432.jpg" alt="img"><br>   真正能够登顶远眺的人，永远是那些心无旁骛，坚持着往前走的人。 愿我们真正成为自律的自己，活成自己喜欢的样子，过上自己想要的生活。 人生没有近路可走，但你走的每一步，都算数。 越勤奋，越努力；越自律，越优秀。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习十大算法</title>
      <link href="/ji-qi-xue-xi-shi-da-suan-fa.html"/>
      <url>/ji-qi-xue-xi-shi-da-suan-fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习十大算法"><a href="#机器学习十大算法" class="headerlink" title="机器学习十大算法"></a>机器学习十大算法</h1><p>机器学习是该行业的一个创新且重要的领域。我们为机器学习程序选择的算法类型，取决于我们想要实现的目标。</p><p>现在，机器学习有很多算法。因此，如此多的算法，可能对于初学者来说，是相当不堪重负的。今天，我们将简要介绍 10 种最流行的机器学习算法，这样你就可以适应这个激动人心的机器学习世界了！</p><p>让我们言归正传！</p><p>\1. 线性回归</p><p>线性回归（Linear Regression）可能是最流行的机器学习算法。线性回归就是要找一条直线，并且让这条直线尽可能地拟合散点图中的数据点。它试图通过将直线方程与该数据拟合来表示自变量（x 值）和数值结果（y 值）。然后就可以用这条线来预测未来的值！</p><p>这种算法最常用的技术是最小二乘法（Least of squares）。这个方法计算出最佳拟合线，以使得与直线上每个数据点的垂直距离最小。总距离是所有数据点的垂直距离（绿线）的平方和。其思想是通过最小化这个平方误差或距离来拟合模型。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025140.jpg" alt="img"></p><p>例如，简单线性回归，它有一个自变量（x 轴）和一个因变量（y 轴）</p><p>\2. 逻辑回归</p><p>逻辑回归（Logistic regression）与线性回归类似，但它是用于输出为二进制的情况（即，当结果只能有两个可能的值）。对最终输出的预测是一个非线性的 S 型函数，称为 logistic function, g()。</p><p>这个逻辑函数将中间结果值映射到结果变量 Y，其值范围从 0 到 1。然后，这些值可以解释为 Y 出现的概率。S 型逻辑函数的性质使得逻辑回归更适合用于分类任务。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025237.jpg" alt="img"></p><p>逻辑回归曲线图，显示了通过考试的概率与学习时间的关系。</p><p>\3. 决策树</p><p>决策树（Decision Trees）可用于回归和分类任务。</p><p>在这一算法中，训练模型通过学习树表示（Tree representation）的决策规则来学习预测目标变量的值。树是由具有相应属性的节点组成的。</p><p>在每个节点上，我们根据可用的特征询问有关数据的问题。左右分支代表可能的答案。最终节点（即叶节点）对应于一个预测值。</p><p>每个特征的重要性是通过自顶向下方法确定的。节点越高，其属性就越重要。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025313.jpg" alt="img"></p><p>决定是否在餐厅等候的决策树示例。</p><p>\4. 朴素贝叶斯</p><p>朴素贝叶斯（Naive Bayes）是基于贝叶斯定理。它测量每个类的概率，每个类的条件概率给出 x 的值。这个算法用于分类问题，得到一个二进制“是 / 非”的结果。看看下面的方程式。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025354.jpg" alt="img"></p><p>朴素贝叶斯分类器是一种流行的统计技术，可用于过滤垃圾邮件！</p><p>\5. 支持向量机（SVM）</p><p>支持向量机（Support Vector Machine，SVM）是一种用于分类问题的监督算法。支持向量机试图在数据点之间绘制两条线，它们之间的边距最大。为此，我们将数据项绘制为 n 维空间中的点，其中，n 是输入特征的数量。在此基础上，支持向量机找到一个最优边界，称为超平面（Hyperplane），它通过类标签将可能的输出进行最佳分离。</p><p>超平面与最近的类点之间的距离称为边距。最优超平面具有最大的边界，可以对点进行分类，从而使最近的数据点与这两个类之间的距离最大化。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025425.jpg" alt="img"></p><p>例如，H1 没有将这两个类分开。但 H2 有，不过只有很小的边距。而 H3 以最大的边距将它们分开了。</p><p>\6. K- 最近邻算法（KNN）</p><p>K- 最近邻算法（K-Nearest Neighbors，KNN）非常简单。KNN 通过在整个训练集中搜索 K 个最相似的实例，即 K 个邻居，并为所有这些 K 个实例分配一个公共输出变量，来对对象进行分类。</p><p>K 的选择很关键：较小的值可能会得到大量的噪声和不准确的结果，而较大的值是不可行的。它最常用于分类，但也适用于回归问题。</p><p>用于评估实例之间相似性的距离可以是欧几里得距离（Euclidean distance）、曼哈顿距离（Manhattan distance）或明氏距离（Minkowski distance）。欧几里得距离是两点之间的普通直线距离。它实际上是点坐标之差平方和的平方根。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025452.jpg" alt="img"></p><p>KNN 分类示例</p><p>\7. K- 均值</p><p>K- 均值（K-means）是通过对数据集进行分类来聚类的。例如，这个算法可用于根据购买历史将用户分组。它在数据集中找到 K 个聚类。K- 均值用于无监督学习，因此，我们只需使用训练数据 X，以及我们想要识别的聚类数量 K。</p><p>该算法根据每个数据点的特征，将每个数据点迭代地分配给 K 个组中的一个组。它为每个 K- 聚类（称为质心）选择 K 个点。基于相似度，将新的数据点添加到具有最近质心的聚类中。这个过程一直持续到质心停止变化为止。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025524.jpg" alt="img"></p><p>\8. 随机森林</p><p>随机森林（Random Forest）是一种非常流行的集成机器学习算法。这个算法的基本思想是，许多人的意见要比个人的意见更准确。在随机森林中，我们使用决策树集成（参见决策树）。</p><p>为了对新对象进行分类，我们从每个决策树中进行投票，并结合结果，然后根据多数投票做出最终决定。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025601.jpg" alt="img"></p><p>（a）在训练过程中，每个决策树都是基于训练集的引导样本来构建的。</p><p>（b）在分类过程中，输入实例的决定是根据多数投票做出的。</p><p>\9. 降维</p><p>由于我们今天能够捕获的数据量之大，机器学习问题变得更加复杂。这就意味着训练极其缓慢，而且很难找到一个好的解决方案。这一问题，通常被称为“维数灾难”（Curse of dimensionality）。</p><p>降维（Dimensionality reduction）试图在不丢失最重要信息的情况下，通过将特定的特征组合成更高层次的特征来解决这个问题。主成分分析（Principal Component Analysis，PCA）是最流行的降维技术。</p><p>主成分分析通过将数据集压缩到低维线或超平面 / 子空间来降低数据集的维数。这尽可能地保留了原始数据的显著特征。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025634.jpg" alt="img"></p><p>可以通过将所有数据点近似到一条直线来实现降维的示例。</p><p>\10. 人工神经网络（ANN）</p><p>人工神经网络（Artificial Neural Networks，ANN）可以处理大型复杂的机器学习任务。神经网络本质上是一组带有权值的边和节点组成的相互连接的层，称为神经元。在输入层和输出层之间，我们可以插入多个隐藏层。人工神经网络使用了两个隐藏层。除此之外，还需要处理深度学习。</p><p>人工神经网络的工作原理与大脑的结构类似。一组神经元被赋予一个随机权重，以确定神经元如何处理输入数据。通过对输入数据训练神经网络来学习输入和输出之间的关系。在训练阶段，系统可以访问正确的答案。</p><p>如果网络不能准确识别输入，系统就会调整权重。经过充分的训练后，它将始终如一地识别出正确的模式。</p><p><img src="https://img.iamghf.top/blog/2020-01-04-025701.jpg" alt="img"></p><p>每个圆形节点表示一个人工神经元，箭头表示从一个人工神经元的输出到另一个人工神经元的输入的连接。</p><p>接下来是什么？现在，你已经了解了最流行的机器学习算法的基础介绍。你已经准备好学习更为复杂的概念，甚至可以通过深入的动手实践来实现它们。如果你想了解如何实现这些算法，可以参考 Educative 出品的 Grokking Data Science 课程，该课程将这些激动人心的理论应用于清晰、真实的应用程序。</p><p>祝你学习愉快！</p><p><strong>作者介绍：</strong></p><p>Fahim ul Haq，曾在 Facebook、Microsoft 工作。Educative.io 联合创始人。Educative 旨在帮助学生使用交互式课程来学习编程知识。</p><p><strong>原文链接：</strong></p><p><a href="https://towardsdatascience.com/the-top-10-ml-algorithms-for-data-science-in-5-minutes-4ffbed9c8672" target="_blank" rel="noopener">https://towardsdatascience.com/the-top-10-ml-algorithms-for-data-science-in-5-minutes-4ffbed9c8672</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议详解</title>
      <link href="/http-xie-yi-xiang-jie.html"/>
      <url>/http-xie-yi-xiang-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h1><p>当今web程序的开发技术真是百家争鸣，ASP.NET, PHP, JSP，Perl, AJAX 等等。 无论Web技术在未来如何发展，理解Web程序之间通信的基本协议相当重要, 因为它让我们理解了Web应用程序的内部工作. 本文将对HTTP协议进行详细的实例讲解，内容较多，希望大家耐心看。也希望对大家的开发工作或者测试工作有所帮助。</p><h1 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h1><p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器</p><p>目前我们使用的是HTTP/1.1 版本</p><h1 id="Web服务器，浏览器-代理服务器"><a href="#Web服务器，浏览器-代理服务器" class="headerlink" title="Web服务器，浏览器,代理服务器"></a>Web服务器，浏览器,代理服务器</h1><p>当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？</p><p>实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022114.png" alt="img"></p><p>我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。</p><p>过程如下图所示</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022125.png" alt="img"></p><p>代理服务器就是网络信息的中转站，有什么功能呢？</p><p>\1. 提高访问速度， 大多数的代理服务器都有缓存功能。</p><p>\2. 突破限制， 也就是翻墙了</p><p>\3. 隐藏身份。</p><h1 id="URL详解"><a href="#URL详解" class="headerlink" title="URL详解"></a>URL详解</h1><p> URL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下</p><pre><code>schema://host[:port#]/path/.../[?query-string][#anchor]</code></pre><p>scheme        指定低层使用的协议(例如：http, https, ftp)</p><p>host          HTTP服务器的IP地址或者域名</p><p>port#         HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/" target="_blank" rel="noopener">http://www.cnblogs.com:8080/</a></p><p>path          访问资源的路径</p><p>query-string    发送给http服务器的数据</p><p>anchor-       锚</p><p>URL 的一个例子</p><p><a href="javascript:void(0);"><img src="https://img.iamghf.top/blog/2020-01-04-022115.gif" alt="复制代码"></a></p><pre><code>http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuffSchema:                 httphost:                   www.mywebsite.compath:                   /sj/test/test.aspxQuery String:           name=sviergn&amp;x=trueAnchor:                 stuff</code></pre><p><a href="javascript:void(0);"><img src="https://img.iamghf.top/blog/2020-01-04-022115.gif" alt="复制代码"></a></p><h1 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a>HTTP协议是无状态的</h1><p>http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</p><h1 id="打开一个网页需要浏览器发送很多次Request"><a href="#打开一个网页需要浏览器发送很多次Request" class="headerlink" title="打开一个网页需要浏览器发送很多次Request"></a>打开一个网页需要浏览器发送很多次Request</h1><p>\1. 当你在浏览器输入URL <a href="http://www.cnblogs.com" target="_blank" rel="noopener">http://www.cnblogs.com</a> 的时候，浏览器发送一个Request去获取 <a href="http://www.cnblogs.com" target="_blank" rel="noopener">http://www.cnblogs.com</a> 的html. 服务器把Response发送回给浏览器.</p><p>\2. 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。</p><p>\3. 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</p><p>\4. 等所有的文件都下载成功后。 网页就被显示出来了。</p><h1 id="HTTP消息的结构"><a href="#HTTP消息的结构" class="headerlink" title="HTTP消息的结构"></a>HTTP消息的结构</h1><p>先看Request 消息的结构,  Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-22117.png" alt="img"></p><p>第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号</p><p>当使用的是”GET” 方法的时候， body是为空的</p><p>比如我们打开博客园首页的request 如下</p><pre><code>GET http://www.cnblogs.com/ HTTP/1.1Host: www.cnblogs.com</code></pre><p>抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response.</p><p>下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息，  如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022118.png" alt="img"></p><p>我们再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行, 结构如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022119.png" alt="img"></p><p>HTTP/version-number表示HTTP协议的版本号， status-code 和message 请看下节[<a href="https://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html#statecode" target="_blank" rel="noopener">状态代码</a>]的详细解释.</p><p>我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Response的消息，  如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-22123.png" alt="img"></p><h1 id="Get和Post方法的区别"><a href="#Get和Post方法的区别" class="headerlink" title="Get和Post方法的区别"></a>Get和Post方法的区别</h1><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p><p>我们看看GET和POST的区别</p><p>\1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p><p>\2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p><p>\3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p><p>\4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p><p>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.</p><p>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p><p>1XX 提示信息 - 表示请求已被成功接收，继续处理</p><p>2XX 成功 - 表示请求已被成功接收，理解，接受</p><p>3XX 重定向 - 要完成请求必须进行更进一步的处理</p><p>4XX 客户端错误 - 请求有语法错误或请求无法实现</p><p>5XX 服务器端错误 -  服务器未能实现合法的请求</p><p>看看一些常见的状态码</p><p>200 OK</p><p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端</p><p>如下图， 打开博客园首页</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022123.png" alt="img"></p><p>302 Found</p><p>重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request</p><p>例如在IE中输入， <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022117.png" alt="img"></p><p>304 Not Modified</p><p>代表上次的文档已经被缓存了， 还可以继续使用，</p><p>例如打开博客园首页, 发现很多Response 的status code 都是304</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022124.png" alt="img"></p><p>提示：　如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面</p><p>400 Bad Request 客户端请求与语法错误，不能被服务器所理解</p><p>403 Forbidden 服务器收到请求，但是拒绝提供服务</p><p>404 Not Found</p><p>请求资源不存在（输错了URL）</p><p>比如在IE中输入一个错误的URL， <a href="http://www.cnblogs.com/tesdf.aspx" target="_blank" rel="noopener">http://www.cnblogs.com/tesdf.aspx</a></p><p><img src="https://img.iamghf.top/blog/2020-01-04-022116.png" alt="img"></p><p>500 Internal Server Error 服务器发生了不可预期的错误</p><p>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><h1 id="HTTP-Request-header"><a href="#HTTP-Request-header" class="headerlink" title="HTTP Request header"></a>HTTP Request header</h1><p>使用Fiddler 能很方便的查看Reques header, 点击Inspectors tab -&gt;Request tab-&gt; headers 如下图所示.</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022126.png" alt="img"></p><p>header 有很多，比较难以记忆，我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p><h2 id="Cache-头域"><a href="#Cache-头域" class="headerlink" title="Cache 头域"></a>Cache 头域</h2><p>If-Modified-Since</p><p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p><p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</p><p>实例如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022120.png" alt="img"></p><p>If-None-Match</p><p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能</p><p>例如: If-None-Match: “03f2b33c0bfcc1:0”</p><p>实例如下图</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022121.png" alt="img"></p><p>Pragma</p><p>作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样</p><p>Pargma只有一个用法， 例如： Pragma: no-cache</p><p>注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p><p>Cache-Control</p><p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</p><p>Cache-Control:Public  可以被任何缓存所缓存（）</p><p>Cache-Control:Private   内容只缓存到私有缓存中</p><p>Cache-Control:no-cache 所有内容都不会被缓存</p><p>还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料</p><h2 id="Client-头域"><a href="#Client-头域" class="headerlink" title="Client 头域"></a>Client 头域</h2><p>Accept</p><p>作用： 浏览器端可以接受的媒体类型,</p><p>例如： Accept: text/html  代表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档,</p><p>如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)</p><p>通配符 * 代表任意类型</p><p>例如  Accept: <em>/</em>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)</p><p>Accept-Encoding：</p><p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;</p><p>例如： Accept-Encoding: gzip, deflate</p><p>Accept-Language</p><p>作用： 浏览器申明自己接收的语言。 </p><p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p><p>例如： Accept-Language: en-us</p><p>User-Agent</p><p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p><p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p><p>例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p><p>Accept-Charset</p><p>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；</p><p>例如：</p><h2 id="Cookie-Login-头域"><a href="#Cookie-Login-头域" class="headerlink" title="Cookie/Login 头域"></a>Cookie/Login 头域</h2><p>Cookie:</p><p>作用： 最重要的header, 将cookie的值发送给HTTP 服务器</p><h2 id="Entity头域"><a href="#Entity头域" class="headerlink" title="Entity头域"></a>Entity头域</h2><p>Content-Length</p><p>作用：发送给HTTP服务器数据的长度。</p><p>例如： Content-Length: 38</p><p>Content-Type</p><p>作用：</p><p>例如：Content-Type: application/x-www-form-urlencoded</p><h2 id="Miscellaneous-头域"><a href="#Miscellaneous-头域" class="headerlink" title="Miscellaneous 头域"></a>Miscellaneous 头域</h2><p>Referer:</p><p>作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p><p>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT" target="_blank" rel="noopener">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p><h2 id="Transport-头域"><a href="#Transport-头域" class="headerlink" title="Transport 头域"></a>Transport 头域</h2><p>Connection</p><p>例如：　Connection: keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p><p>例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p><p>Host（发送请求时，该报头域是必需的）</p><p>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p><p>例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html" target="_blank" rel="noopener">http://www.guet.edu.cn/index.html</a></p><p>浏览器发送的请求消息中，就会包含Host请求报头域，如下：</p><p>Host：<a href="http://www.guet.edu.cn" target="_blank" rel="noopener">http://www.guet.edu.cn</a></p><p>此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p><h1 id="HTTP-Response-header"><a href="#HTTP-Response-header" class="headerlink" title="HTTP Response header"></a>HTTP Response header</h1><p>同样使用Fiddler 查看Response header, 点击Inspectors tab -&gt;Response tab-&gt; headers 如下图所示</p><p><img src="https://img.iamghf.top/blog/2020-01-04-22120.png" alt="img"></p><p> 我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p><h2 id="Cache头域"><a href="#Cache头域" class="headerlink" title="Cache头域"></a>Cache头域</h2><p>Date</p><p>作用: 生成消息的具体时间和日期</p><p>例如：　Date: Sat, 11 Feb 2012 11:35:14 GMT </p><p>Expires</p><p>作用: 浏览器会在指定过期时间内使用本地缓存</p><p>例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT</p><p>Vary</p><p>作用：</p><p>例如: Vary: Accept-Encoding</p><h2 id="Cookie-Login-头域-1"><a href="#Cookie-Login-头域-1" class="headerlink" title="Cookie/Login 头域"></a>Cookie/Login 头域</h2><p>P3P</p><p>作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</p><p>例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</p><p>Set-Cookie</p><p>作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p><p>例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com</p><p><img src="https://img.iamghf.top/blog/2020-01-04-022122.png" alt="img"></p><h2 id="Entity头域-1"><a href="#Entity头域-1" class="headerlink" title="Entity头域"></a>Entity头域</h2><p>ETag</p><p>作用: 和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）</p><p>例如: ETag: “03f2b33c0bfcc1:0”</p><p>Last-Modified:</p><p>作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）</p><p>例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p><p>Content-Type</p><p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p><p>例如:</p><p>Content-Type: text/html; charset=utf-8</p><p>Content-Type:text/html;charset=GB2312</p><p>Content-Type: image/jpeg</p><p>Content-Length</p><p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p><p>例如: Content-Length: 19847</p><p>Content-Encoding</p><p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p><p>例如：Content-Encoding：gzip</p><p>Content-Language</p><p>作用： WEB服务器告诉浏览器自己响应的对象的语言者</p><p>例如： Content-Language:da</p><h2 id="Miscellaneous-头域-1"><a href="#Miscellaneous-头域-1" class="headerlink" title="Miscellaneous 头域"></a>Miscellaneous 头域</h2><p>Server:</p><p>作用：指明HTTP服务器的软件信息</p><p>例如:Server: Microsoft-IIS/7.5</p><p>X-AspNet-Version:</p><p>作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本</p><p>例如: X-AspNet-Version: 4.0.30319</p><p>X-Powered-By:</p><p>作用：表示网站是用什么技术开发的</p><p>例如： X-Powered-By: ASP.NET</p><h2 id="Transport头域"><a href="#Transport头域" class="headerlink" title="Transport头域"></a>Transport头域</h2><p>Connection</p><p>例如：　Connection: keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p><p>例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p><h2 id="Location头域"><a href="#Location头域" class="headerlink" title="Location头域"></a>Location头域</h2><p>Location</p><p>作用： 用于重定向一个新的位置, 包含新的URL地址</p><p> 实例请看304状态实例</p><h1 id="HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="HTTP协议是无状态的和Connection: keep-alive的区别"></a>HTTP协议是无状态的和Connection: keep-alive的区别</h1><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p><p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p><p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p><p> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript闭包</title>
      <link href="/javascript-bi-bao.html"/>
      <url>/javascript-bi-bao.html</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-闭包"><a href="#JavaScript-闭包" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h1><p>　Peter Mortensen问：</p><blockquote><p>就像老Albert所说的，“如果你不能向一个六岁的孩子解释清楚，那么其实你自己根本就没弄懂。”好吧，我试着向一个27岁的朋友就是JS闭包（JavaScript closure）却彻底失败了。</p><p>你们会怎么把它解释给一个充满好奇心的六岁孩子听呢？</p><p>注：我看过StackOverflow上给出的示例，但根本没用。</p></blockquote><p>　　Ali的回答：</p><p>　　当function里嵌套function时，内部的function可以访问外部function里的变量。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">++</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><p>　　不管执行多少次，都会alert 16，因为bar能访问foo的参数x，也能访问foo的变量tmp。</p><p>　　但，这还不是闭包。当你return的是内部function时，就是一个闭包。内部function会close-over外部function的变量直到内部function结束。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">++</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// bar 现在是一个闭包</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>　　上面的脚本最终也会alert 16，因为虽然bar不直接处于foo的内部作用域，但bar还是能访问x和tmp。</p><p>　　但是，由于tmp仍存在于bar闭包的内部，所以它还是会自加1，而且你每次调用bar时它都会自加1.</p><p>　　（考虑到六岁这个限制：我们其实可以建立不止一个闭包方法，比如return它们的数组，也可以把它们设置为全局变量。它们全都指向相同的x和相同的tmp，而不是各自有一份副本。）</p><p>　　注：现在来整点儿七岁的内容。</p><p>　　上面的x是一个字面值（值传递），和JS里其他的字面值一样，当调用foo时，实参x的值被复制了一份，复制的那一份作为了foo的参数x。</p><p>　　那么问题来了，JS里处理object时是用到引用传递的，那么，你调用foo时传递一个object，foo函数return的闭包也会引用最初那个object！</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>  x<span class="token punctuation">.</span>memb <span class="token operator">=</span> x<span class="token punctuation">.</span>memb <span class="token operator">?</span> x<span class="token punctuation">.</span>memb <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">alert</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>memb<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// bar 现在是一个引用了age的闭包</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>　　不出我们意料，每次运行bar(10)，x.memb都会自加1。但需要注意的是x每次都指向同一个object变量——age，运行两次bar(10)后，age.memb会变成2.</p><p>　　这和HTML对象的内存泄漏有关，呃，不过貌似超出了答题的范围。</p><p>　　JohnMerlino 对Ali说：</p><p>　　这里有一个不用return关键字的闭包例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">closureExample</span><span class="token punctuation">(</span>objID<span class="token punctuation">,</span> text<span class="token punctuation">,</span> timedelay<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>objID<span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> text<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span> timedelay<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">closureExample</span><span class="token punctuation">(</span>‘myDiv’<span class="token punctuation">,</span> ‘Closure is created’<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>　　深夜1:37 John Pick这样回答：</p><p>　　JS里的function能访问它们的：</p><p>　　1. 参数</p><p>　　2. 局部变量或函数</p><p>　　3. 外部变量（环境变量？），包括</p><blockquote><p>3.1 全局变量，包括DOM。</p><p>3.2 外部函数的变量或函数。</p></blockquote><p>　　如果一个函数访问了它的外部变量，那么它就是一个闭包。</p><p>　　注意，外部函数不是必需的。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出；但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据。</p><p>　　一个典型的例子就是全局变量的使用。</p><p>　　mykhal这样回答：</p><p>　　Wikipedia对闭包的定义是这样的：</p><blockquote><p>In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.</p></blockquote><p>　　从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。</p><p>　　Since <strong>scope-defining construction in Javascript is a function</strong>, not a code block like in many other languages, <strong>what we usually mean by *closure* in Javascript</strong> is a <strong>fuction working with nonlocal variables defined in already executed surrounding function</strong>.</p><p>　　闭包经常用于创建含有隐藏数据的函数（但并不总是这样）。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> db <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 创建一个隐藏的object, 这个object持有一些数据</span><span class="token comment" spellcheck="true">// 从外部是不能访问这个object的</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个函数, 这个函数提供一些访问data的数据的方法</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// get</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// set</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 我们可以调用这个匿名方法</span><span class="token comment" spellcheck="true">// 返回这个内部函数，它是一个闭包</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">db</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 undefined</span><span class="token function">db</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置data['x']为1</span><span class="token function">db</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 1</span><span class="token comment" spellcheck="true">// 我们不可能访问data这个object本身</span><span class="token comment" spellcheck="true">// 但是我们可以设置它的成员</span></code></pre><p>　　看了这么多外国大牛的解答，不知道你懂还是不懂，反正我是懂了。</p><p>　　P.S. 发布文章之后看到@xiaotie的<a href="http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html" target="_blank" rel="noopener">一篇文章</a>，觉得有必要推荐一下，因为其剖析得更为深入。有人说应该在文章结尾对闭包进行总结，可惜小弟才疏学浅，不能给出一个精辟的总结。</p><p>　　@xiaotie对闭包的总结如下：</p><blockquote><p>（1）闭包是一种设计原则，它通过分析上下文，来简化用户的调用，让用户在不知晓的情况下，达到他的目的；</p><p>（2）网上主流的对闭包剖析的文章实际上是和闭包原则反向而驰的，如果需要知道闭包细节才能用好的话，这个闭包是设计失败的；</p><p>（3）尽量少学习。</p></blockquote><p>　　大家学习学习。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个公司即将要倒闭的征兆是什么？</title>
      <link href="/gong-si-dao-bi.html"/>
      <url>/gong-si-dao-bi.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.iamghf.top/blog/2020-01-03-092331.jpg" alt="img"></p><p>我就经历过一个p2p公司荣辱兴衰。到现在为止，还欠我3个月工资加上杂七杂八的费用，也有6万左右。期间去劳动仲裁不管用，再去法院控告，对方不到庭，虽然胜了。但执行又是好大一笔费用，最后，心力人力憔悴，这事认个吃亏倒霉。</p><p>总结下，这家公司倒闭前的征兆，知友们可以补充。</p><p><strong>1.拼命不计成本的搞活动</strong></p><p>了解运营的小伙伴应该知道，拉新留存转化率，严盯获客成本。这个行业获客在8块左右很正常，做的活动很好，获客就低点。</p><p>到了后来，总监亲自下令只要拉来人就行，多搞活动，要搞大活动。没事，老板不差钱。底下员工各种线上线下活动搞起来，填写申请财务的单子一厚沓。我算了算当月的获客成本，足足有20元。大家知道借贷宝吧，那时候扫码就给25，只因人家背靠大树好乘凉，九鼎资本在后面能赔的起。</p><p>你一个小公司能跟人家比吗？不知道的员工还以为老板出手阔当，其实这是在跑路前的狂热，在圈钱。</p><p><strong>2.压缩人力资源成本</strong></p><p>人力资源成本是一个公司最不应该压缩的。别画饼，别梦想，就坐下来好好谈谈钱。谈好钱了，再谈梦想也不迟。员工出来工作的目的就是赚钱。</p><p>假如公司把人力资源成本压缩了，为了开源节流，那么，说明这个公司的变现能力很差。已经不能靠足够盈利来对冲掉内部员工的开支。</p><p>这种情况下，就要小心了。</p><p><strong>3.不把客户当成首位，爱答不理半死不活</strong></p><p>一个最明显的特征就是对新客户的后续服务已经漠不关心，老客户可能还有点人情味，新客户只要收到了钱，后续服务已经不再关心，甚至没收到钱，也不想努力去说服客户，这也代表这些市场人员想离开这家公司了。</p><p>尤其是和公司的盈利挂钩的直接部门，比如：线下的市场人员，线上的运营人员，是很多公司活下去的根本。假如他们都已经吊儿郎当，在公司摸鱼打卡混日子，多半公司已经没有前途了。他们都已经对公司没有了信心，某种程度上可以反应公司竞争力不行了。</p><p><strong>4.老板开始四处借钱</strong></p><p>这个也是后期我才知道的，距离老板消失没几天了。那时候抱得幻想才破灭了。知道在不主动出击就一分钱要不到了，结果还真是一分钱没要到。</p><p>资金链断裂很难修复，不管是民间借贷，还是发动公司员工集资，一旦出现这样的情况，都说明公司的财务状况不乐观。运气好能撑过去，运气不好就会很快倒闭。</p><p><strong>5.开始发不出工资或延后发工资时间</strong></p><p><strong>这条大家一定要记（加黑）</strong></p><p><strong>延后发工资时间，你可以再观望到实际发工资那天，假如没有直接辞职，这叫止损。</strong></p><p><strong>开始发不出工资了，这种情况下，不要听领导糊弄你的鬼话，其实他也是被老板糊弄的。开始发不出工资了，一定程度上解析为老板没钱了，你以为谁会给一个没钱的老板融资？</strong></p><p><strong>别抱有和公司风雨同舟的准备，那你就要有血本无归的觉悟。我当时是因为，不懂这方面，另外，那个领导对我一直不错。本着人情的关系傻乎乎的待住了。</strong></p><p><strong>出现这种情况及时辞职，一定一定！</strong></p><p><strong>6.核心领导频繁更换</strong></p><p>最早公司的模式很符合一个p2p的架构。等破产时候，接二连三，天天都有空降领导。这个总，那个总，这个背景牛逼，那个背景深。其实都是来救火的，代表这个公司已经存在很大的问题了。</p><p>管核心领导频繁更换不说，理层上也混乱起来，下属之间也是扯皮。公司的良性循环被打破，只剩下杂乱无章的发展。有了这种标志，也预示着公司有点穷途末路了。</p><p><strong>7.老板很长时间没有露脸</strong></p><p>开公司的不来公司，就对底下员工这么放心吗？</p><p>几回重大的会议，老板没有参加，这很不符合常理。</p><p>有一种可能是老板没法参加。</p><p>个中理由，自己猜测。但老板假如有问题了，那公司也岌岌可危。</p><p><strong>8.财务人员开始请辞</strong></p><p>这是我事后总结的一个征兆。财务是能碰到钱的，知道账面上有没有钱，公司的欠款什么的。他们这个部门就像去留的风向标，多注意。</p><p>来源：<a href="https://www.zhihu.com/question/283190849/answer/881415960" target="_blank" rel="noopener">知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 危机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我战胜了所有对手，却输给了时代！</title>
      <link href="/shu-gei-shi-dai.html"/>
      <url>/shu-gei-shi-dai.html</url>
      
        <content type="html"><![CDATA[<h1 id="大润发创始人挥泪离场：我战胜了所有对手，却输给了时代！"><a href="#大润发创始人挥泪离场：我战胜了所有对手，却输给了时代！" class="headerlink" title="大润发创始人挥泪离场：我战胜了所有对手，却输给了时代！"></a>大润发创始人挥泪离场：我战胜了所有对手，却输给了时代！</h1><p>历史的车轮滚滚向前，它不会因任何人的消极缓慢而停止。</p><p>时代抛弃你时，连一声再见都不会说。</p><p>大润发创始人离职时说：<strong>战胜了所有对手，却输给了时代。</strong></p><p>确实是这样，大润发在零售行业是一个号称19年不关一家店的传奇商场。在商场这个领域里，没有任何人能打败它，包括沃尔玛/家乐福，但是<strong>很可惜他败给了这个时代，被阿里巴巴收购，高层集体走人。</strong></p><p><img src="https://img.iamghf.top/blog/2020-01-03-023510.jpg" alt="img"></p><p><strong>1</strong></p><p>现在的竞争是怎么样的呢？</p><p>就像乌鸦喝水，一只老乌鸦经过长年累月的摸索，终于琢磨出了丢石子的方法，从此它就顺畅的喝到了水。并且它经常被人夸赞，方法还被写到教科书里！</p><p>然而忽然有一天，飞来了另外一群乌鸦。<strong>这群乌鸦人家根本不会衔石子，但个个嘴里都带着一根吸管：</strong></p><p><img src="https://img.iamghf.top/blog/2020-01-03-23608.jpg" alt="img"></p><p>这叫什么事嘛！</p><p>金庸小说里，金轮法王练了16年的武功，被杨过一招打败！</p><p>完全不按套路出牌。</p><p>的确，这个世界接下来就是不按套路出牌！</p><p><strong>2</strong></p><p>去年，著名数码相机品牌——尼康，关闭了它在中国的工厂。给出的理由是：<strong>智能手机的崛起侵占了原本属于数码相机的市场。</strong></p><p>按照传统的商业逻辑，尼康最多被索尼/佳能等等同行打败，没想到打败它的居然是另一个行业——<strong>智能手机。</strong></p><p>还是以数码相机行业为例，世界上曾经有一家世界500强的企业，名叫“柯达”，在1991年的时候，他的技术领先世界同行10年，但是2012年1月破产了，被做数码的干掉了。</p><p>当“索尼”还沉浸在数码领先的喜悦中时，突然发现，原来全世界卖照相机卖的最好的不是他，而是做手机的“诺基亚”，因为每部手机都是一部照相机，于是“索尼”业绩大幅亏损。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-023610.jpg" alt="img"></p><p>然后呢？</p><p>然后原来做电脑的“苹果”出来了，做出了触屏的智能手机，把手机世界老大的“诺基亚”给干掉了，而且没有还手之力：2013年9月，“诺基亚”被微软收购了……</p><p>事情还没完！</p><p>10年之后的今天，当苹果手机还在如日中天时，中国的华为异军突起，又发布了全球首款AI手机，将手机带入了人工智能时代</p><p><strong>3</strong></p><p>我之前曾写过一篇文章，讲的是方便面行业的衰败原因，当时也用过这句话。</p><p>方便面现在每年的销量以几十亿包的速度在减少，遭遇如此断崖式的危机，难道是产品出问题了吗？</p><p>不是的，反而是越做越精致，越来越全面，大的小的，干拌的，开水泡的，各种口味层出不穷，还请了一些口碑极好的明星代言宣传，但仍旧挽回不了衰败的颓势。</p><p>为什么这个曾连续18年销量保持增长的国民美食，在越做越用心的情况下，反而销量严重下滑呢？</p><p>因为有了外卖，自从外卖行业的横空出世，各种可口的美食半小时左右就能送到手上，这时候基本就没方便面什么事了。</p><p>打败康师傅的不是统一，不是今麦郎，更不是白象，不是任何一个平日里厮杀惨烈的竞争对手，而是美团、饿了么这些新兴公司，是散布在城市里大大小小的外卖美食小作坊。</p><p>就好像大润发超市，没有被沃尔玛干掉，没有被家乐福给抢走地盘，但仍被阿里巴巴收购，高层集体走人。</p><p>慢着，故事到这里还只是一个开始！</p><p>我们都知道：美团是做外卖的，滴滴是做打车的，两者井水不犯河水。</p><p>然而忽然有一天，一则“滴滴骑手招募令”在网上曝光，也就是说，打车起家的滴滴，竟然要和美团抢送餐的业务了！</p><p>这下可好，美团也宣布要进军打车业务了！为了抢夺司机资源，美团给前2万报名的司机（北京是前5万）将享受3个月0抽成的优惠。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-023607.jpg" alt="img"></p><p>下面是一张网上流传的图片，有人透露这是美团外卖渠道部的年会：最显眼的是这四个字：”灭饿除滴”。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-023609.jpg" alt="img"></p><p>乱了，乱了，全乱了！</p><p>以前，市场虽然很残酷，但我们最起码知道谁是敌人、谁是朋友。</p><p>现在呢？<strong>我们完全分辨不出来孰敌孰友了！</strong></p><p><strong>4</strong></p><p>再看几个例子：</p><p>对于80、90年代的人来说，儿时最珍贵的记忆莫过于一卷胶片，那个印在黑白时代的画面，——是整整一代人的情怀，也是那一年生人最美的芳华。</p><p>关于胶卷的记忆，大多数人脑海中第一个就会想到柯达(Kodak)，就是那个曾经闻名于世的“胶卷王国”，曾拥有将近8000多家的柯达冲印店。那些遍布大小城市街区里醒目的黄黑标识，就是孩子们最向往的地方。</p><p>可就在2012年1月19日，曾经的胶卷帝国一下子突然崩塌。柯达公司正式提出破产保护申请，市值一落千丈。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-023606.jpg" alt="img"></p><p>关于柯达衰落的原因，其实看一下数码相机在大众中掀起的潮流就知道了。而在当时，柯达却是十分抗拒新时代和新技术的来临。<strong>与其说柯达公司没有意识到，还不如说柯达是不愿意参与、推动数码技术的更新迭代，它步伐沉重地缓慢转身，然而，驻足时却发现时代的鸿沟已经清晰地将自己与前行者远远隔开。</strong>在数字化浪潮面前，曾带给无数人以美好记忆的柯达就这样被席卷着被带到了众人看不见的地方。</p><p><strong>讽刺的是，推倒柯达的数码影像技术，最早的发明者其实就是柯达。</strong>世界第一款数码相机由柯达的相机工程师Steve Sasson在1975年发明，并投入10亿美元进行相关研发，但是在当时数码业务并没有得到柯达高管们的重视，出于担心核心业务胶卷的地位受到影响，他们选择了放弃这次机会。</p><p>Steve Sasson曾告诉《纽约时报》，他发明出数码相机之后，管理层的反应是：<strong>“这很可爱，但千万别告诉任何人。”</strong></p><p>2000年以后，数码技术促使了很多行业变革，数码相机也得到了普及，佳能、尼康等日产照相机品牌抓住了这一时机，大规模地开发一系列的新机型。可是柯达依然一意孤行，执意投入在胶卷生产上，错过了数码技术这个风口。</p><p><img src="https://img.iamghf.top/blog/2020-01-03-23611.jpg" alt="img"></p><p>一个时代以前，提起“Kodak Moment”(“柯达时刻”)，人们想到的是值得留存与回味的记忆。如今，再提到柯达，却成了企业高管的警钟：在颠覆性技术侵入市场的时候，必须要及时回应。</p><p>历史的车轮滚滚向前，它不会因任何人的消极缓慢而停止。庞大如诺基亚、记忆如柯达，它们的倒下显然不是个例。如今诺基亚贱卖，柯达败落，蝴蝶效应煽动的翅膀已经遍及几乎所有行业。整个世界都陷入一种焦虑。</p><p>正如达尔文所讲，<strong>在丛林里，最终能存活下来的，往往不是最高大、最强壮的，而是对变化能做出最快反应的物种。</strong></p><p><img src="https://img.iamghf.top/blog/2020-01-03-023608.jpg" alt="img"></p><p>《三体》里有一个名词，就是：<strong>降维打击。</strong>一个无意中路过了人类文明的歌者文明，发现了人类，于是就像捏死一直蚂蚁一样，顺手灭掉了太阳系。</p><p><strong>这就叫：我消灭你，但与你无关。</strong></p><p>这个时代的残酷在于，往往你被抛弃了还一头雾水，事先不会和你打一声招呼。</p><p>那些干掉你的，通常是你从未谋面过的陌生人，或是一些你从未放在心上的人和事，同你无冤无仇，但却来势凶猛，如同洪水猛兽般令人招架不住。</p><p><strong>5</strong></p><p>在如今这个时代，如果你隐居三年，彻底与世隔绝，当再次回归红尘之中，你会感到恍如隔了一个世纪。</p><p>一切都变化地太快，快到很多人的观念还停留在上一个时代，快到很多人还没来得及做出反应，就已经被打倒在地。</p><p>在我大学即将毕业的时候，有一次去奶奶家吃饭，奶奶就问我，毕业以后学校工作分配在哪里，是我们镇上的学校还是银行啊。</p><p>我告诉她，现在学校不包分配了，全都要自己找。</p><p>她感到很奇怪，然后就唠叨说家里哪个亲戚人家大学毕业后进了什么单位，现在日子有多好…</p><p><strong>很多父母辈们对于子女的工作，期望最多的一点就是：稳定。</strong></p><p>在他们的观念里，只要你进了一家大的单位，这辈子都不用愁了，能一直干到退休，每月拿着稳定的工资，就是最大的幸福。</p><p>但现实的情况是，无论是体制内还是体制外，都没有绝对稳定的工作，谁都无法保证手上的饭碗明天还能不能端上。</p><p>那个唐山收费站的大姐没想到，那些被机器人取代了岗位的富士康员工也没想到…</p><p>在这个时代的车轮碾压下，没有人是可以逃离的，如果不做好准备，如果没有这方面的危机意识，那么当噩运来得时候，往往会招架不住，犹如天塌。</p><p>温水煮青蛙的故事我们都知道，那只青蛙一直陶醉在稳定的舒适区，幻想着岁月静好，却从来没有想过有一天，这水会热到发烫，而自己却无力跳出。</p><p><strong>未来没有稳定的工作，只有稳定的能力。</strong></p><p><strong>未来只有一种稳定：是你到哪里都有饭吃！</strong></p><p>有本事的人到哪都有饭吃，即使身背巨债，依旧可以东山再起。</p><p>而大多数人目前却处于排斥学习的状态，自然也就难以摆脱迷茫，更难以挣到钱，这才是焦虑最主要的原因。</p><p>认清这个时代，拥抱这个时代，然后活好余生。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大润发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50张2019年度最美照片，每一张都是大自然的奇迹</title>
      <link href="/2019-nian-du-zhao-pian.html"/>
      <url>/2019-nian-du-zhao-pian.html</url>
      
        <content type="html"><![CDATA[<h1 id="50张2019年度最美照片，每一张都是大自然的奇迹"><a href="#50张2019年度最美照片，每一张都是大自然的奇迹" class="headerlink" title="50张2019年度最美照片，每一张都是大自然的奇迹"></a>50张2019年度最美照片，每一张都是大自然的奇迹</h1><p>  【2019年AGORA大奖 50张入围摄影作品】<br> 经过几个月的激烈角逐，2019年AGORA大奖揭晓了入围的50张摄影作品。<br> 下面这些精美的图片从13万张作品中脱颖而出。每一张都风格独特，充满震撼力。请看大屏幕：</p><p>#1 蚂蚁扛起地球<br><img src="https://img.iamghf.top/blog/2019-12-29-130544.jpg" alt="img"><br>一只蚂蚁举起落在线上的水滴，摄影师花了4个小时才拍下这张照片。<br>@anadgphotography(菲律宾)，Analiza De Guzman/AGORA images<br>#2 最好的朋友<br><img src="https://img.iamghf.top/blog/2019-12-29-130556.jpg" alt="img"><br>蜥蜴和蜗牛的超萌瞬间。<br>@andihalil(印度尼西亚)，Andi Halil / AGORA images<br>#3 收获香料<br><img src="https://img.iamghf.top/blog/2019-12-29-130606.jpg" alt="img"><br>在越南，香料被认为可以让活人与祖先以神灵相通。<br>@ptkhanhhvnh(越南)，Khanh Phan/AGORA images<br>#4 触碰天堂<br><img src="https://img.iamghf.top/blog/2019-12-29-130612.jpg" alt="img"><br>法国的圣米歇尔山隐身于云雾之中。<br>@thedronelad(英国)，Konrad Paruch/AGORA images<br>#5 自由之歌<br><img src="https://img.iamghf.top/blog/2019-12-29-130624.jpg" alt="img"><br>这不仅仅是一张照片——更是一场自由与归属的无声斗争，灵感来自Bob Marley的《救赎之歌》。<br>@eighthman(加纳)，Michael Aboya/AGORA images<br>#6 雨天<br><img src="https://img.iamghf.top/blog/2019-12-29-130632.jpg" alt="img"><br>西爪哇的红眼树蛙。<br>@hendymp(印度尼西亚)，Hendy MP/AGORA images<br>#7 沙海孤旅<br><img src="https://img.iamghf.top/blog/2019-12-29-130639.jpg" alt="img"><br>这张照片摄于摩洛哥梅如卡的沙丘上，在那里你可以看到游牧民族穿越撒哈拉沙漠。<br>@carlesalonsophotography(西班牙)，Carles Alonso/AGORA images<br>#8 母亲的温柔<br><img src="https://img.iamghf.top/blog/2019-12-29-130645.jpg" alt="img"><br>抓拍到戴胜鸟喂孩子的完美瞬间。<br>@phyomoe(缅甸)，Phyo Moe/AGORA images<br>#9 未知的回声<br><img src="https://img.iamghf.top/blog/2019-12-29-130651.jpg" alt="img"><br>摄影师想要表现的是人与动物间的亲密关系。@theeastwoodexperience(加纳)，Clement Eastwood/AGORA images<br>#10 奔跑，嬉闹<br><img src="https://img.iamghf.top/blog/2019-12-29-130658.jpg" alt="img"><br>小僧侣们在欣毕梅佛塔玩得很开心。<br>@lingling25(缅甸)，Ling Ling/AGORA images<br>#11 生活的色彩<br><img src="https://img.iamghf.top/blog/2019-12-29-130704.jpg" alt="img"><br>在去市场前，女性们在西孟加拉邦捕鱼。<br>@pranab_basak(印度)，Pranab Basak/AGORA images<br>#12 地球的血脉<br><img src="https://img.iamghf.top/blog/2019-12-29-130710.jpg" alt="img"><br>这张神似亚马逊河的照片摄于东苏塞克斯郡，那里的卡克米尔河将草原隔开。<br>@hugohealy(英国)，Hugo Healy/AGORA images<br>#13 在光影下制作蜡染工艺品<br><img src="https://img.iamghf.top/blog/2019-12-29-130715.jpg" alt="img"><br>这是印度尼西亚日惹的蜡染。蜡染是一门古老的技艺，摄影师希望通过这张照片让它传承下去。<br>@<em>bimo</em>(印度尼西亚)，Bimo Pradityo/AGORA images<br>#14 沙蜂与猎物<br><img src="https://img.iamghf.top/blog/2019-12-29-130721.jpg" alt="img"><br>这只沙蜂正要把猎物带回家!<br>@pokokemoto(印度尼西亚)，Imam Primahardy/AGORA images<br>#15 野性的凝视<br><img src="https://img.iamghf.top/blog/2019-12-29-130726.jpg" alt="img"><br>卡巴塞诺自然公园拍到的猞猁。<br>@saavedraphotography(西班牙)，Sergio Saavedra/AGORA images<br>#16 雷讷之虹<br><img src="https://img.iamghf.top/blog/2019-12-29-130732.jpg" alt="img"><br>在挪威罗浮敦群岛的一座桥上，摄影师看到了双彩虹。<br>@uglefisk(挪威)，Paal Lund/AGORA images<br>#17 彩色屋<br><img src="https://img.iamghf.top/blog/2019-12-29-130737.jpg" alt="img"><br>荷兰格罗宁根市的长曝光日落。<br>@anskar(德国)，Anskar Lenzen/AGORA images<br>#18 母性之爱<br><img src="https://img.iamghf.top/blog/2019-12-29-130742.jpg" alt="img"><br>在西班牙的特内里费动物园，摄影师等了两个多小时才捕捉到黑猩猩和幼崽间的温馨时刻。<br>@santiagolopezfotografia, Santiago Lopez /AGORA images<br>#19 未知<br><img src="https://img.iamghf.top/blog/2019-12-29-130749.jpg" alt="img"><br>照片摄于东爪哇的赛武瀑布，想要镜头不湿，这对摄影师来说很不容易。<br>@jprphotos（英国），Jonathan Rogers/AGORA images<br>#20 撒网<br><img src="https://img.iamghf.top/blog/2019-12-29-130755.jpg" alt="img"><br>渔夫在万隆巴登岗湖捕鱼。<br>@g13nnn(印度尼西亚), Glenn Valentino/AGORA images<br>#21 神情<br><img src="https://img.iamghf.top/blog/2019-12-29-130802.jpg" alt="img"><br>巴基斯坦神庙的圣僧。<br>@asimijaz(巴基斯坦)，Asim Ijaz/AGORA images<br>#22 白伞之间<br><img src="https://img.iamghf.top/blog/2019-12-29-130808.jpg" alt="img"><br>缅甸曼德勒的传统制伞厂。传统雨伞的制作一个人无法完成，也不可能在一天之内完成。制作一把雨伞需要分工，每个人的分工都不同。<br>@aungthuya(缅甸)，Aung ThuYa/AGORA images<br>#23 暗黑迪士尼<br><img src="https://img.iamghf.top/blog/2019-12-29-130815.jpg" alt="img"><br>新天鹅城堡的俯瞰，据说这是迪士尼城堡的原型。<br>@tommimatz(德国)，Tommi Matz/AGORA images<br>#24 天意难违<br><img src="https://img.iamghf.top/blog/2019-12-29-130820.jpg" alt="img"><br>法国布列塔尼的沉船墓地。有些船在那里已有100多年的历史了。<br>@charliieb(摩纳哥)，Charlie Berthaume/AGORA images<br>#25 海洋之心<br><img src="https://img.iamghf.top/blog/2019-12-29-130827.jpg" alt="img"><br>越南渔网的航拍照片。<br>@phannguyen5285(越南)，Nguyen Phan Xuan/AGORA images<br>#26 世上最美的环形路口<br><img src="https://img.iamghf.top/blog/2019-12-29-130832.jpg" alt="img"><br>巴黎凯旋门的俯瞰全景，12条大街汇集在一起。<br>@henrydo(美国)，Henry Do/AGORA images<br>#27 冰之海<br><img src="https://img.iamghf.top/blog/2019-12-29-130838.jpg" alt="img"><br>专业野生动物摄影师在南极拍下了这张照片。捕食蟹类的海豹喜欢在冰块上小憩。<br>@florianledoux(法国)，Florian Ledoux/AGORA images<br>#28 雪中牧马人<br><img src="https://img.iamghf.top/blog/2019-12-29-130844.jpg" alt="img"><br>蒙古的冬天。<br>@zayyarlin(缅甸)，Zay Yar Lin/AGORA images<br>#29 舞者<br><img src="https://img.iamghf.top/blog/2019-12-29-130849.jpg" alt="img"><br>摄于雅典和平友谊体育场。<br>@markellos(希腊)，Markellos Plakitsis/AGORA images<br>#30 斑马之眼<br><img src="https://img.iamghf.top/blog/2019-12-29-130854.jpg" alt="img"><br>这张照片拍摄于马德里野生动物园。<br>@s.p。marin(西班牙)，Sara Pinto marin /AGORA images<br>#31 悬而未定<br><img src="https://img.iamghf.top/blog/2019-12-29-130859.jpg" alt="img"><br>这张照片摄于加州托多斯桑托斯的公路旅行。摄影师很幸运，后来他还与这些动物们一起潜水了!<br>@jordisark(西班牙)，Jordi Sark/AGORA images<br>#32 水牛回栏<br><img src="https://img.iamghf.top/blog/2019-12-29-130906.jpg" alt="img"><br>在越南中部的波来古洗澡的水牛。<br>@hoangquocvinh, Hoang Quocvinh/AGORA images<br>#33 日食钻石环<br><img src="https://img.iamghf.top/blog/2019-12-29-130913.jpg" alt="img"><br>2017年的日全食，摄于内布拉斯加州。<br>@edoindo(美国)，Edward Panjaitan/AGORA images<br>#34 等待的女人<br><img src="https://img.iamghf.top/blog/2019-12-29-130918.jpg" alt="img"><br>在罗马的罗通达广场，女人在香肠店等着买东西。<br>@paulaaranoa(阿根廷)，Paula Aranoa /AGORA images<br>#35 水即生命<br><img src="https://img.iamghf.top/blog/2019-12-29-130924.jpg" alt="img"><br>虽然台风在菲律宾很常见，但菲律宾人仍然崇拜水这种赋予生命的元素。<br>@froirivera(菲律宾)，Froi Rivera/AGORA images<br>#36 忆往昔<br><img src="https://img.iamghf.top/blog/2019-12-29-130930.jpg" alt="img"><br>孤独的男人望着日本神户的地平线。<br>@patriciasoon(马来西亚)，Patricia Soon/AGORA images<br>#37 草莓的温室<br><img src="https://img.iamghf.top/blog/2019-12-29-130934.jpg" alt="img"><br>在土耳其爱琴海地区草莓田里工作的年轻女子。<br>@leylaemektar(土耳其)，Leyla Emektar/AGORA images<br>#38 开斋节的祈祷<br><img src="https://img.iamghf.top/blog/2019-12-29-130939.jpg" alt="img"><br>斋月的斋戒之后，在伊斯兰猎月第一天进行开斋节祈祷。<br>@azimronnie(孟加拉国)，Azim Ronnie/AGORA images<br>#39 耕作<br><img src="https://img.iamghf.top/blog/2019-12-29-130944.jpg" alt="img"><br>这张照片摄于越南北部的稻田。农夫们正为下一季的丰收在插秧。<br>@diepvan(越南)，Diep Van/AGORA images<br>#40 六尺之下<br><img src="https://img.iamghf.top/blog/2019-12-29-130948.jpg" alt="img"><br>乌克兰一个雾蒙蒙的早晨，摄影师看到一个男人在墓地里徒手挖坟。<br>@davidedziegler(西班牙)，David Carbonell/AGORA images<br>#41 大雨滂沱<br><img src="https://img.iamghf.top/blog/2019-12-29-130953.jpg" alt="img"><br>摄影师为父亲拍下在雨中极具张力的肖像。<br>@wunderbilder(德国)，Perry Wunderlich/AGORA images<br>#42 蓝色之眼<br><img src="https://img.iamghf.top/blog/2019-12-29-130958.jpg" alt="img"><br>摄影师拍下了他儿子在巴伦西亚的艺术科学城奔跑的瞬间。<br>@ajuriaguerra(西班牙)，Pedro Luis Ajuriaguerra Saiz/AGORA images<br>#43 生命之光<br><img src="https://img.iamghf.top/blog/2019-12-29-131003.jpg" alt="img"><br>这是清晨中的西拉洪大桥，它位于打横和尖米士的交界处，1893年由荷兰殖民者建造。<br>@dikyedarling(印度尼西亚)，Dikye Ariani/AGORA images<br>#43 开启一切的火花<br><img src="https://img.iamghf.top/blog/2019-12-29-131007.jpg" alt="img"><br>在加泰罗尼亚的传统节日期间，装扮成恶魔的人们在人群中燃放烟花。<br>@xopet1969(西班牙)，Albert Castane /AGORA images<br>#45 奋勇向前<br><img src="https://img.iamghf.top/blog/2019-12-29-131012.jpg" alt="img"><br>这张照片是在尼亚斯岛附近拍摄的，该地是著名的冲浪胜地。<br>@bastian_as(印度尼西亚)，Bastian AS/AGORA images<br>#46 准备开斋节的食物<br><img src="https://img.iamghf.top/blog/2019-12-29-131019.jpg" alt="img"><br>这三个人在准备1000盘鸡肉和米饭，为开斋做准备。<br>@dharmaku(印度尼西亚)，Dharma Kurniawan/AGORA images<br>#47 消防员<br><img src="https://img.iamghf.top/blog/2019-12-29-131024.jpg" alt="img"><br>孟加拉国发生了一起电路起火事故，当地居民和消防员组团灭火。<br>@tanveer.rohan(孟加拉国)，Tanveer rohan /AGORA images<br>#48 出海的”地中海邮轮管乐号“<br><img src="https://img.iamghf.top/blog/2019-12-29-131029.jpg" alt="img"><br>来自泽西海峡群岛的18岁摄影师是本届大赛最年轻的入围者。邮轮正在他家乡附近的港口航行。<br>@above_and_beyond_visuals(英国)，Cameron Aird/AGORA images<br>#49 农场和道路被洪水淹没<br><img src="https://img.iamghf.top/blog/2019-12-29-131035.jpg" alt="img"><br>伊朗北部的戈尔甘市发生了洪灾。<br>@mohammadmoheimany(伊朗)，Mohammad Moheimani/AGORA images<br>#50 男孩们<br><img src="https://img.iamghf.top/blog/2019-12-29-131044.jpg" alt="img"><br>通过这张照片，摄影师想要表现两个人类之间的平等。<br>@diegocampomar(乌拉圭)，Diego Campomar/AGORA images</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 照片 </tag>
            
            <tag> AGORA大奖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变</title>
      <link href="/xia-wen-hua.html"/>
      <url>/xia-wen-hua.html</url>
      
        <content type="html"><![CDATA[<h1 id="从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变"><a href="#从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变" class="headerlink" title="从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变"></a>从游侠到豪侠再到官侠，中国古代“侠”之文化为何会发生异变</h1><p>提起侠客一词，大部分人的第一印象便是金庸武侠小说中武功高强行侠仗义的英雄人物，他们或放荡不羁，或洒脱高洁，引得人深深向往。诚然，历史上的侠客如影视文学作品中的不在少数，但其实，他们也是在随时间经历了数代演变之后，才形成此类特征。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132536.jpg" alt="img"> </p><p>侠客产生的社会背景</p><p>古代生产工具的落后注定了社会资源生产效率的低下，这导致平民百姓的生活只能在温饱线上挣扎。若是遇到政治黑暗的年代，基本生存亦会更加困难。</p><p>因此，在精神上，这种对上天的无奈和对社会不公现象的愤懑，使得平民百姓渴望有一位“取予然诺，千里诵义，为死不顾世”的侠客来帮助自己摆脱困苦，侠客精神也顺应这种希望而产生。</p><p>由于周王朝初期便定下的以礼教人、以德服人的社会管理方针，当时人们的思想道德水平也普遍拔高，这使得侠客之行有了实施者与承担者。同时，这些侠客不为自己谋私利的行为出发目的，也为他们积累的大量的声望，成为时人钦佩与敬仰的对象。在这样的社会影响下，侠客自然也层出不穷。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132545.jpg" alt="img"> </p><p>以身触法，江湖留名</p><p>早期侠客的行为准则与行为规范全凭自己的道德底线与个人喜好，他们既不受朝廷管理，也不为法律约束。虽然他们人数不多，但大都由于继承了先秦时期的良好风范与高尚情操，所以道德水平与目光远见方面，也远超常人。</p><p>也正由于这类人的存在，才形成了侠客精神在历史发展中的第一阶段：游侠。他们的行为绝非是为了功名利禄与显赫名声，相反，由于他们所解救的人中大多与政治有所瓜葛，这导致他们时常与官府为敌，甚至连累自己遭到通缉也是家常便饭。</p><p>但是，与莫大危险相对应的，却是在江湖上极高的威望与名声。如汉朝时期的朱家与郭解，便是在冒着生命危险的情况下，在解救了成千上百人的性命之后，才得到了“自关以东,莫不延颈愿交焉。”的社会地位。又如《水浒传》中的宋江，也是在这样的情况下才能稳坐后期梁山泊的第一把交椅。</p><p>也许这种社会地位并非他们主观上所故意造成的，但作为他们付出的代价，这种回报却是他们应该得到的。由此可见，游侠人士在当时江湖中的影响力与声望是极为强大的。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132552.jpg" alt="img"> </p><p>时代更迭，思想挣扎</p><p>由于唐朝国力的鼎盛，莫说王公贵族，即便是普通百姓，在社会生活上也处于一种较为奢侈的状态。而西域与唐朝之间的频繁贸易往来，更使得当时的文化在杂糅百家之后，显得多姿多彩。</p><p>繁华的生活，灿烂的文化，再加上文人墨客的渲染，都令尚有春秋遗留之风的游侠不再将自己限制于所谓的儒家君子道德之中，保持着一颗淡泊明志的心，而是开始向朝廷靠拢，想要追求自己的一片荣华富贵。</p><p>也因此，侠客也产生了在历史发展中的第二个阶段：豪侠。“红线夜盗魏博节度使田承嗣床头金盒;聂隐娘为陈许节度使刘昌裔屡退刺客 ; 虬髯客更是有图王之志。”，这些虽只是文学作品的片段，但也在一定程度反映了当时试图改变的侠客们的真实影像。</p><p>但千年传承下来的游侠之风，却仍深深影响着豪侠们的思想与行为。李白诗中所言“事了拂衣去，深藏功与名”实际反映了在当时人们的心中，侠客依旧应该是那种不谋私利不问世事的人。</p><p>而这也使得依托平民百姓而存在的豪侠们，在此种思想的影响下不敢完全投身于功名利禄的追求之中，甚至即便在被官府重用之后，也要尽快脱身，不愿沉陷其中。由此可见，夹在官府与江湖中间的豪侠们，其思想上相比于充满江湖气息的游侠和其后充满官宦气息的官侠相比，具有更多的复杂性与可变性。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132559.jpg" alt="img"> </p><p>官府招安，江湖渐远</p><p>宋朝后，社会经济的快速发展与市民阶层地位的提升，使统治者不得不在某些方面对广大百姓做出政策上的让步。大量从社会底层脱颖而出的士人进入官场，虽然他们政见不同，想法不一，但却大都为官清廉，品格正直。在这种社会良好风气的更正下，普通百姓对清官的依赖，渐渐高于相比之下更加虚无缥缈的侠人义士。</p><p>再加上深受儒家“为官入仕”思想的影响，人们的希望已普遍不在所谓的侠客身上，而是更希望自己进入朝廷，为民造福，侠的思想也因此开始体现在官的身上。当平民百姓的思想改变之后，摇摆于江湖与官府之间的豪侠们，也渐渐转投于官府的怀抱，不再犹犹豫豫。</p><p>作为中国武侠小说中的代表，《三侠五义》通过对几位侠客的故事叙述。描绘出了一副江湖气息十足的画卷。但需要注意的是，在这部小说中，不同侠客们行为动机的背后却都指向同一个目标：功名利禄。</p><p>也许他们的除暴安良行为确实满足了普通百姓的需要与愿望，但其本质目的，却是将此作为自己拜见朝廷的投名状，以获取更高的政治地位。官侠作为豪侠的接替形式，也借此登上历史的舞台，并最终成为侠客在中国历史发展中的最后一个阶段。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132606.jpg" alt="img"> </p><p>侠客们自游至官的背后原因</p><p>在中国社会的千年发展中，由于封建统治者自身的统治需要，一系列禁锢大众百姓思想的措施被运用。无论是宋朝的“存天理，灭人欲”思想，还是明清时期靠八股文取士的政策，都使得人们的思维愈发僵化，甘当侠客的人渐渐消失。而有关侠客的事迹，也在《汉书》过后，不再记录于书本之中。</p><p>与此同时，随着社会秩序的愈发严格与管理系统的愈发完善，原始侠客们的社会生存空间愈发受限，他们也不得不另谋出路以作资。在这种循环下，侠客行为变得愈发具有功利性而逐渐丧失原有的自发性，也属历史发展的必然。</p><p>同时，科举制度在隋唐之后的盛行，也对下层平民百姓的生活造成了巨大的影响。不管是两汉察举制还是魏晋九品中正制，都使得贵家大族垄断了为官之路，普通人难有出头之日。</p><p>然而，在科举制度施行后，下层群众的拔擢机会显而易见地扩大，当读书与做官紧密结合在一起后，百姓们的入仕积极性也显著提高，这一中国古代发展史的大变革，却间接造成了侠客们后继无人的尴尬情况。</p><p>社会主流思潮的改变，也对侠客的存在产生了致命的打击。因为侠客们自身武功高强，非寻常人能敌，再加上他们以暴制暴的惯用手法，万一在行侠仗义的过程中对无辜者造成了伤害，无人赔偿这种损失便成了一个社会现实性的问题。</p><p><img src="https://img.iamghf.top/blog/2019-12-29-132614.jpg" alt="img"> </p><p>久而久之，侠客们的社会声望与自身名气开始受到致命性打击，他们也不再受到群众的爱戴与拥护。侠客们作为不受朝廷控制与法律监管的人，早就为朝廷所忌惮，而在没了“白昼杀人红尘中,京兆知名不敢捕。”的社会地位后，他们的人身安全开始受到极大的威胁。</p><p>在这种情况之下，相比对抗官府，加入其中，反倒成了最好的解决措施与选择。</p><p>虽然不同时期的侠客对社会的影响的深度不同，但不可否认的是，他们早已渗透进人们生活的方方面面。侠客们的故事作为大众百姓茶余饭后的谈资，极大丰富了人们的日常生活，他们的行为也被不断模仿，成为中华文化的一种符号。</p><p>而作为说书先生和文学作品的描写对象，他们又在客观上促进了古代商品经济的发展，推动了平民阶层地位的提升。同时，侠客们作为曾经百姓所崇拜与敬仰的对象，他们自身所拥有的品格与修养也在不自觉中成为了中国道德标准的一部分，在千年间对国人的思想观念造成了巨大的影响。</p><p>其实，侠客精神在我国的文明传承中从未消失，它只是在不同时代有着不同的显现方式而已。无论是战争时代抗击外敌侵略的英勇战士，还是在和平社会乐于助人的热心群众，都是传统侠义精神的传承者与实施者。而行侠仗义这种方式，也在不断地文明进步中，更加合理、自然的融入这个社会。</p><p>参考资料:</p><p>《史记·游侠列传》</p><p>《论武侠小说》</p><p>《中国文学侠特征的异变及启示》</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 侠客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charles 抓包使用教程</title>
      <link href="/charles-zhua-bao-shi-yong-jiao-cheng.html"/>
      <url>/charles-zhua-bao-shi-yong-jiao-cheng.html</url>
      
        <content type="html"><![CDATA[<h1 id="Charles-抓包使用教程"><a href="#Charles-抓包使用教程" class="headerlink" title="Charles 抓包使用教程"></a>Charles 抓包使用教程</h1><ul><li><p>charles使用教程</p></li><li><p>将 Charles 设置成系统代理</p></li><li><p>Charles 主界面介绍</p></li><li><p>过滤网络请求</p></li><li><p>截取 iPhone 上的网络封包</p></li><li><p>截取 Https 通讯信息</p></li><li><p>模拟慢速网络</p></li><li><p>修改网络请求内容</p></li><li><p>给服务器做压力测试</p></li><li><p>修改服务器返回内容</p></li><li><p>总结</p></li><li><p><strong>简介</strong></p></li><li><p><img src="https://img.iamghf.top/blog/2019-12-27-082708.png" alt="img"></p><p><a href="http://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a> 是在 Mac 下常用的网络封包截取工具，在做 <a href="http://lib.csdn.net/base/wechat" target="_blank" rel="noopener"><strong>移动开发</strong></a>时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p><p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p><p>除了在做<a href="http://lib.csdn.net/base/android" target="_blank" rel="noopener"><strong>移动开发</strong></a>中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p><p>Charles 主要的功能包括：</p><ol><li>截取 Http 和 Https 网络封包。</li><li>支持重发网络请求，方便后端调试。</li><li>支持修改网络请求参数。</li><li>支持网络请求的截获并动态修改。</li><li>支持模拟慢速网络。</li></ol></li></ul><p>  <strong>将 Charles 设置成系统代理</strong></p><p>  之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。</p><p>  启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” –&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082741.png" alt="img"></p><p>  之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。</p><p>  需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。</p><p>  <strong>Charles 主界面介绍</strong></p><p>  <strong><em>\</em><img src="https://img.iamghf.top/blog/2019-12-27-082748.png" alt="img">**</strong></p><p>  Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。</p><ol><li><p>Structure 视图将网络请求按访问的域名分类。</p></li><li><p>Sequence 视图将网络请求按访问的时间排序。</p><p>大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。</p><p>对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。</p></li></ol><p>  <strong>过滤网络请求</strong></p><p>  通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法：</p><p>  方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：<a href="http://yuantiku.com" target="_blank" rel="noopener">http://yuantiku.com</a> , 那么只需要在 Filter 栏中填入 yuantiku 即可。</p><p>  方法二：在 Charles 的菜单栏选择 “Proxy”–&gt;“Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082800.png" alt="img"></p><p>  通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。</p><p>  方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082806.png" alt="img"></p><p>  这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。</p><p>  <strong>截取 iPhone 上的网络封包</strong></p><p>  Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。</p><p>  <strong>Charles 上的设置</strong></p><p>  要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”–&gt;“Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示:</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082812.png" alt="img"></p><p>  <strong>iPhone 上的设置</strong></p><p>  首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”–&gt;“Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082818.png" alt="img"></p><p>  在 iPhone 的 “ 设置 ”–&gt;“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082822.png" alt="img"></p><p>  设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082828.png" alt="img"></p><p>  <strong>截取 Https 通讯信息</strong></p><p>  <strong>安装证书</strong></p><p>  如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。</p><p>  首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” –&gt; “SSL Proxying” –&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082833.png" alt="img"></p><p>  需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082839.png" alt="img"></p><p>  这样，对于该 Host 的所有 SSL 请求可以被截取到了。</p><p>  <strong>截取移动设备中的 Https 通讯信息</strong></p><p>  如果我们需要在 <a href="http://lib.csdn.net/base/ios" target="_blank" rel="noopener"><strong>iOS</strong></a> 或 <a href="http://lib.csdn.net/base/android" target="_blank" rel="noopener"><strong>Android</strong></a> 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” –&gt; “SSL Proxying” –&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082845.png" alt="img"></p><p>  按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：<a href="http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的" target="_blank" rel="noopener">http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的</a> Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。</p><p>  <strong>模拟慢速网络</strong></p><p>  在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener"><strong>测试</strong></a>在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。</p><p>  在 Charles 的菜单上，选择 “Proxy”–&gt;“Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082851.png" alt="img"></p><p>  如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。</p><p>  <strong>修改网络请求内容</strong></p><p>  有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082857.png" alt="img"></p><p>  我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082909.png" alt="img"></p><p>  <strong>给服务器做压力测试</strong></p><p>  我们可以使用 Charles 的 Repeat 功能来简单地<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener"><strong>测试</strong></a>服务器的并发处理能力，方法如下。</p><p>  我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示：</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082915.png" alt="img"></p><p>  接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082920.png" alt="img"></p><p>  悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener"><strong>数据库</strong></a>打挂了，嗯，请叫我雷锋。</p><p>  <strong>修改服务器返回内容</strong></p><p>  有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。</p><p>  根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：</p><ol><li>Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。</li><li>Rewrite 功能适合对网络请求进行一些正则替换。</li><li>Breakpoints 功能适合做一些临时性的修改。</li></ol><p>  <strong>Map 功能</strong></p><p>  Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。</p><p>  在 Charles 的菜单中，选择 “Tools”–&gt;“Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082925.png" alt="img"></p><p>  对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 ytk1.yuanku.ws（测试服务器）的请求重定向到了 <a href="http://www.yuantiku.com（线上服务器）。" target="_blank" rel="noopener">www.yuantiku.com（线上服务器）。</a></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082930.png" alt="img"></p><p>  对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。</p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082936.png" alt="img"></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082951.png" alt="img"></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-082956.png" alt="img"></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-083128.png" alt="img"></p><p>  <img src="https://img.iamghf.top/blog/2019-12-27-083122.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2009⇆2019：六组数据里的中国十年</title>
      <link href="/zhong-guo-shi-nian.html"/>
      <url>/zhong-guo-shi-nian.html</url>
      
        <content type="html"><![CDATA[<h1 id="2009⇆2019：六组数据里的中国十年"><a href="#2009⇆2019：六组数据里的中国十年" class="headerlink" title="2009⇆2019：六组数据里的中国十年"></a>2009⇆2019：六组数据里的中国十年</h1><p> 来源：微信公众号吴晓波频道</p><p>你的2019年余额仅剩6天</p><p>在即将迈向2020年的这个节点</p><p>我们不妨回顾一下</p><p>过去10年的变化</p><p>当2009年第一缕阳光洒下的时候</p><p>马云还是阿里巴巴CEO</p><p>彼时茅台的股价也才<strong>60元</strong></p><p>手机应用商店里还搜不到支付宝</p><p>10年后的2019年</p><p>马爸爸已投身教育事业</p><p>茅台股价飙涨了<strong>20倍</strong></p><p>支付宝下载量超过<strong>120亿</strong></p><p>当然，在这10年中</p><p>有不少新玩意应运而生</p><p><strong>会员制</strong>成为新兴线上付费模式</p><p><strong>共享单车</strong>解决了“出行最后一公里”难题</p><p>……</p><p>那么</p><p>正值201“X”年结束之际</p><p>不妨看看小巴整理的一些对比图</p><p>感受这10年间的变化</p><p><img src="https://img.iamghf.top/blog/2019-12-26-123550.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123607.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123616.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123628.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123644.jpg" alt="img"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-123656.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 十年 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vsftpd高级用法之虚拟用户配置</title>
      <link href="/vsftpd-gao-ji-yong-fa-zhi-xu-ni-yong-hu-pei-zhi.html"/>
      <url>/vsftpd-gao-ji-yong-fa-zhi-xu-ni-yong-hu-pei-zhi.html</url>
      
        <content type="html"><![CDATA[<h1 id="vsftpd高级用法之虚拟用户配置"><a href="#vsftpd高级用法之虚拟用户配置" class="headerlink" title="vsftpd高级用法之虚拟用户配置"></a>vsftpd高级用法之虚拟用户配置</h1><p>需求：需要2个ftp用户访问不同的根目录，其他的访问ftp默认目录。</p><p>2个用户为：test1、test2</p><p>首先安装vsftpd，然后配置文件如下：</p><p>vsftpd.conf：</p><p>anonymous_enable=NO</p><p>local_enable=YES</p><p>write_enable=YES</p><p>local_umask=022</p><p>dirmessage_enable=YES</p><p>xferlog_enable=YES</p><p>connect_from_port_20=YES</p><p>xferlog_std_format=YES</p><p>chroot_local_user=NO</p><p>chroot_list_enable=YES</p><p>chroot_list_file=/etc/vsftpd/chroot_list</p><p>listen=YES</p><p>ftpd_banner=”welcome test Ftp Server.”</p><p>pam_service_name=vsftpd  #设置PAM使用的名称,该名称就是/etc/pam.d/目录下vsfptd文件的文件名</p><p>userlist_enable=YES</p><p>tcp_wrappers=YES</p><p>local_root=/home/www/test/upload/</p><p>virtual_use_local_privs=YES</p><p>guest_enable=YES  #表示是否开启vsftpd虚拟用户的功能，yes表示开启，no表示不开启。</p><p>guest_username=www</p><p>user_config_dir=/etc/vsftpd/vuser_conf #指定每个虚拟用户账号配置目录</p><p>pasv_enable=YES</p><p>pasv_min_port=40000</p><p>pasv_max_port=40080</p><p>pasv_promiscuous=YES</p><p>创建虚拟用户配置目录：</p><p>mkdir /etc/vsftpd/vuser_conf</p><p>创建虚拟用户文件，把这些用户名和密码存放在一个文件中。该文件内容格式是：用户名占用一行，密码占一行。如下：</p><p>[root@localhost vsftpd]# cat /etc/vsftpd/login.txt<br>test1<br>testone<br>test2<br>testtwo</p><p>这个文件的虚拟用户和密码的文本文件无法被系统帐号直接调用，所以我们需要使用db_load命令生成db口令数据库文件，命令如下：</p><p><strong>db_load -T -t hash -f /etc/vsftpd/login.txt /etc/vsftpd/login.db</strong></p><p>为了使服务器能够使用上述生成的数据库文件，对客户端进行身份验证，需要调用系统的PAM模块。PAM(Plugable Authentication Module)为可插拔认证模块，不必重新安装应用系统，通过修改指定的配置文件，调整对该程序的认证方式。PAM模块配置文件路径为/etc/pam.d/目录，此目录下保存着大量与认证有关的配置文件，并以服务名称命名。</p><p>我们现在切换到/etc/pam.d/ 目录下，编辑vsfptd文件。如下图：</p><p>[<img src="https://img.iamghf.top/blog/2019-12-26-113253.jpg" alt=""></p><p>auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/login</p><p>account required /lib64/security/pam_userdb.so db=/etc/vsftpd/login</p><p>auth是指对用户的用户名口令进行验证。</p><p>accout是指对用户的帐户有哪些权限哪些限制进行验证。</p><p>再后面的/lib64/security/pam_userdb.so表示该条审核将调用pam_userdb.so这个库函数进行。</p><p>注意该函数会根据系统的位数而所在位置不同。</p><p>如果是32bit系统，该文件所在位置是/lib/security/pam_userdb.so</p><p>如果是64bit系统，该文件所在位置是/lib64/security/pam_userdb.so</p><p>最后db=/etc/vsftpd/login则指定了验证库函数将到这个指定的数据库中调用数据进行验证。其实该文件指的是/etc/vsftpd/login.db文件。</p><p><strong>注意：**</strong>db=/etc/vsftpd/login<strong>**格式是这样的，去掉.db后缀。</strong></p><p>PAM配置完毕后，我们现在开始创建虚拟用户与系统用户对应的文件。切换到/etc/vsftpd/vuser_conf目录下，并创建test1文件。注意该文件名称一定要与login.txt中的虚拟用户要对应。比如现在login.txt文件有test1用户，那么在 /etc/vsftpd/vuser_conf目录下创建一个文件名为test1的文件。</p><p>[root@localhost vsftpd]# cat /etc/vsftpd/vuser_conf/test1</p><p>local_root=/home/www/test1/upload/  #表示使用本地用户登录到ftp时的默认目录<br>virtual_use_local_privs=YES  #虚拟用户和本地用户有相同的权限<br>guest_username=www  #表示的是设置FTP对应的系统用户为www<br>write_enable=YES<br>anon_umask=022</p><p>以上配置完毕后，启动vsftpd服务完成。</p><p>测试test1、test2 ftp用户均可以正常登录，对应的根目录不同，均有创建和删除、上传权限。</p><p><strong>ftp虚拟用户，故不需要事先创建系统用户。</strong></p><p>关于chroot：</p><p>  \1. chroot_local_user</p><p>  \2. chroot_list_enable</p><p>  \3. chroot_list_file</p><p>可以通过如下两种方法来设置chroot，从而杜绝上述不安全的情况发生：</p><p>（1）设置所有的本地用户执行chroot，只要将/etc/vsftpd/vsftpd.con文件中的chroot_local_ user值置为YES，即       chroot_local_user=YES。</p><p>（2）设置指定的用户执行chroot，按照如下方法进行设置：</p><pre><code>chroot_local_user=NOchroot_list_enable=YESchroot_list_file=/etc/vsftpd.chroot_list</code></pre><p>设置后，只有/etc/vsftpd.chroot_list文件中指定的用户才能够执行chroot命令。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装配置vsftp搭建FTP</title>
      <link href="/centos7-an-zhuang-pei-zhi-vsftp-da-jian-ftp.html"/>
      <url>/centos7-an-zhuang-pei-zhi-vsftp-da-jian-ftp.html</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS7安装配置vsftp搭建FTP"><a href="#CentOS7安装配置vsftp搭建FTP" class="headerlink" title="CentOS7安装配置vsftp搭建FTP"></a>CentOS7安装配置vsftp搭建FTP</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装前查看是否已安装vsftpd</p><pre><code># 查看是否已安装 方法一[root@localhost ~]# rpm -q vsftpdvsftpd-3.0.2-21.el7.x86_64# 查看是否已安装 方法二[root@localhost ~]# vsftpd -vvsftpd: version 3.0.2# 安装 vsftpd[root@localhost ~]# yum -y install vsftpd</code></pre><h2 id="查看位置"><a href="#查看位置" class="headerlink" title="查看位置"></a>查看位置</h2><pre><code>[root@localhost ~]# whereis vsftpdvsftpd: /usr/sbin/vsftpd /etc/vsftpd /usr/share/man/man8/vsftpd.8.gz</code></pre><h2 id="启动vsftpd服务"><a href="#启动vsftpd服务" class="headerlink" title="启动vsftpd服务"></a>启动vsftpd服务</h2><pre><code>systemctl start vsftpd.service</code></pre><h2 id="关闭firewall和SELinux"><a href="#关闭firewall和SELinux" class="headerlink" title="关闭firewall和SELinux"></a>关闭firewall和SELinux</h2><pre><code>setenforce 0   # 设置SELinux 成为permissive模式  （关闭SELinux）setenforce 1   # 设置SELinux 成为enforcing模式   （开启SELinux）# 或者修改配置vi /etc/selinux/config# SELINUX=enforcing# 注释掉# SELINUXTYPE=targeted# 注释掉SELINUX=disabled# 增加:wq! #保存退出setenforce 0</code></pre><p>或者设置SELinux</p><pre><code>getsebool -a | grep ftpsetsebool -P ftpd_full_access onsystemctl stop firewalld.service#停止firewallsystemctl disable firewalld.service#禁止firewall开机启动</code></pre><p>如果你不愿意关闭防火墙，需要防火墙添加FTP服务。</p><pre><code>firewall-cmd --permanent --zone=public --add-service=ftpfirewall-cmd --reload</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>配置文件<code>/etc/vsftpd/vsftpd.conf</code></p><pre><code>anonymous_enable=NO        # 不允许匿名访问，禁用匿名登录chroot_local_user=YES      # 启用限定用户在其主目录下use_localtime=YES          # 使用本地时(自行添加)chroot_list_enable=YESlocal_enable=YES           # 允许使用本地帐户进行FTP用户登录验证allow_writeable_chroot=YES # 如果启用了限定用户在其主目录下需要添加这个配置，解决报错 500 OOPS: vsftpd: refusing to run with writable root inside chroot()xferlog_enable=YES         # 启用上传和下载的日志功能，默认开启。local_umask=022            # 设置本地用户默认文件掩码022# FTP上本地的文件权限，默认是077，不过vsftpd安装后的配置文件里默认是022</code></pre><p>虚拟用户高级参数</p><pre><code>当virtual_use_local_privs=YES 时，虚拟用户和本地用户有相同的权限；当virtual_use_local_privs=NO  时，虚拟用户和匿名用户有相同的权限，默认是NO。当virtual_use_local_privs=YES，write_enable=YES时，虚拟用户具有写权限（上传、下载、删除、重命名）。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=YES，anon_upload_enable=YES时，虚拟用户不能浏览目录，只能上传文件，无其他权限。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=NO，anon_upload_enable=NO时，虚拟用户只能下载文件，无其他权限。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=NO，anon_upload_enable=YES时，虚拟用户只能上传和下载文件，无其他权限。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=NO，anon_mkdir_write_enable=YES时，虚拟用户只能下载文件和创建文件夹，无其他权限。当virtual_use_local_privs=NO，write_enable=YES，anon_world_readable_only=NO，anon_other_write_enable=YES时，虚拟用户只能下载、删除和重命名文件，无其他权限。</code></pre><h2 id="匿名登录"><a href="#匿名登录" class="headerlink" title="匿名登录"></a>匿名登录</h2><p>安装完默认情况下是开启匿名登录的，对应的是 <code>/var/ftp</code> 目录，这时只要服务启动了，就可以直接连上FTP了。默认用户名是<code>ftp</code>，密码是空的。如果你在配置里面配置了<code>anonymous_enable=NO</code>，匿名就无法登录。</p><pre><code>$ ftp 192.168.188.114Connected to 192.168.188.114.220 (vsFTPd 3.0.2)Name (192.168.188.114:kennywang): ftp331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; ls229 Entering Extended Passive Mode (|||47867|).150 Here comes the directory listing.-rw-r--r--    1 0        0              12 Jan 18 06:31 README.mddrwxr-xr-x    2 0        0               6 Nov 05 19:43 pub226 Directory send OK.</code></pre><h2 id="多用户配置"><a href="#多用户配置" class="headerlink" title="多用户配置"></a>多用户配置</h2><p>多用户配置需要自己手工添加配置，下面内容到vsftpd.conf末尾</p><pre><code># # use_localtime=YES          # 使用本地时(自行添加)listen_port=21chroot_local_user=YES      # 启用限定用户在其主目录下idle_session_timeout=300data_connection_timeout=120  # 数据连接超时时间guest_enable=YES             # 设定启用虚拟用户功能guest_username=ftpuser       # 指定虚拟用户的宿主用户 ftpuser（就是我们后面会新建这个用户）# guest_username=www# 如果ftp目录是指向网站根目录，用来上传网站程序，# 可以指定虚拟用户的宿主用户为nginx运行账户www，可以避免很多权限设置问题 user_config_dir=/etc/vsftpd/vuser_conf   # 虚拟用户配置文件目录virtual_use_local_privs=YES # NO时，虚拟用户和匿名用户有相同的权限，默认是NOpasv_min_port=10060         # 被动模式最小端口号10060pasv_max_port=10090         # 被动模式最大端口号10090accept_timeout=5connect_timeout=1</code></pre><h3 id="创建宿主用户"><a href="#创建宿主用户" class="headerlink" title="创建宿主用户"></a>创建宿主用户</h3><p>新建系统用户ftpuser，用户目录为<code>/home/vsftpd</code>, 用户登录终端设为/bin/false(即使之不能登录系统)</p><pre><code># 方法一# 创建用户 ftpuser 指定 `/home/vsftpd` 目录useradd -g root -M -d /home/vsftpd -s /sbin/nologin ftpuser# 设置用户 ftpuser 的密码passwd ftpuser# 把 /home/vsftpd 的所有权给ftpuser.rootchown -R ftpuser.root /home/vsftpd# 方法二useradd ftpuser -d /home/vsftpd -s /bin/falsechown ftpuser:ftpuser /home/vsftpd -R # 如果虚拟用户的宿主用户为www，需要这样设置# www目录是你应用的目录chown www:www /home/www -R</code></pre><p>删除用户 <code>userdel ftpuser</code></p><h3 id="建立虚拟用户文件"><a href="#建立虚拟用户文件" class="headerlink" title="建立虚拟用户文件"></a>建立虚拟用户文件</h3><pre><code>touch /etc/vsftpd/vuser_passwd# 编辑虚拟用户名单文件：（# 第一行账号，第二行密码，注意：不能使用root做用户名，系统保留）vi /etc/vsftpd/vuser_passwd # 编辑内容，下面是 vuser_passwd 内容wcj123456hss123456#保存退出</code></pre><h3 id="生成虚拟用户数据文件"><a href="#生成虚拟用户数据文件" class="headerlink" title="生成虚拟用户数据文件"></a>生成虚拟用户数据文件</h3><pre><code>db_load -T -t hash -f /etc/vsftpd/vuser_passwd /etc/vsftpd/vuser_passwd.dbchmod 600 /etc/vsftpd/vuser_passwd.db</code></pre><h3 id="创建用户配置"><a href="#创建用户配置" class="headerlink" title="创建用户配置"></a>创建用户配置</h3><pre><code>mkdir /etc/vsftpd/vuser_conf  # 建立虚拟用户个人vsftp的配置文件cd /etc/vsftpd/vuser_conf     # 进入目录touch hss wcj                 # 这里创建两个虚拟用户配置文件</code></pre><p>每一个文件配置文件都差不多，只是参数<code>local_root</code>不一样。</p><pre><code>local_root=/home/vsftpd/hss   # 用户 hss 配置目录，这个地方不一样write_enable=YES              # 允许本地用户对FTP服务器文件具有写权限anon_world_readable_only=NOanon_upload_enable=YES        # 允许匿名用户上传文件(须将全局的write_enable=YES,默认YES)anon_mkdir_write_enable=YES   # 允许匿名用户创建目录anon_other_write_enable=YES   # 允许匿名用户删除和重命名权限(自行添加)</code></pre><h3 id="创建用户目录"><a href="#创建用户目录" class="headerlink" title="创建用户目录"></a>创建用户目录</h3><p>每个用户目录文件夹是有root用户创建的，也就是上面<code>local_root</code>配置目录，其权限应设置为755。因为权限的问题在该文件夹内无法直接上传文件。而如果设置为777则无法访问，这是由于vsftpd的安全性设置。解决上传问题的方法是在local_root文件夹内新建一个upload的文件夹，权限设置为777，可将文件上传到该文件夹。</p><pre><code>mkdir -p /home/vsftpd/hss     # 每个用户对于一个目录，创建两个目录“hss”、“wcj”# 下面是目录结构/home/vsftpd      ├── hss      │   ├── filename.md      │   └── upload      └── wcj          └── filename.md# 赋予其权限chmod -R 777 /var/vsftpd/hss/upload/# 在/var/ftp下新建一个目录来实现匿名用户上传mkdir /var/ftp/upload</code></pre><p>vsftpd中几种用户的区分：</p><p><strong>本地用户</strong>：用户在FTP服务器拥有账号，且该账号为本地用户的账号，可以通过自己的账号和口令进行授权登录，登录目录为自己的home目录<code>$HOME</code><br><strong>虚拟用户</strong>：用户在FTP服务器上拥有账号，但该账号只能用于文件传输服务。登录目录为某一特定的目录，通常可以上传和下载<br><strong>匿名用户</strong>：用户在FTP服务器上没有账号，登录目录为/var/ftp</p><h3 id="最后重启vsftpd服务器"><a href="#最后重启vsftpd服务器" class="headerlink" title="最后重启vsftpd服务器"></a>最后重启vsftpd服务器</h3><pre><code>systemctl restart vsftpd.service</code></pre><h2 id="服务运维"><a href="#服务运维" class="headerlink" title="服务运维"></a>服务运维</h2><pre><code>systemctl restart vsftpd.service  # 重启服务systemctl start vsftpd.service    # 启动服务systemctl status vsftpd.service   # 服务状态查看</code></pre><h2 id="FTP命令"><a href="#FTP命令" class="headerlink" title="FTP命令"></a>FTP命令</h2><pre><code>ftp&gt; ascii  # 设定以ASCII方式传送文件(缺省值) ftp&gt; bell   # 每完成一次文件传送,报警提示. ftp&gt; binary # 设定以二进制方式传送文件. ftp&gt; bye    # 终止主机FTP进程,并退出FTP管理方式. ftp&gt; case # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. ftp&gt; cd     # 同UNIX的CD命令. ftp&gt; cdup   # 返回上一级目录. ftp&gt; chmod  # 改变远端主机的文件权限. ftp&gt; close  # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. ftp&gt; delete # 删除远端主机中的文件. ftp&gt; dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. ftp&gt; get [remote-file] [local-file] # 从远端主机中传送至本地主机中. ftp&gt; help [command] # 输出命令的解释. ftp&gt; lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. ftp&gt; ls [remote-directory] [local-file] # 同DIR. ftp&gt; macdef                 # 定义宏命令. ftp&gt; mdelete [remote-files] # 删除一批文件. ftp&gt; mget [remote-files]    # 从远端主机接收一批文件至本地主机. ftp&gt; mkdir directory-name   # 在远端主机中建立目录. ftp&gt; mput local-files # 将本地主机中一批文件传送至远端主机. ftp&gt; open host [port] # 重新建立一个新的连接. ftp&gt; prompt           # 交互提示模式. ftp&gt; put local-file [remote-file] # 将本地一个文件传送至远端主机中. ftp&gt; pwd  # 列出当前远端主机目录. ftp&gt; quit # 同BYE. ftp&gt; recv remote-file [local-file] # 同GET. ftp&gt; rename [from] [to]     # 改变远端主机中的文件名. ftp&gt; rmdir directory-name   # 删除远端主机中的目录. ftp&gt; send local-file [remote-file] # 同PUT. ftp&gt; status   # 显示当前FTP的状态. ftp&gt; system   # 显示远端主机系统类型. ftp&gt; user user-name [password] [account] # 重新以别的用户名登录远端主机. ftp&gt; ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。ftp&gt; ! # 从 ftp 子系统退出到外壳。 </code></pre><h3 id="关闭FTP连接"><a href="#关闭FTP连接" class="headerlink" title="关闭FTP连接"></a>关闭FTP连接</h3><pre><code>byeexitquit</code></pre><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><pre><code>ftp&gt; get readme.txt # 下载 readme.txt 文件ftp&gt; mget *.txt     # 下载 </code></pre><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><pre><code>ftp&gt; put /path/readme.txt # 上传 readme.txt 文件ftp&gt; mput *.txt           # 可以上传多个文件</code></pre><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul><li>230 - 登录成功</li><li>200 - 命令执行成功</li><li>150 - 文件状态正常，开启数据连接端口</li><li>250 - 目录切换操作完成</li><li>226 - 关闭数据连接端口，请求的文件操作成功</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://hx100.blog.51cto.com/44326/383143/" target="_blank" rel="noopener">Vsftpd虚拟用户的配置</a></li><li><a href="http://www.cnblogs.com/flandre/p/6051532.html" target="_blank" rel="noopener">CentOS7安装和配置FTP</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三十而立</title>
      <link href="/san-shi-er-li.html"/>
      <url>/san-shi-er-li.html</url>
      
        <content type="html"><![CDATA[<h1 id="三十而立"><a href="#三十而立" class="headerlink" title="三十而立"></a>三十而立</h1><p><img src="https://img.iamghf.top/91ef76c6a7efce1b6e9970cda251f3deb48f6503.jpg" alt=""></p><p>《论语·为政》中说：“三十而立。”指年至三十，学有成就。我从小读了很多书，但都是一些乱七八糟的书。后来上错了大学，耽误了学业，学术上没什么成绩，大部时间都用来思考宇宙和人生了。<br>三十岁对于一个男人来说是一个矛盾的年龄。三十岁的男人，才真正开始走向成熟、拥有担当能力的开端。<br>三十岁是人生的分界线。我出身平凡，努力改变命运，前二十年走过很多坑；三十岁的男人，应当有立锥之地。<br>三十多岁的男人，就象早秋午后太阳，即便过了正午时分，也不应有太多的倦意。<br>女人十八岁便开始成熟，而男人要到二十八岁才知道自己是怎么回事。<br>生命如此短暂，二十岁的男人还没有来得及享受生活，就要开始面对生活、社会、家庭和责任。<br>突然感觉有写点什么的必要，一来算是对青年时期的感悟总结；二来算是和年轻读者的谈心。<br>人生要远离“官场”。官场一个有原则无底线的是非场。年轻的时候总有人削尖脑袋想当官，成为“干部”。这些年接触了各种各样的“干部”，碰到了很多志大才疏，德不配位之人，让我对“官场”认识更加深刻。这是一个把君子变成小人的场所。我以后也会有儿子、孙子，我要告诉他们，一定不要有为了做官而做官的想法；要学会隐居，努力去做学问。对于张口“级别”、“待遇”、“工资”的这些人，要学会远离他们，最好拉黑。这些人无时无刻不在想着不劳而获，你跟他们混在一起，只会吃亏。<br>人生要远离“身份感”。年轻人最不该碰的东西，就是身份感和优越感。优越感，来自比较。内敛而不失度的优越，俗称自信。狂放而失礼的优越，俗称傲慢。天主教认定的遭永劫的七宗罪：傲慢，暴怒，懒惰，贪婪，嫉妒，饕餮，淫欲。排在首位的赫然便是傲慢，可见傲慢的杀伤力。当然，优越感源自优越，这点无可否认。但沉浸在优越中不可自拔，养成傲慢的脾气秉性，将导致固步自封、不思进取，既不被人待见，又坐吃山空。深到骨子里的高贵，是没有身份感。<br>人生始终要重视教育，要学会主动选择教育。当一个人出身贫困，没有平台和背景，教育是最好的投资。好的教育能唤醒人的意识，促进美德和智力的发展，差的教育喜欢“塑造”，强迫人去便成别人想要看到的样子。越是质量低劣的教育越喜欢“洗脑”。很多人无法意识到自己接受了什么样的教育，原因在于他们缺乏教育标准是非观，最终只能随波逐流。<br>人生要学会思考，认准自己的定位，远离口号。中国人二十岁之前都在考试，很少会去思考“我是谁？我为什么在这里”之类的问题。人类的痛苦往往来自于对自身认识不清的缘故。理想和现实产生了冲突，从而精神分类。因此，认准自己在社会中的位置非常重要，不要被口号欺骗和蒙蔽。<br>阅读是最好的教育。多阅读经典，多阅读原著。同样一本书，不同的人会有不同的感受，一定要先阅读原著，形成自己的认识，然后再去和别人交流，这样才能产生思想的碰撞，切不可人云亦云，失去自我。<br>清醒时做事，糊涂时读书。时时刻刻都要读书学习，你的知识面有多广，心怀有多宽，世界的舞台就有多大。<br>人生要有敬畏之心。曾经我也是那么叛逆，目无尊长、不拘约束，很多和我对抗过的故人至今还宣扬：你是降服不了他的。我们要对生命和规则充满敬畏之心，学会善良和尊重。<br>学会沉默，不要卖惨。不要报怨出身，不要埋怨现状。总有人家庭背景比你好，总有人生活条件比你差。人生来是为改变命运而努力的，一切的不如意都是为了让我们拼搏奋斗。<br>要懂得诚实，不要自欺欺人。很多时候，我们走错了路，做错了选择，都是因为自己骗自己。那个东西明明不好，却非要说服自己认为它是好的。所有错误的选择，大体如此。<br>要克制贪欲。我们本来就是赤条条来到世间的，一切都是身外之物，对物质的过分追求会失去自我。<br>要学会慎独。在很多孤独、自我相处的时间里，放松不放纵，做让自己欣赏的自己。总有一天你会明白，孤独才是人生的常态。<br>要有规则意识，不要道德绑架。文明社会是讲规则的社会，言谈举止一定要尊重社会规则。道德是规则的升华，自古以来道德是强调约束自己的，而今天很多人却用道德去要求别人，这就是道德绑架。<br>要认清君子和小人。看清一个人的嘴脸，看他对领导的态度；看清一个人的品性，看他如何对待弱者；看清一人的将来，看他在在读什么样的书。<br>不要滥交朋友。人生得一知已足亦，很多人注定是我们生命中的过客，不要太热情，不要太冷漠，平平淡淡的交往就好。<br>人生要有一个正直的朋友。有个正直的朋友是痛苦的，他总会盯着你的缺点；有了正直的朋友是幸福的，你的人生不会犯大错。<br>要远离疯狗杠精。流言蜚语总会围绕在我们周围，甚至威胁我们的名誉。不要企图和疯狗争论是非。如果辱骂能够胜利，泼妇将统治世界，流言总会消失，清白总是沉淀而出。总有人喜欢你，总有人不喜欢你，你只需要在乎喜欢你的人便可。<br>要远离脑残智障。太监脱掉裤子才知道不是正常人，脑残一张嘴就知道不是正常人。太监因残疾而自卑，脑残因无知而狂妄。一个人获得信息来源的途径决定认识水平，接受单一教育的人看问题容易偏激。批判是创新的前提，要远离那些满嘴赞美权力、习惯歌功颂德之流，奴颜婢膝之徒是不配做我们的朋友的。<br>不要轻视人性之恶。人是一种喜欢在欺负弱小中得到快感的动物，敢于挑战强者的只是极少数，孤傲而高贵。人在利益和原则之间是很容易犯错的，要时时提防可能来临的伤害，保全自我是人生的必修课。<br>与贵族为友，与流氓共事。项羽是贵族，刘邦是流氓，贵族斗不过流氓。做人与做事是人生两门功课，外圆内方，把贵族当作朋友，把流氓当作同事。<br>要学会和异性正常交往。异性地球上唯一的另类智能生物。和异性交往，充满了人类智慧当中最高的技巧和情商。不要去做女性的舔狗，喜欢被男性跪舔的女性是不值得交往的。<br>要多思考家庭、婚姻和两性关系。人生可以没有婚姻，但是要有一段付出真心的爱情；人生可以没有伴侣，一定要有一个红颜知已，彼此都记在心间，可以相互付出所有。<br>要学会在市场中赚钱养活自己。作为一个男人，没有赚钱的能力，是万万不行的。人口越来越老化，平均每个中国男人的身上，都有七八口人要养活。如果你不幸是体制内人员，只能靠工资活着，家里又没有背景和财富，那还是请多考虑“赚钱”的问题。<br>学会孝敬父母。父母是我们的心灵归宿，父母在，我们永远是孩子，受了委屈或得到荣耀，可以回家，总感觉生死离我们很远；父母不在了，我们开始直接面对生死。<br>要同情弱势群体，不要轻易可怜他人。社会公平总有顾及不到的地方，弱势群体更需要同情和关爱，要有区别的对待个体可怜之人，可怜之人必有可恨之处，理智不能被同情控制。<br>要永远相信公平正义。无论位居多高，掌握多少财富，都要和普通百姓站在一起，不要为权势们锦上添花，要为天下百姓说话，只要和百姓在一起，人生就不会偏离方向。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库表连接</title>
      <link href="/shu-ju-ku-biao-lian-jie.html"/>
      <url>/shu-ju-ku-biao-lian-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库表连接"><a href="#数据库表连接" class="headerlink" title="数据库表连接"></a>数据库表连接</h1><p>关系型数据库最难的地方，就是建模（model）。</p><p>错综复杂的数据，需要建立模型，才能储存在数据库。所谓”模型”就是两样东西：实体（entity）+ 关系（relationship）。</p><p>实体指的是那些实际的对象，带有自己的属性，可以理解成一组相关属性的容器。关系就是实体之间的联系，通常可以分成”一对一”、”一对多”和”多对多”等类型。</p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo3-1552277828.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p>在关系型数据库里面，每个实体有自己的一张表（table），所有属性都是这张表的字段（field），表与表之间根据关联字段”连接”（join）在一起。所以，表的连接是关系型数据库的核心问题。</p><p>表的连接分成好几种类型。</p><blockquote><ul><li>内连接（inner join）</li><li>外连接（outer join）</li><li>左连接（left join）</li><li>右连接（right join）</li><li>全连接（full join）</li></ul></blockquote><p>以前，很多文章采用维恩图（两个圆的集合运算），解释不同连接的差异。</p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo2-1552277828.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo2-1552277828-1.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo0-1552277828.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo1-1552277829.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p>上周，我读到一篇文章，认为还有比维恩图更好的解释方式。我发现确实如此，换一个角度解释，更容易懂。</p><p>所谓”连接”，就是两张表根据关联字段，组合成一个数据集。问题是，两张表的关联字段的值往往是不一致的，如果关联字段不匹配，怎么处理？比如，表 A 包含张三和李四，表 B 包含李四和王五，匹配的只有李四这一条记录。</p><p>很容易看出，一共有四种处理方法。</p><blockquote><ul><li>只返回两张表匹配的记录，这叫内连接（inner join）。</li><li>返回匹配的记录，以及表 A 多余的记录，这叫左连接（left join）。</li><li>返回匹配的记录，以及表 B 多余的记录，这叫右连接（right join）。</li><li>返回匹配的记录，以及表 A 和表 B 各自的多余记录，这叫全连接（full join）。</li></ul></blockquote><p>下图就是四种连接的图示。我觉得，这张图比维恩图更易懂，也更准确。</p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo1-1552277829.jpeg" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p><p>上图中，表 A 的记录是 123，表 B 的记录是 ABC，颜色表示匹配关系。返回结果中，如果另一张表没有匹配的记录，则用 null 填充。</p><p>这四种连接，又可以分成两大类：内连接（inner join）表示只包含匹配的记录，外连接（outer join）表示还包含不匹配的记录。所以，左连接、右连接、全连接都属于外连接。</p><p>这四种连接的 SQL 语句如下。</p><pre><code>SELECT * FROM A  INNER JOIN B ON A.book_id=B.book_id;</code></pre><p>SELECT * FROM A<br>LEFT JOIN B ON A.book_id=B.book_id;</p><pre><code></code></pre><p>SELECT * FROM A<br>RIGHT JOIN B ON A.book_id=B.book_id;</p><pre><code></code></pre><p>SELECT * FROM A<br>FULL JOIN B ON A.book_id=B.book_id;</p><pre><code></code></pre><p>上面的 SQL 语句还可以加上where条件从句，对记录进行筛选，比如只返回表 A 里面不匹配表 B 的记录。</p><pre><code>SELECT * FROM ALEFT JOIN BON A.book_id=B.book_idWHERE B.id IS null;</code></pre><p>另一个例子，返回表 A 或表 B 所有不匹配的记录。</p><pre><code>SELECT * FROM AFULL JOIN BON A.book_id=B.book_idWHERE A.id IS null OR B.id IS null;</code></pre><p>此外，还存在一种特殊的连接，叫做”交叉连接”（cross join），指的是表 A 和表 B 不存在关联字段，这时表 A（共有 n 条记录）与表 B （共有 m 条记录）连接后，会产生一张包含 n x m 条记录的新表（见下图）。</p><p><img src="https://www.i5seo.com/wp-content/uploads/2019/03/seo10-1552277829.png" alt="数据库表连接的简单解释 | 图文并茂，通俗易懂"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大基础实用算法</title>
      <link href="/shi-da-ji-chu-shi-yong-suan-fa.html"/>
      <url>/shi-da-ji-chu-shi-yong-suan-fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="十大基础实用算法"><a href="#十大基础实用算法" class="headerlink" title="十大基础实用算法"></a>十大基础实用算法</h1><p><strong>算法一：快速排序算法</strong></p><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(nlogn) 次比较。在最坏状况下则需要Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(nlogn) 算法更快，因为它的内部循环（innerloop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divideandconquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p><strong>算法步骤：</strong></p><p>\1. 从数列中挑出一个元素，称为「基准」（pivot），</p><p>\2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p><p>\3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><strong>算法二：堆排序算法</strong></p><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>堆排序的平均时间复杂度为Ο(nlogn)。</p><p><strong>算法步骤：</strong></p><p>\1. 创建一个堆 H[0..n-1]</p><p>\2. 把堆首（最大值）和堆尾互换</p><p>\3. 把堆的尺寸缩小 1，并调用 shift_down(0), 目的是把新的数组顶端数据调整到相应位置</p><p>\4. 重复步骤 2，直到堆的尺寸为 1</p><p><strong>算法三：归并排序</strong></p><p>归并排序（Mergesort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（DivideandConquer）的一个非常典型的应用。</p><p><strong>算法步骤：</strong></p><p>\1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p><p>\2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置</p><p>\3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p><p>\4. 重复步骤 3 直到某一指针达到序列尾</p><p>\5. 将另一序列剩下的所有元素直接复制到合并序列尾</p><p><strong>算法四：二分查找算法</strong></p><p>二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn)。</p><p><strong>算法五：BFPRT（线性查找算法）</strong></p><p>BFPRT 算法解决的问题十分经典，即从某 n 个元素的序列中选出第 k 大（第 k 小）的元素，通过巧妙的分析，BFPRT 可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到 o(n) 的时间复杂度，五位算法作者做了精妙的处理。</p><p><strong>算法步骤：</strong></p><p>\1. 将 n 个元素每 5 个一组，分成 n/5(上界) 组。</p><p>\2. 取出每一组的中位数，任意排序方法，比如插入排序。</p><p>\3. 递归的调用 selection 算法查找上一步中所有中位数的中位数，设为 x，偶数个中位数的情况下设定为选取中间小的一个。</p><p>\4. 用 x 来分割数组，设小于等于 x 的个数为 k，大于 x 的个数即为 n-k。</p><p>\5. 若 i==k，返回 x；若 i&lt;k，在小于 x 的元素中递归查找第 i 小的元素；若 i&gt;k，在大于 x 的元素中递归查找第 i-k 小的元素。</p><p>终止条件：n=1 时，返回的即是 i 小元素。</p><p><strong>算法六：DFS（深度优先搜索）</strong></p><p>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所有边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS 属于盲目搜索。</p><p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现 DFS 算法。</p><p><strong>深度优先遍历图算法步骤：</strong></p><p>\1. 访问顶点 v；</p><p>\2. 依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问；</p><p>\3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</p><p>上述描述可能比较抽象，举个实例：</p><p>DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1 邻接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，…如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。</p><p>接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</p><p><strong>算法七：BFS（广度优先搜索）</strong></p><p>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树 (图) 的宽度遍历树 (图) 的节点。如果所有节点均被访问，则算法中止。BFS 同样属于盲目搜索。一般用队列数据结构来辅助实现 BFS 算法。</p><p><strong>算法步骤：</strong></p><p>\1. 首先将根节点放入队列中。</p><p>\2. 从队列中取出第一个节点，并检验它是否为目标。</p><p>如果找到目标，则结束搜寻并回传结果。</p><p>否则将它所有尚未检验过的直接子节点加入队列中。</p><p>\3. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传「找不到目标」。</p><p>\4. 重复步骤 2。</p><p><strong>算法八：Dijkstra算法</strong></p><p>戴克斯特拉算法（Dijkstra』salgorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p><p>该算法的输入包含了一个有权重的有向图 G，以及 G 中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u,v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示 G 中所有边的集合，而边的权重则由权重函数 w:E→[0,∞] 定义。因此，w(u,v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t 的最低权重路径 (例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra 算法是目前已知的最快的单源最短路径算法。</p><p><strong>算法步骤：</strong></p><p>\1. 初始时令 S={V0},T={其余顶点}，T 中顶点对应的距离值</p><p>若存在，d(V0,Vi) 为弧上的权值</p><p>若不存在，d(V0,Vi) 为∞</p><p>\2. 从 T 中选取一个其距离值为最小的顶点 W 且不在 S 中，加入 S</p><p>\3. 对其余 T 中顶点的距离值进行修改：若加进 W 作中间顶点，从 V0 到 Vi 的距离值缩短，则修改此距离值</p><p>重复上述步骤 2、3，直到 S 中包含所有顶点，即 W=Vi 为止</p><p><strong>算法九：动态规划算法</strong></p><p>动态规划（Dynamicprogramming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><p>关于动态规划最经典的问题当属背包问题。</p><p><strong>算法步骤：</strong></p><p>\1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p><p>\2. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p><p><strong>算法十：朴素贝叶斯分类算法</strong></p><p>朴素贝叶斯分类算法是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下，如何完成推理和决策任务。概率推理是与确定性推理相对应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其他特征都不相关。</p><p>朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获取得非常好的分类效果。在许多实际应用中，朴素贝叶斯模型参数估计使用最大似然估计方法，换言之朴素贝叶斯模型能工作并没有用到贝叶斯概率或者任何贝叶斯模型。</p><p>尽管是带着这些朴素思想和过于简单化的假设，但朴素贝叶斯分类器在很多复杂的现实情形中仍能够取得相当好的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生苦短，我用PyCharm</title>
      <link href="/ren-sheng-ku-duan-wo-yong-pycharm.html"/>
      <url>/ren-sheng-ku-duan-wo-yong-pycharm.html</url>
      
        <content type="html"><![CDATA[<h1 id="人生苦短，我用PyCharm"><a href="#人生苦短，我用PyCharm" class="headerlink" title="人生苦短，我用PyCharm"></a>人生苦短，我用PyCharm</h1><p>导读：PyCharm 是一种 Python IDE，可以帮助程序员节约时间，提高生产效率。那么具体如何使用呢？本文从 PyCharm 安装到插件、外部工具、专业版功能等进行了一一介绍，希望能够帮助到大家。</p><p>在本文中，我们并不会提供非常完善的指南，但是会介绍 PyCharm 最主要的一些能力，了解这些后，后面就需要我们在实践中再具体学习了。</p><p>JetBrains 开发的 PyCharm 差不多是 Python 最常用的 IDE。PyCharm 可以为我们节省大量时间，它能够管理代码，并完成大量其他任务，如 debug 和可视化等。</p><p>本文将介绍：</p><ul><li>PyCharm 安装</li><li>在 PyCharm 中写代码</li><li>在 PyCharm 中运行代码</li><li>在 PyCharm 中进行代码 debug 和测试</li><li>在 PyCharm 中编辑已有项目</li><li>在 PyCharm 中搜索和导航</li><li>在 PyCharm 中使用版本控制</li><li>在 PyCharm 中使用插件和外部工具</li><li>使用 PyCharm Professional 功能，如 Django 支持和科学模式</li></ul><p>本文假设读者熟悉 Python 开发，且计算机中已安装某个版本的 Python。该教程将使用 Python 3.6 版本，屏幕截图和 demo 均来自 macOS 系统。由于 PyCharm 可在所有主流平台上运行，读者在其他系统中会看到略微不同的 UI 元素，可能需要调整某些命令。</p><h3 id="01、PyCharm-安装"><a href="#01、PyCharm-安装" class="headerlink" title="01、PyCharm 安装"></a>01、PyCharm 安装</h3><p>本文将使用 PyCharm Community Edition 2019.1 版本，该版本免费且可在所有主流平台上使用。只有最后一部分「PyCharm Professional 功能」使用的是 PyCharm Professional Edition 2019.1 版本。</p><p>推荐使用 JetBrains Toolbox App 安装 PyCharm。使用该 App，你可以安装不同的 JetBrains 产品或者同一产品的不同版本，并在必要的情况下更新、回滚和轻松删除任意工具。你还可以在恰当的 IDE 及版本中快速打开任意项目。</p><p>Toolbox App 安装指南，参见 JetBrains 官方文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/installation-guide.html#toolbox" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/installation-guide.html#toolbox</a></p><p>该 App 会根据你的操作系统提供合适的安装说明。如果它无法准确识别系统，你可以在右上角的下拉列表中找到合适的系统。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092628.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>安装成功后，启动该 app 并接受用户协议。在 Tools 选项下，你可以看到一个可用产品列表。从中找到 PyCharm Community，并点击 Install。</p><p>好啦，现在你的机器上已经安装 PyCharm 了。如果不想使用 Toolbox app，你可以单独安装 PyCharm。</p><p>启动 PyCharm，你将看到导入设置弹窗。PyCharm 会自动检测出这是首次安装，并为你选择「Do not import settings」选项。点击 OK，之后 PyCharm 会让你选择键盘映射（keymap scheme）。保留默认设置，点击右下角的「Next: UI Themes」：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092637.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>PyCharm 将询问选择深色模式 Darcula 还是浅色模式。你可以选择自己喜欢的模式，并点击「Next: Launcher Script」：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092643.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>本教程将使用深色模式 Darcula。</p><p>在下一个页面上，直接保留默认设置，并点击「Next: Featured plugins」，这时 PyCharm 将展示可用插件列表。点击「Start using PyCharm」，现在你可以写代码了！</p><h3 id="02、在-PyCharm-中写代码"><a href="#02、在-PyCharm-中写代码" class="headerlink" title="02、在 PyCharm 中写代码"></a>02、在 PyCharm 中写代码</h3><p>在 PyCharm 中，你可以在「项目」中执行任意操作。因此，首先你需要创建一个项目。</p><p>安装和打开 PyCharm 后，你会看到欢迎页面。点击「Create New Project」，出现「New Project」弹窗：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092649.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>指定项目位置，打开 Project Interpreter 列表，选择创建新的项目解释器或者使用已有的解释器。选择「New environment using」，打开其右方的下拉列表，选择 Virtualenv、Pipenv 或 Conda。这些工具可以为不同项目单独创建 Python 环境，从而分别保存不同项目所需的依赖项。</p><p>你可以选择其中任意一个，本教程使用的是 Virtualenv。选择后，指定环境位置，从 Python 解释器列表中选择要安装在系统中的 base interpreter。通常，保持默认设置即可。下面有两个可选框：在新环境中继承全局包环境、令当前环境可以用其它所有项目，两个都不要选。</p><p>点击右下角的「Create」，创建新项目：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092655.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>屏幕上出现「Tip of the Day」弹窗，在每次启动时 PyCharm 通过该弹窗提供 trick。关掉该弹窗。</p><p>现在我们可以开始新的 Python 程序了。如果你使用的是 Mac 系统，使用 Cmd+N 键；如果你使用的是 Windows 或 Linux 系统，使用 Alt+Ins 键。然后选择 Python File。你也可以在菜单中选择 File → New。将新文件命名为 guess_game.py 并点击 OK。你将看到如下 PyCharm 窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092701.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>至于测试代码，我们来快速写一个简单的猜谜游戏，即程序选择一个数字让用户来猜，在每一次猜测时，程序将告诉用户他猜的数字比神秘数字大还是小，用户猜中数字时游戏结束。以下是该游戏的代码：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092707.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>直接键入上述代码，而不是复制粘贴。你会看到如下画面：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092714.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>如上图所示，PyCharm 提供 Intelligent Coding Assistance 功能，可以执行代码补全、代码检查、错误高亮显示和快速修复建议。比如键入 main 并点击 tab 键，PyCharm 会自动补全整个 main 从句。</p><p>此外，如果你在条件句前忘记键入 if，在该句子最后增添.if 并点击 Tab 键，PyCharm 将修复该 if 条件句。该用法同样适用于 True.while。这即是 PyCharm 的 Postfix Completion 功能，它可以帮助用户减少退格键使用次数。</p><h3 id="03、在-PyCharm-中运行代码"><a href="#03、在-PyCharm-中运行代码" class="headerlink" title="03、在 PyCharm 中运行代码"></a>03、在 PyCharm 中运行代码</h3><p>现在你已经编码完成该游戏，可以运行了。</p><p>该游戏程序有三种运行方式：</p><ol><li>在 Mac 系统中使用快捷键 Ctrl+Shift+R，在 Windows 或 Linux 系统中，使用快捷键 Ctrl+Shift+F10。</li><li>右键单击背景，从菜单中选择「Run 『guess_game』」。</li><li>由于该程序具备<strong>main</strong> 从句，你可以点击<strong>main</strong> 从句左侧的绿色小箭头，选择「Run 『guess_game』」。</li></ol><p>使用以上任一方式运行该程序，窗口底部会出现终端面板（Terminal pane），显示你的代码输出结果：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092720.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>你可以玩一下这个游戏，看看自己能否猜中数字。（专业建议：从 50 开始猜。）</p><h3 id="04、在-PyCharm-中进行代码-debug"><a href="#04、在-PyCharm-中进行代码-debug" class="headerlink" title="04、在 PyCharm 中进行代码 debug"></a>04、在 PyCharm 中进行代码 debug</h3><p>找到神秘数字了吗？如果找到了，你可能会看到一些奇怪的东西：程序没有打印出祝贺信息和显示退出按钮，而是重新开始了。这就是 bug 所在。要想发现程序重新开始的原因，你需要 debug。</p><p>首先，点击第 8 行代码左侧的空白区域，设置断点：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092725.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>断点即程序运行到这一行时会自动停止，你可以探索断点处之后的代码有什么错误。接下来，从以下三种方式中选择一种开始 debug：</p><ol><li>在 Mac 系统中使用 Ctrl+Shift+D 键，在 Windows 或 Linux 系统中使用 Shift+Alt+F9 键。</li><li>右键单击背景，选择「Debug 『guess_game』」。</li><li>点击<strong>main</strong>从句左侧的绿色小箭头，选择「Debug 『guess_game』」。</li></ol><p>之后，你将看到底部出现 Debug 窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092732.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>按照下列步骤执行程序 debug：</p><ol><li>注意当前行被蓝色高亮显示。</li><li>Debug 窗口显示 random_int 及其值。记录该数字。（上图中该数字为 85。）</li><li>点击 F8 执行当前代码行，并执行到下一行代码。如有必要，你也可以使用 F7 跳转到当前行内的函数。随着你继续执行语句，变量的变化将自动呈现在 Debugger 窗口。</li><li>注意 Debugger 标签右侧有一个 Console 标签。Console 标签和 Debugger 标签相互独立。你可以在 Console 中与程序进行交互，在 Debugger 中执行 debug 动作。</li><li>转向 Console 标签，进入猜测过程。</li><li>键入左侧 Debugger 标签中显示的数字，点击 Enter 键。</li><li>转回 Debugger 标签。</li><li>再次点击 F8，计算 if 语句。注意现在你在第 14 行。为什么不是第 11 行呢？因为第 10 行的 if 语句被计算为 False。那么为什么当你键入数字后它算出来为 False 了呢？</li><li>仔细看第 10 行，注意我们在对比 user_guess 和一个错误的项。我们应该对比用户猜测的数字和 random_int，但此处我们对比的是 randint（从 random 包导入的函数）。</li><li>将 randint 更改为 random_int，按照同样的步骤重新开始 debug。你会发现，这一次到达的是第 11 行，第 10 行算出来为 True：</li></ol><p><img src="https://img.iamghf.top/blog/2019-12-26-092737.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>恭喜你，bug 被修复了！</p><h3 id="05、在-PyCharm-中进行代码测试"><a href="#05、在-PyCharm-中进行代码测试" class="headerlink" title="05、在 PyCharm 中进行代码测试"></a>05、在 PyCharm 中进行代码测试</h3><p>不经单元测试的应用都不可靠。PyCharm 可以帮助你快速舒适地写单元测试并运行。默认情况下，unittest 被用作测试运行器，而 PyCharm 还支持其他测试框架，如 pytest、nose、doctest、tox 和 trial。例如，你可以按照以下步骤为项目选择 pytest 测试运行器：</p><ol><li>打开 Settings/Preferences → Tools → Python Integrated Tools 设置对话框。</li><li>在默认测试运行器字段中选择 pytest。</li><li>点击 OK 保存该设置。</li></ol><p>本教程的示例将使用默认测试运行器 unittest。</p><p>在同一个项目中，创建文件 calculator.py，并将以下 Calculator 类放入该文件：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092743.png" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>PyCharm 使得为已有代码创建测试变得轻而易举。打开 calculator.py 文件，执行以下步骤中的任意一个：</p><ul><li>在 Mac 系统中使用 Shift+Cmd+T 键，在 Windows 或 Linux 系统中使用 Ctrl+Shift+T。</li><li>右键单击该类的背景，选择「Go To and Test」。</li><li>在主菜单中吗，选择 Navigate → Test。</li></ul><p>选择「Create New Test…」，得到以下窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092748.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>Target directory、Test file name 和 Test class name 这三项均保留默认设置。选中上图中两种需要测试的方法并点击 OK。好了！PyCharm 自动创建文件 test_calculator.py，并在其中创建了以下 stub test：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092753.png" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>使用以下方法中的任意一个运行测试：</p><ul><li>在 Mac 系统中使用 Ctrl+R 键，在 Windows 或 Linux 系统中使用 Shift+F10 键。</li><li>右键单击背景，选择「Run 『Unittests for test_calculator.py』」。</li><li>点击测试类名称左侧的绿色小箭头，选择「Run 『Unittests for test_calculator.py』」。</li></ul><p>你将看到底部出现测试窗口，所有测试均失败：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092801.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>注意，左侧是测试结果的层次结构，右侧是终端的输出。现在，将代码更改成以下代码，实现 test_add：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092806.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>重新运行测试，你会看到一个测试通过了，另一个则失败。按照如下操作探索不同选项，来展示已通过测试和被忽略测试，按照字母顺序对测试进行排序，以及按照时长对测试进行排序：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092811.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>注意，上图中的 sleep(0.1) 方法的作用是使其中一个测试变慢，以便按时长对测试进行排序。</p><h3 id="06、在-PyCharm-中编辑已有项目"><a href="#06、在-PyCharm-中编辑已有项目" class="headerlink" title="06、在 PyCharm 中编辑已有项目"></a>06、在 PyCharm 中编辑已有项目</h3><p>单文件项目非常适合作为示例，但你通常需要处理较大的项目。这部分将介绍如何使用 PyCharm 处理较大项目。</p><p>为了探索 PyCharm 以项目为中心的特征，你将使用 Alcazar web 框架（该框架用于学习目的）。在本地复制该 repo。</p><p>地址：</p><p><a href="https://realpython.com/optins/view/alcazar-web-framework/" target="_blank" rel="noopener">https://realpython.com/optins/view/alcazar-web-framework/</a></p><p>当你在本地已有项目时，使用以下方法中的任意一个在 PyCharm 中打开项目：</p><ul><li>在主菜单中点击 File → Open。</li><li>在欢迎页面点击 Open。</li></ul><p>之后，在计算机中找到包含该项目的文件夹，并打开。</p><p>如果该项目包含虚拟环境，PyCharm 将自动使用该虚拟环境，并将它作为项目解释器。</p><p>如果你需要配置不同的虚拟环境 virtualenv，在 Mac 上打开 Preferences，或在 Windows 或 Linux 系统中使用 Ctrl+Alt+S 打开 Settings，找到 Project: ProjectName。打开下拉列表，选择 Project Interpreter：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092818.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>从下拉列表中选择 virtualenv。如果没有要选择的项，则点击下拉列表右方的设置按钮选择 Add…其余步骤和创建新项目的步骤相同。</p><h3 id="07、在-PyCharm-中搜索和导航"><a href="#07、在-PyCharm-中搜索和导航" class="headerlink" title="07、在 PyCharm 中搜索和导航"></a>07、在 PyCharm 中搜索和导航</h3><p>在大项目中，我们很难记住每个事物的位置，因此快速导航和搜索非常重要。PyCharm 可以提供这些功能。接下来，我们使用上一节中打开的项目，实践以下快捷键：</p><ul><li>在当前文件中搜索代码段：在 Mac 系统中使用 Cmd+F 键，在 Windows 或 Linux 系统中使用 Ctrl+F 键。</li><li>在整个项目中搜索代码段：在 Mac 系统中使用 Cmd+Shift+F 键，在 Windows 或 Linux 系统中使用 Ctrl+Shift+F 键。</li><li>搜索类：在 Mac 系统中使用 Cmd+O 键，在 Windows 或 Linux 系统中使用 Ctrl+N 键。</li><li>搜索文件：在 Mac 系统中使用 Cmd+Shift+O 键，在 Windows 或 Linux 系统中使用 Ctrl+Shift+N 键。</li><li>如果你不知道要搜索的是文件、类还是代码段，则搜索全部：按两次 Shift 键。</li></ul><p>导航可使用以下快捷键：</p><ul><li>前往变量的声明：在 Mac 系统中使用 Cmd 键，在 Windows 或 Linux 系统中使用 Ctrl 键，然后单击变量。</li><li>寻找类、方法或文件的用法：使用 Alt+F7 键。</li><li>查看近期更改：使用 Shift+Alt+C 键，或者在主菜单中点击 View → Recent Changes。</li><li>查看近期文件：在 Mac 系统中使用 Cmd+E 键，在 Windows 或 Linux 系统中使用 Ctrl+E 键，或者在主菜单中点击 View → Recent Files。</li><li>多次跳转后在导航历史中前进和后退：在 Mac 系统中使用 Cmd+[ / Cmd+] 键，在 Windows 或 Linux 系统中使用 Ctrl+Alt+Left / Ctrl+Alt+Right 键。</li></ul><p>更多细节，参见官方文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/tutorial-exploring-navigation-and-search.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/tutorial-exploring-navigation-and-search.html</a></p><h3 id="08、PyCharm-中的版本控制"><a href="#08、PyCharm-中的版本控制" class="headerlink" title="08、PyCharm 中的版本控制"></a>08、PyCharm 中的版本控制</h3><p>版本控制系统（如 Git 和 Mercurial）是现代软件开发世界中最重要的工具之一。因此，IDE 必须支持版本控制。PyCharm 在这方面做得很好，它集成了大量流行的版本控制系统，如 Git（和 Github (<a href="https://github.com/)）、Mercurial、Perforce" target="_blank" rel="noopener">https://github.com/)）、Mercurial、Perforce</a> 和 Subversion。</p><p>注：以下示例中使用的版本控制系统为 Git。</p><h4 id="1-配置版本控制系统（VCS）"><a href="#1-配置版本控制系统（VCS）" class="headerlink" title="1. 配置版本控制系统（VCS）"></a>1. 配置版本控制系统（VCS）</h4><p>要想实现 VCS 集成，你需要在顶部菜单点击 VCS → VCS Operations Popup…，或者在 Mac 系统中使用 Ctrl+V 键，在 Windows 或 Linux 系统中使用 Alt+` 键。选择 Enable Version Control Integration…，你将看到以下窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092827.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>从下拉列表中选择 Git，点击 OK，这样你就为项目设置好了 VCS。（注意，如果你打开的已有项目已经具备版本控制系统，PyCharm 将会发现并自动使用该版本控制系统。）</p><p>这时如果你前往 VCS Operations Popup…，你会发现一个不同的弹窗，它具备选项 git add、git stash、git branch、git commit、git push 等等：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092834.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>如果你找不到所需要的选项，你可以在顶部菜单中点击 VCS，选择 Git，在这里你可以创建和查看 pull request。</p><h4 id="2-提交和冲突处理"><a href="#2-提交和冲突处理" class="headerlink" title="2. 提交和冲突处理"></a>2. 提交和冲突处理</h4><p>这是 PyCharm 中 VCS 集成的两大特征，我个人经常使用并且非常喜欢。假如你完成了工作，打算提交，前往 VCS → VCS Operations Popup… → Commit…，或者在 Mac 系统中使用 Cmd+K 键，在 Windows 或 Linux 系统中使用 Ctrl+K 键。你将看到如下窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092840.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>在该窗口中，你可以：</p><ul><li>选择要提交的文件</li><li>写下提交信息</li><li>在提交前执行各项检查</li><li>查看更改</li><li>点击右下角 Commit 按钮旁边的箭头，选择 Commit and Push…，从而一次性完成提交和 push</li></ul><p>是不是感觉很神奇很迅速？特别是如果你以前经常通过命令行手动执行这些任务时。</p><p>团队合作中会出现合并冲突（merge conflict）。当一个人对你正在处理的文件提交更改时，你们二人更改了同一行导致更改重叠，这时 VCS 无法决定选择你的更改还是队友的更改。那么你可以使用以下箭头和符号来解决这个问题：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092846.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>看起来很奇怪，我们很难分辨应该删除哪些更改、保留哪些更改。不要怕，PyCharm 来了！它可以用更好、更简洁的方法解决冲突。在顶部菜单中前往 VCS，选择 Git，然后选择 Resolve conflicts…。选择存在冲突的文件，点击 Merge，出现以下窗口：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092852.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>在左侧列中，你可以查看自己做的更改。在右侧列中，可以查看队友做的更改。而中间列则显示结果。存在冲突的代码行被高亮显示，你可以在它们旁边看到 X 和 &gt;&gt;/&lt;&lt;。点击箭头表示接受更改，点击 X 则表示拒绝更改。解决所有冲突后，点击 Apply 按钮：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092858.gif" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>在上图中，对于第一个冲突行，作者选择拒绝自己的更改，接受队友的更改。而在第二个冲突行中，作者接受了自己的更改，拒绝了队友的更改。</p><p>使用 PyCharm 中的 VCS 集成还可以执行很多操作。详情参见：</p><p><a href="https://www.jetbrains.com/help/pycharm/version-control-integration.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/version-control-integration.html</a></p><h3 id="09、在-PyCharm-中使用插件和外部工具"><a href="#09、在-PyCharm-中使用插件和外部工具" class="headerlink" title="09、在 PyCharm 中使用插件和外部工具"></a>09、在 PyCharm 中使用插件和外部工具</h3><p>在 PyCharm 中你可以找到开发所需的几乎所有功能。如果没找到，那么很可能存在一个插件，向 PyCharm 提供你需要的功能。例如，它们可以：</p><ul><li>添加多语言和多框架支持</li><li>使用快捷键提示（shortcut hint）、文件监视器（file watcher）等提升你的生产效率</li><li>利用代码练习，帮助你学习新的编程语言</li></ul><p>例如，IdeaVim 插件向 PyCharm 添加 Vim 模拟。如果你喜欢 Vim，这个插件可以实现不错的结合。</p><p>Material Theme UI 插件可将 PyCharm 的外观改变为 Material Design 的外观：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092904.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>Vue.js 插件使 PyCharm 支持 Vue.js 项目。Markdown 插件使得在 IDE 内可以编辑 Markdown 文件，并实时预览渲染后的 HTML。</p><p>在 Mac 系统上点击 Preferences → Plugins，在 Windows 或 Linux 系统中点击 Settings → Plugins，你可以在 Marketplace 标签下找到和安装所有可用插件：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092910.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>如果仍然没找到所需插件，你甚至可以自己开发一个。</p><p>如果你找不到合适的插件，又不想自己开发，因为 PyPI 上有可用的包，你可以将这个包作为外部工具添加到 PyCharm。以代码分析器 Flake8 为例。</p><p>首先，在所选 Terminal app 中键入 pip install flake8，从而在虚拟环境中安装 Flake8。或者也可以使用 PyCharm 集成的 Terminal：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092916.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>在 Mac 系统上点击 Preferences → Tools，在 Windows 或 Linux 系统中点击 Settings → Tools，选择 External Tools。然后点击底部 (1) 处的 + 按钮。在弹出的窗口中，输入细节并在两个窗口中点击 OK，如下图所示：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092923.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>上图中，Program (2) 指 Flake8，你可以在虚拟环境文件夹（bin）中找到它。Arguments (3) 表示你想用 Flake8 分析的文件。Working directory 表示项目目录。</p><p>你可以把这里所有项的绝对路径写死，但这就意味着你无法在其他项目中使用该外部工具，只能在一个项目中针对一个文件使用该工具。</p><p>因此你需要使用 Macros。它是$name$格式的变量，根据语境而变化。例如，当你编辑 first.py 时，$FileName$ 为 first.py，当你编辑 second.py 时，$FileName$ 为 second.py。你可以查看它们的列表，点击 Insert Macro… 按钮将其中一个插入。此处你使用了 macros，它们的值会根据你目前处理的项目而改变，Flake8 将继续准确执行其工作。</p><p>要想使用它，你需要创建文件 example.py，并在其中写入以下代码：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092928.png" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>上述代码故意破坏了 Flake8 的一些规则。右键单击文件背景，选择 External Tools → Flake8。Flake8 分析结果将出现在窗口底部：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-092933.jpg" alt="Python最强IDE详细使用指南：人生苦短，我用PyCharm"></p><p>为了使效果更好，你可以为其添加快捷键。在 Mac 系统中选择 Preferences，在 Windows 或 Linux 系统中选择 Settings。然后，点击 Keymap → External Tools → External Tools。双击 Flake8，选择 Add Keyboard Shortcut，出现以下窗口：</p><p>上图中，快捷键是 Ctrl+Alt+A（本教程使用该快捷键）。你可以在文本框中添加喜欢的快捷键，然后在两个窗口中点击 OK。然后，你就可以用该快捷键，在 Flake8 的帮助下分析目前在处理的文件了。</p><h3 id="10、PyCharm-Professional-功能"><a href="#10、PyCharm-Professional-功能" class="headerlink" title="10、PyCharm Professional 功能"></a>10、PyCharm Professional 功能</h3><p>PyCharm Professional 是 PyCharm 的付费版本，具备更多开箱即用的功能和集成。这部分将概览其主要功能，以及官方文档链接（其中详细介绍了每一项功能）。记住，以下功能在 PyCharm Community 版本中均不可用。</p><h4 id="1-Django-支持"><a href="#1-Django-支持" class="headerlink" title="1. Django 支持"></a>1. Django 支持</h4><p>Django 是最流行和最受喜爱的 Python web 框架，PyCharm 对 Django 提供广泛的支持。要确保对 Django 的支持，需要执行以下步骤：</p><ol><li>在 Mac 系统中打开 Preferences，在 Windows 或 Linux 系统中打开 Settings。</li><li>选择 Languages and Frameworks。</li><li>选择 Django。</li><li>检查复选框 Enable Django support。</li><li>应用更改。</li></ol><p>现在确保了对 Django 的支持，你在 PyCharm 中的 Django 开发之旅将轻松很多。具体而言在创建项目时，你会得到一个专用的 Django 项目类型。这表示，当你选择该类型时，你将拥有所有必要文件和设置。这等同于使用 django-admin startproject mysite。</p><p>你也可以在 PyCharm 内直接运行 manage.py 命令。目前支持的 Django 模板，包括以下一些：</p><ul><li>语法和错误高亮显示</li><li>代码补全</li><li>导航</li><li>block 名称补全</li><li>自定义标签和过滤器补全</li><li>标签和过滤器的快速文档</li><li>模板 debug 能力</li></ul><p>除此之外，我们还可以在其他 Django 部分（如视图、URL 和模型）中执行代码补全、对 Django ORM 提供代码追踪支持（code insight support）、对 Django 模型提供模型依赖项关系图。</p><p>更多细节，参见官方文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/django-support7.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/django-support7.html</a></p><h4 id="2-数据库支持"><a href="#2-数据库支持" class="headerlink" title="2. 数据库支持"></a>2. 数据库支持</h4><p>现代数据库开发是一个复杂的任务，需要多个支持系统和工作流。这也是 JetBrains 开发独立 IDE DataGrip 的原因。DataGrip 是独立于 PyCharm 的产品，二者的应用场景和授权都不相同。</p><p>但幸运的是，通过 Database tools and SQL 插件（该插件默认开启），PyCharm 可以支持 DataGrip 中的所有特性。在该插件的帮助下，你可以查询、创建和管理数据库，不管数据库在本地、服务器，还是在云端。该插件支持 MySQL、PostgreSQL、Microsoft SQL Server、SQLite、MariaDB、Oracle、Apache Cassandra 等。</p><p>关于该插件的更多用途，请查看文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/relational-databases.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/relational-databases.html</a></p><h4 id="3-线程并发可视化（Thread-Concurrency-Visualization）"><a href="#3-线程并发可视化（Thread-Concurrency-Visualization）" class="headerlink" title="3. 线程并发可视化（Thread Concurrency Visualization）"></a>3. 线程并发可视化（Thread Concurrency Visualization）</h4><p>Django Channels、asyncio 和近期框架（如 Starlette (<a href="https://www.starlette.io/)）表明异步" target="_blank" rel="noopener">https://www.starlette.io/)）表明异步</a> Python 编程正逐渐成为趋势。异步编程具备很多好处，但很难写，也很难 debug。在此类案例中，Thread Concurrency Visualization 就是医生，帮助你全面管理多线程应用并进行优化。</p><p>更多细节，参见文档：</p><p><a href="https://www.jetbrains.com/help/pycharm/thread-concurrency-visualization.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/thread-concurrency-visualization.html</a></p><h4 id="4-Profiler"><a href="#4-Profiler" class="headerlink" title="4. Profiler"></a>4. Profiler</h4><p>说到优化，profiling 是另一种代码优化方法。profiling 可以帮助你查看代码的哪一部分占用了最多的执行时间。profiler 运行的优先级如下：</p><ol><li>vmprof</li><li>yappi</li><li>cProfile</li></ol><p>如果你没有安装 vmprof 或 yappi，则运行标准 cProfile。</p><p>更多细节，参见：</p><p><a href="https://www.jetbrains.com/help/pycharm/profiler.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/profiler.html</a></p><h4 id="4-科学模式"><a href="#4-科学模式" class="headerlink" title="4. 科学模式"></a>4. 科学模式</h4><p>Python 不仅是通用和 web 编程语言，由于 NumPy、SciPy、scikit-learn、Matplotlib、Jupyter 等库和工具的加持，Python 成为数据科学和机器学习领域的最优工具。有了这些强大工具，你还需要一个强大的 IDE 来支持这些库所具备的绘图、分析等所有功能。</p><p>关于科学模式的更多详情，参见：</p><p><a href="https://www.jetbrains.com/help/pycharm/matplotlib-support.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/matplotlib-support.html</a></p><h4 id="5-远程开发"><a href="#5-远程开发" class="headerlink" title="5. 远程开发"></a>5. 远程开发</h4><p>很多应用出现 bug 的一个常见原因是，开发环境和生产环境不同。尽管在大多数情况下，开发时完美复制生产环境并不现实，但力求实现完美复刻是值得追寻的目标。</p><p>在 PyCharm 的帮助下，你可以使用另一台计算机（如 Linux VM）上的解释器对应用进行 debug。这样，你就可以拥有与生产环境一样的解释器了，从而避免很多因开发环境和生产环境差异导致的 bug。</p><p>详情参见：</p><p><a href="https://www.jetbrains.com/help/pycharm/remote-debugging-with-product.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/pycharm/remote-debugging-with-product.html</a></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>PyCharm 是最好的 Python 开发 IDE 之一。它提供大量优势，帮助执行例行任务，从而节约大量时间。学完本教程，现在你知道如何利用 PyCharm 提高生产效率了吗？</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量劫持技术分析</title>
      <link href="/liu-liang-jie-chi-ji-zhu-fen-xi.html"/>
      <url>/liu-liang-jie-chi-ji-zhu-fen-xi.html</url>
      
        <content type="html"><![CDATA[<h1 id="流量劫持技术分析"><a href="#流量劫持技术分析" class="headerlink" title="流量劫持技术分析"></a>流量劫持技术分析</h1><p>万物互联时代，无线网络全面覆盖我们的生活，基本上各家门店都有wifi标志，而且有的还没有密码，蹭WiFi似乎已成为一项基本“生存技能”，现代人的基本状态就像下面这首打油诗一样：</p><p>枯藤老树昏鸦，空调Wifi西瓜</p><p>葛优同款沙发，我就往那一趴</p><p>如果企业没有对自家应用做好数据防护，蹭网的同时，用户个人隐私也暴露在互联网中，不安全协议传输数据，直接导致用户数据被中间人劫持获取。</p><p>同时，流量被劫持获取，可以直接对服务器发起攻击，获取服务器业务数据、用户数据等核心资产信息。那么企业应该如何去避免此类攻击的发生呢？首先得去了解一下中间人攻击的前因后果。</p><p><strong>中间人攻击的前因后果</strong></p><p><strong>协议先天性缺陷</strong></p><p><strong>（1）HTTP明文传输导致用户信息泄露？</strong></p><p>从攻击的视频中可以知道，攻击者是实施了HTTP协议的中间人攻击，相信每个计算机行业人员都知道，超文本传输协议（HTTP，HyperText TranSfer Protocol）是互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准，也就是说万维网不得不使用这个协议，也是非常的尴尬。</p><p><strong>从攻击者的角度是怎么看待这个问题呢？</strong></p><p>寻找一个采用HTTP协议传输数据的网站系统，这里针对用户登录的账号信息进行数据获取，使用WireShark流量分析工具对局域网下的用户HTTP数据包进捕获，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121924.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>对TCP数据流进行数据分析，可以发现，存在明文的用户名uname和密码password，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121935.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><strong>总结：由此可见HTTP数据流是用明文方式传输数据，攻击者可以利用局域网抓包等手段轻易获取用户与服务器的交互信息。</strong> </p><p><strong>（2）为什么HTTP是明文传输？</strong></p><p>从上一小节可以知道攻击者抓取的HTTP数据包里面的数据是明文，为了解明文传输的原理，可以先了解以下在OSI七层模型中HTTP协议工作的地方，OSI模型七个层次的功能以及协议集图示如下：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121943.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>根据OSI七层模型，可以知道HTTP协议工作在应用层，再来看看HTTP数据包的封装过程，发送方在客户端页面输入上层数据，上层数据到传输层会添加TCP报头形成数据段，再下送到网络层添加IP报头形成数据段，在继续下送至数据链路层添加以太网首部和尾部，形成以太网帧，最后传递至物理层形成01010形式的比特流，整个过程，上层数据这一部分没有进行任何加密数据处理，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121952.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>同理接收方也是如此，接受方收到二进制比特流，通过层层上送解包，最终获取明文的上层数据，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-121957.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><strong>总结：HTTP虽然是应用层的协议，但是其数据在整个数据装包中都是处于明文状态，只是不同层次之间进行了包的封装转换，在不同层次会看到不同的数据，比如在物理层，只能看到0101010类型的二进制比特流，但是在应用层却可以看到明文的数据，整个过程只是一个数据包的封装和解包，没有设计数据的加密和解密操作。</strong></p><p><strong>（3）中间人攻击的根源是什么？</strong></p><p>通过了解HTTP明文传输的分析过后，结合OSI七层模型每一层的含义，参考如下：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122005.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>路由器是存在于OSI七层模型的网络层，也就是通常接触最多的局域网，家里接入有线或者无线网络都会设置路由器，用户通过接入路由器与外界网络进行联系。</p><p>中间人攻击也是在这一层面实施攻击的，这一层存在的协议参考OSI七层模型可以知道有IP，ARP，ICMP等协议。在路由器层面，也就是局域网内是通过地址解析协议即ARP（AddreSS ReSolution Protocol），根据IP地址获取物理地址进行目标寻址交流。大概的流程内容如下：</p><ul><li>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；</li><li>收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</li></ul><p>ARP协议没有安全认证机制，因为局域网内主机是建立在信任的基础上的，所以只要主机接收到ARP应答包，都会缓存在ARP表中，这就为ARP欺骗提供了可能。攻击者可以发送错误的IP地址MAC地址的映射关系。</p><p>ARP欺骗主机等攻击是最常见的中间人攻击，在同一个局域网中，通过将网卡设置为混杂模式，借助ARP欺骗实现中间人攻击即可监听目标设备的网络通信。ARP攻击原理如下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122010.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><img src="https://img.iamghf.top/blog/2019-12-26-122018.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>主机A IP:192.168.1.2 MAC:02-02-02-02-02-02</p><p>主机B IP:192.168.1.3 MAC:03-03-03-03-03-03</p><p>网关 IP:192.168.1.1 MAC:01-01-01-01-01-01</p><p>主机B为攻击者，向被攻击者主机A不断发送ARP响应数据包内容：IP：192.168.1.1对应MAC：03-03-03-03-03-03 向网关不断发送ARP响应包内容：192.168.1.2对应MAC：03-03-03-03-03-03，在局域网内，广播寻址是根据MAC地址来定位用户地址的，所以，一旦mac地址进行了改变，用户地址也就进行了改变，由于ARP会更新缓存表的特性，导致了攻击者可以通过不断发送ARP响应包达到欺骗网关和被攻击者的目的，代替用户与网关进行信息交互，同时代替网关与用户联系，进而形成了中间人攻击。</p><p><strong>总结：ARP缓存接受任何时间更新成为中间人攻击的根本原因</strong></p><p><strong>安全协议不安全</strong></p><p><strong>（1）HTTPS加密传输也存在信息泄漏？</strong></p><p>开发人员针对部分不安全协议进行了安全控制，采用HTTP+SSL的方式进行数据传输，也就是我们常说的HTTPS协议。使用安全套接字层（SSL）进行信息交换，简单来说就是HTTP的安全版，来保证传输的数据安全。</p><p>从攻击者的角度是怎么看待这个问题呢？</p><p>可以通过实验来看结果，选择QQ邮箱登录网站，该网站使用HTTPS，使用WireShark抓包查看TCP数据量</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122024.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>追踪TCP数据流，数据全是乱码，无法识别数据，很明显数据已经被加密了，通过抓包并没有获取用户信息。</p><p>到这里一定会存在一个疑问，如果我的App与服务器全部采用HTTPS通信不就没有中间人攻击的问题了吗？</p><p>事实上如果用自己伪造的CA证书去加解密数据包，一样可以获取到敏感信息，大致攻击思路：攻击者在设备上导入并信任自己的CA证书，然后利用该证书进行数据的加密和解密，在这个过程中，明文信息已经被暴露在攻击者面前。</p><p>比如这里，将CA证书导入设备让其信任，使用工具抓包，能够清晰看见HTTPS数据包的信息。同样是qq邮箱登录的数据，区别就在于使用工具之前我让设备信任了自己的CA证书。当然这里并没有抓到明文密码，这是由于qq邮箱还有其他数据安全加密设置，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122029.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><strong>总结：HTTPS证书信任机制出现问题，还是可以进行中间人攻击截取用户明文的数据流量。</strong></p><p><strong>（2）HTTPS为什么存在安全风险？</strong></p><p>从上一节可以了解到，HTTPS加密协议也是存在中间人攻击的，为了解攻击的原理，我们可以先来看一看HTTPS的握手过程。这里以支付宝为例，利用WireShark获取支付宝的HTTPS数据流量进行分析</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122035.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>客户端发送Client Hello请求建立HTTPS链接，服务器返回Server Hello回应客户端接收到请求，并下发HTTPS证书给客户进行验证，客户端验证通过，发送对称加密密钥，进行数据交换。能够非常直观的看出握手流程，简单的HTTPS实现图</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122040.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>如果客户端未严格校验证书或者忽略了域名校验，攻击者可以通过对客户端进行操作，从而绕过客户端的弱校验，达到欺骗服务器，进行中间人攻击的目的。简单例举了HTTPS存在的问题</p><ul><li>忽略SSL证书校验</li><li>忽略域名校验</li><li>证书信息泄漏</li></ul><p>情况一、信任任何证书。出现这种情况的原因很有可能是使用的开源通信库存在缺陷，还有就是开发人员在开发过程中未连接生产环境的服务器，为解决认证过程中证书报错的问题只能暂时修改代码使其APP信任任意证书，而在上线前未对此代码进行处理。通过对APP进行逆向分析，可以在客户端代码中发现存在开发人员忽略证书认证的代码片段</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122045.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>该段代码重写了谷歌原有X509Certificate[]的校验方式，进行了覆盖，却没有添加自己的证书校验代码，导致证书校验的代码为空，攻击者可以使用任意证书进行流量劫持，这里利用了工具自签名一个证书，即可进行HTTPS证书校验绕过，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122051.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>情况二、信任证书管理机构（CA）颁发的证书。这种情况的APP可以信任任何CA颁发的证书，据说这类的证书只需50美元就能买到。此类问题出在AFNetworking 2.5.2及之前的版本，也就是说如果某APP使用了此版本的开源通信库，在不安全Wifi网络中的黑客、VPN网络中的职工或者国家支持的黑客，只要使用CA颁发的证书就可以对该APP的HTTPS加密数据进行监听或者篡改，在源代码中发现配置代码片段：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122058.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>该段代码一个重要的配置ALLOW_ALL_HOSTNAME_VERIFIER,使其信任官方的CA证书，无论是颁发给谁的，只要是官方的证书，都可以信任，从而导致验证失败。</p><p>情况三、信任合法证书。这种情况的APP只信任对自己而言合法的证书，首先我们看一下SSL认证的原理的前三步：1、客户端向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。2、服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。3、客户端利用服务端传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行下一步。那么如何让APP信任非法的证书呢，看上文说到的3步，我们只需要做到在合法性验证的时候能够欺骗APP，通讯就不会中断。在手机本地添加一个信任证书，APP在本地验证的时候，由于手机信任该证书，APP默认也信任该证书，达到欺骗APP的目的。</p><p>情况四、这种情况是采用了服务器和客户端双向认证的措施，即客户端在确认服务器是否合法之后，服务器也要确认客户端是否是合法的（服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥）。正是这个原因，我们在测试APP时会发现尽管我们信任了burp或者fiddler的证书，可是在进行登录操作时APP依然会显示网络连接错误，此时服务端已经知道客户端可能是非法的，然后拒绝连接。如果你是开发人员，想分析HTTPS流量也很简单：使用burp导入客户端证书，此时burp就可以与服务器正常的建立连接，你也可以正常的截取到数据包了，只要获取到证书以及密钥，即可进行数据获取。APP开发时，在本地实现证书导入，应用于HTTPS双向校验传输证书的密钥可以在本地获取，参考实现代码片段</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122105.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>分析上例代码可以发现，应用于证书client.p12的密钥，猜测在he.b()/he.a()函数中会进行一个处理，利用hook技术，对函数内容进行hook，即可获取字符串信息，该信息包括了密钥和其他的数据，利用获取的密钥和本地保存的client.p12证书，即可模拟开发人员进行HTTPS双向验证，截取用户明文信息。</p><p>两者代码片段分别如下</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122110.png" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p><strong>总结：HTTPS安全协议不安全，主要还是在设计阶段选择了单向校验，在加上后期没有进行严格的证书校验，导致HTTPS证书验证被绕过，其次就是采用了双向校验，但是本地校验的代码没有进行安全保护，攻击者通过动态HOOK，也是可以获取CA证书以及其密钥信息。</strong></p><p><strong>（3）HTTPS中间人攻击的危害？</strong></p><p>HTTPS虽然也存在中间人攻击，但是和ARP局域网攻击又存在很大的差别，参考下图：</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122117.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p><p>ARP欺骗，数据信息攻击获取范围是介于路由器和用户手机之间，也就是OSI模型的数据链路层，路由器和用户手机之间传输的信息都可能被攻击者截取，通过中间人攻击获取在同一局域网下所有用户的数据流量</p><p>SSL欺骗，SSL是位于OSI模型的传输层和应用层之间，可以通过绕过APP本地校验机制实现在传输层和应用层之间的数据传输（数据到达应用层，也就是给用户的展示界面是明文的）截取，从而获取明文数据，或者是HTTPS相关的密钥信息。仅存在用户自己手机内部，只能获取攻击者本身操作的账户流量信息</p><p>总结：就攻击范围来讲，在客户端的攻击HTTPS攻击是影响面比较窄，但就针对服务端的攻击影响来看，两者是一致的，都可以操作服务端数据，获取服务端信息，都能危及服务器安全。</p><p><strong>几维安全解决方案</strong></p><p>应对传输协议缺陷，流量被劫持的安全风险，几维安全建议以协议安全，数据安全，应用代码安全为目标来应对中间人攻击。</p><p>首先对客户端APP的可执行文件DEX、SO、Mach-O被破解的风险，几维安全采用源代码保护技术，对DEX文件进行JAVA2C，将JAVA代码下沉至Native层，并在该层对转化后的伪C代码进行强度最高的虚拟化处理，对SO和Mach-O文件采用源代码编译的方式，直接把C/C++/Object-C/Swift工程项目编译成KiwiVM虚拟化后的结果，保障客户的不被攻击者逆向破解。</p><p>其次对在终端设备运行的客户端运行时会在内存中传递重要的数据，通过接入几维安全防御安全SDK，可以对手机环境，进程防护，代码注入等方面进行全面的检测和防护，保证本地内存数据不遭受恶意篡改。</p><p>同时，针对通道存在的明文传输和协议破解伪造风险，几维安全提供结合<a href="https://www.kiwisec.com/product/KiwiVM-iot.html" target="_blank" rel="noopener">代码虚拟化技术</a>和白盒技术研发的白盒密钥SDK。利用SDK对传输的数据和存储的数据进行高强度的加密，且提供动态加密、数据完整性校验等功能，支持多种对称加密、非对称加密和哈希算法，严格保障了数据的完整性和保密性。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-122124.jpg" alt="流量劫持技术分析！传输协议不安全，数据泄露谁之过？"></p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流量劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何超过大多数人</title>
      <link href="/ru-he-chao-guo-da-duo-shu-ren.html"/>
      <url>/ru-he-chao-guo-da-duo-shu-ren.html</url>
      
        <content type="html"><![CDATA[<p>当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！</p><p>P.S. 这篇文章借鉴于《<a href="https://coolshell.cn/articles/4758.html" target="_blank" rel="noopener">如何写出无法维护的代码</a>》一文的风格……嘿嘿</p><h4 id="相关技巧和最佳实践"><a href="#相关技巧和最佳实践" class="headerlink" title="相关技巧和最佳实践"></a>相关技巧和最佳实践</h4><p>要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。<strong>所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了</strong>。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。</p><p>在信息获取上，你要不断地向大众鼓吹下面的这些事：</p><ul><li>让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。</li><li>让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。</li><li>把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。</li><li>让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场……</li><li>利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。</li></ul><p>然后，在知识学习和技能训练上，让他们不得要领并产生幻觉</p><ul><li>让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……</li><li>培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……</li><li>不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”……</li><li>让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃……</li><li>玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……</li><li>让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……</li><li>告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……</li><li>让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……</li><li>让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……</li></ul><p>最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。</p><ul><li>让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好……</li><li>宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……</li><li>告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……</li><li>多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……</li><li>多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……</li><li>让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……</li><li>让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……</li><li>告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春……</li><li>当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）</li><li>告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……</li><li>每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……</li></ul><p><strong>最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。</strong></p><h4 id="相关原理和思维模型"><a href="#相关原理和思维模型" class="headerlink" title="相关原理和思维模型"></a>相关原理和思维模型</h4><p>对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。</p><p>一般来说，超过别人一般来说就是两个维度：</p><ol><li><strong>在认知、知识和技能上</strong>。这是一个人赖以立足社会的能力（参看《<a href="https://coolshell.cn/articles/4235.html" target="_blank" rel="noopener">程序员的荒谬之言还是至理名言？</a>》和《<a href="https://coolshell.cn/articles/2250.html" target="_blank" rel="noopener">21天教你学会C++</a>》）</li><li><strong>在领导力上</strong>。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《<a href="https://coolshell.cn/articles/17583.html" target="_blank" rel="noopener">技术人员发展之路</a>》）</li></ol><p>首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。</p><h5 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h5><p>要在认知上超过别人，就要在下面几个方面上做足功夫：</p><p>1）<strong>信息渠道</strong>。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？）</p><p>2）<strong>信息质量</strong>。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。</p><p>3）<strong>信息密度</strong>。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像<a href="https://medium.com/netflix-techblog" target="_blank" rel="noopener">Netflix的官方blog</a>和<a href="https://www.allthingsdistributed.com/" target="_blank" rel="noopener">AWS CTO的blog</a>等等地方也会经常有一些这样的文章。</p><h5 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h5><p>要在知识上超过别人，你就需要在下面几个方面上做足功夫：</p><p>1）<strong>知识树（图）</strong>。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，<strong>对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！</strong></p><p>2）<strong>知识缘由</strong>。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。<strong>能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。</strong></p><p>3）<strong>方法套路</strong>。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。<strong>你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路</strong>。</p><h5 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h5><p>要在技能上超过别人，你就需要在下面几个方面做足功夫：</p><p>1）<strong>精益求精</strong>。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。</p><p>2）<strong>让自己犯错</strong>。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！</p><p>3）<strong>找高手切磋</strong>。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！</p><h5 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h5><p>最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。</p><p>1）<strong>识别自己的特长和天赋</strong>。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。</p><p>2）<strong>识别自己的兴趣和事业</strong>。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。</p><p>3）<strong>建立高级的习惯和方法</strong>。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。</p><p>4）<strong>勤奋努力执着坚持</strong>。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《<a href="https://coolshell.cn/articles/2250.html" target="_blank" rel="noopener">21天教你学会C++</a>》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。</p><p>好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。</p><p>转至 <a href="https://coolshell.cn/articles/19464.html" target="_blank" rel="noopener">https://coolshell.cn/articles/19464.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天生容易胖？坚持这几项运动，减肥依旧不是梦</title>
      <link href="/jian-fei.html"/>
      <url>/jian-fei.html</url>
      
        <content type="html"><![CDATA[<p>你是不是也有过这样的经历？同样是放飞自我胡吃海喝，自己逢年过节胖三斤，身边的小伙伴却还一如既往瘦如闪电。</p><h2 id="容易发胖是谁的锅？"><a href="#容易发胖是谁的锅？" class="headerlink" title="容易发胖是谁的锅？"></a>容易发胖是谁的锅？</h2><p>这事儿其实不能怪你，人容不容易胖，和很多因素有关，比如性别、年龄，比如喝酒、抽烟习惯，甚至有研究发现学历越高越不容易发胖 [1]。</p><p>另外，还有一个相当重要的因素——<strong>基因</strong>，并且不是一个两个基因，而是一堆基因：2014年，美国的学者们利用贝叶斯模型找出了欧洲裔美国人群体中8个和肥胖相关的基因，并推测这些基因是通过影响能量摄入的方式影响肥胖 [2]；2015年，又有学者通过全基因组关联分析鉴定出了欧洲人中97个和肥胖相关的基因 [3]。</p><p>所以如果你觉得自己喝水都会长肉，也许这就是命……</p><p>不过，就算命运如此安排，大家还是不可自暴自弃！近期一项最新的研究结果表明，先天易胖，还是有救的！</p><p><img src="https://img.iamghf.top/blog/2019-12-26-113105.gif" alt="img">先天易胖，还是有救的 | 《大侦探皮卡丘》</p><p>最近PLoS Genetics杂志发表了一项关于基因性易胖和运动的研究 [4]。在这项研究中，Lin等人主要探讨了下面这两个问题：运动能不能影响基因导致的肥胖倾向？如果能的话，哪种运动影响最大？</p><h2 id="运动可以改变被写进基因的命运"><a href="#运动可以改变被写进基因的命运" class="headerlink" title="运动可以改变被写进基因的命运"></a>运动可以改变被写进基因的命运</h2><p>为了回答这两个问题，研究者们首先建立了一个多基因风险评分模型。多基因风险评分模型能够通过统计学方法，用一个人的基因序列来预测其患病风险，或者身高啦、是否会脱发啦等等性状的产生概率。在Lin等人的研究中，这个模型便用来预测基因导致的个体肥胖风险。</p><p>通过多基因风险评分模型，Lin等人将研究涉及到的近2万名个体按照基因肥胖风险分为了四个等级；在这个基础上，他们又将每个等级中的个体按照“是否进行规律锻炼”分成了两类，分别统计了每一类样本个体的平均BMI.（注：“规律锻炼”被定义为每次至少30分钟，每周至少三次，每天定时定点亲自下楼买奶茶是不算的！）</p><p>BMI 指一个人的体重与身高的平方之比，是用来评估个体肥胖程度的一个常用指标，BMI指数超过25即为“超重”，超过30就是“肥胖”。</p><p>研究表明，BMI在22.5kg/m2至25kg/m2 之间的个体死亡风险最小。不出意外地，基因肥胖风险更小的组平均BMI更低，基因肥胖风险更大的组平均BMI更高。与此同时，Lin等人发现，在基因肥胖风险最小的组中，规律锻炼的个体BMI比不锻炼个体的BMI更高；而在基因肥胖风险最大的组中，规律锻炼的个体BMI更低。这说明，规律锻炼的人更可能拥有健康的BMI水平。</p><p><img src="https://1-im.guokr.com/jBgXo_YBS-xzWiVAjCYJX00wodTu07RrEd6ObLUIwq44BAAAogMAAEpQ.jpg?imageView2/1/w/555/h/477" alt="img">四组不同基因肥胖风险评分的人群中，不锻炼/日常锻炼个体的平均BMI | 修改自参考文献4</p><p>除了BMI之外，还有其它肥胖衡量指标，比如体脂率，腰围（反映向心性肥胖，就是“将军肚”），臀围（反映糖尿病等代谢疾病）等等。这些指标与BMI类似，和基因肥胖风险成正相关。同样地，在基因肥胖风险最大的组中，规律锻炼个体的所有指标都比不锻炼个体的指标要低——说明规律锻炼能够改善个体健康状况，在一定程度上抵抗基因导致的肥胖风险。</p><h2 id="对于易胖人群，哪些运动更减肥？"><a href="#对于易胖人群，哪些运动更减肥？" class="headerlink" title="对于易胖人群，哪些运动更减肥？"></a>对于易胖人群，哪些运动更减肥？</h2><p>这个结果其实也不算意外，如果研究发现“运动对减肥没有效果”，那才是个大新闻呢。真正的重点在后面——你知道那么多种运动，哪种最减肥吗？</p><p>Lin等人比较了十八种运动对于肥胖指标的影响。这十八种武艺运动包括：慢跑、散步、快走、骑行、爬山、拉伸、国标舞、游泳、太极、跳舞毯、瑜伽、气功、举重、羽毛球、乒乓球、篮球、网球和其它。而在实验室或者办公室或者工地搬砖等，只要是因工作产生的运动，都不计算在内。</p><p><img src="https://1-im.guokr.com/IBr6FDO5fhqnqcBZAwK5fH1nFe7n39ohaAZMbSr0FWBcAQAAjwEAAFBO.png" alt="img">基因肥胖风险评分每升高一个标准差，日常锻炼者BMI和非锻炼者BMI的变化差异。其中，不同运动方式按流行程度自上而下排列。单位：kg/m2 | 修改自参考文献4</p><p>研究者们定量地比较了不同运动对基因肥胖风险的抵消性。从数字上看，大部分运动（上图为负值的运动）都能够在一定程度上抵消部分基因肥胖风险。但值得注意的是，有些运动的抵消效果其实是“<strong>不显著</strong>” 的。这里，“不显著”的意思是指运动效果不大稳定。举个例子，四个朋友一起团购了减肥课程A，课程结束，四个朋友中有两个人各减了10斤，有个人一斤没减，还有一个人胖了10斤。平均每个人减了2.5斤，看起来效果还不错。但是，如果你去参加这个课程，你认为自己会是减10斤的那个，还是胖10斤的那个呢？——A课程的减肥效果就是不显著的。第二年，这群朋友出于某些原因又相约团购了减肥课程B，这次课程结束之后每个人都减了2斤，虽然平均下来不如课程A减得重量多，但胜在表现稳定，给后续想要报名课程的伙伴们提供了很好的参照——课程B的效果就是比A显著的。</p><p>在科学研究中，显著性检验是得出结论的必须步骤之一。在Lin等人的研究中，他们使用了较为严苛的显著性检验方法，最终发现，<strong>慢跑作为能够同时抑制BMI、体脂、和臀围的Top1运动脱颖而出，爬山、散步、快走和国标舞对于抑制BMI也有良好的效果</strong>。至于其它运动，例如游泳啊、骑车啊等等，则被淘汰出局了。</p><p><img src="https://2-im.guokr.com/iLNFoaNOyXDuU57d0UePx_qefEPXExCuzl9djTW3mKn0AQAAGQEAAEpQ.jpg" alt="img">慢跑从众多运动中脱颖而出 | pexels</p><p>好些运动对于减肥的效果似乎并没有那么有效，这个结果还挺出人意料的。前面提到，当前模型里只考虑了“是否参与某种运动”，<strong>那如果把运动时间、运动频率也考虑进来呢？</strong>结果显示，瑜伽做得久也可以抑制BMI的升高，但是颇受欢迎的游泳运动，即使游得久、游得多，好像对于抑制肥胖来说还是没有什么用。</p><p>为什么会有这样的结果呢？作者分析，举重、羽毛球、乒乓球、篮球和网球可能是因为样本量小造成统计不显著；骑行、拉伸运动和气功可能是因为一般人运动时能量消耗太小；至于游泳，有研究提到，<strong>冷水中的运动会刺激食欲，导致运动后吃得更多了</strong>[5, 6]……不过，这些结果也有可能是由样本本身具有、而文章中没有考虑到的因素带来的统计偏差。</p><p>值得一提的是，这篇研究论文中使用的多基因评分模型是基于台湾省人体生物资料库中的相关数据建立的，<strong>这个资料库的绝大部分样本来自具有汉族血统的志愿者</strong> [4, 7]，也就是说，这一篇研究的结果应该对大部分中国人都相当具有参考性了！</p><p>不过话又说回来，不管什么基因啊、血统啊、还是哪种运动效果更好啊，都不是重点。重点是，每天只是动动手指收藏不同的运动分析文章是没有用没有用没有用的！</p><p>今天天气正好，不如晚上一起去跑个步？</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 减肥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统的事务处理</title>
      <link href="/fen-bu-shi-xi-tong-de-shi-wu-chu-li.html"/>
      <url>/fen-bu-shi-xi-tong-de-shi-wu-chu-li.html</url>
      
        <content type="html"><![CDATA[<p>#分布式系统的事务处理</p><p>当我们在生产线上用一台服务器来提供数据服务的时候，我会遇到如下的两个问题：</p><p>1）一台服务器的性能不足以提供足够的能力服务于所有的网络请求。</p><p>2）我们总是害怕我们的这台服务器停机，造成服务不可用或是数据丢失。</p><p>于是我们不得不对我们的服务器进行扩展，加入更多的机器来分担性能上的问题，以及来解决单点故障问题。 通常，我们会通过两种手段来扩展我们的数据服务：</p><p>1）<strong>数据分区</strong>：就是把数据分块放在不同的服务器上（如：uid % 16，一致性哈希等）。</p><p>2）<strong>数据镜像</strong>：让所有的服务器都有相同的数据，提供相当的服务。</p><p>对于第一种情况，我们无法解决数据丢失的问题，单台服务器出问题时，会有部分数据丢失。所以，<strong>数据服务的高可用性只能通过第二种方法来完成——数据的冗余存储</strong>（一般工业界认为比较安全的备份数应该是3份，如：Hadoop和Dynamo）<strong>。 但是，加入更多的机器，会让我们的数据服务变得很复杂，尤其是跨服务器的事务处理，也就是跨服务器的数据一致性</strong>。这个是一个很难的问题。 让我们用最经典的Use Case：“A帐号向B帐号汇钱”来说明一下，熟悉RDBMS事务的都知道从帐号A到帐号B需要6个操作：</p><ol><li>从A帐号中把余额读出来。</li><li>对A帐号做减法操作。</li><li>把结果写回A帐号中。</li><li>从B帐号中把余额读出来。</li><li>对B帐号做加法操作。</li><li>把结果写回B帐号中。</li></ol><p>为了数据的一致性，这6件事，要么都成功做完，要么都不成功，而且这个操作的过程中，对A、B帐号的其它访问必需锁死，所谓锁死就是要排除其它的读写操作，不然会有脏数据的问题，这就是事务。那么，我们在加入了更多的机器后，这个事情会变得复杂起来：</p><p>1）<strong>在数据分区的方案中</strong>：如果A帐号和B帐号的数据不在同一台服务器上怎么办？我们需要一个跨机器的事务处理。也就是说，如果A的扣钱成功了，但B的加钱不成功，我们还要把A的操作给回滚回去。这在跨机器的情况下，就变得比较复杂了。</p><p>2）<strong>在数据镜像的方案中</strong>：A帐号和B帐号间的汇款是可以在一台机器上完成的，但是别忘了我们有多台机器存在A帐号和B帐号的副本。如果对A帐号的汇钱有两个并发操作（要汇给B和C），这两个操作发生在不同的两台服务器上怎么办？也就是说，在数据镜像中，在不同的服务器上对同一个数据的写操作怎么保证其一致性，保证数据不冲突？</p><p>同时，我们还要考虑性能的因素，如果不考虑性能的话，事务得到保证并不困难，系统慢一点就行了。除了考虑性能外，我们还要考虑可用性，也就是说，一台机器没了，数据不丢失，服务可由别的机器继续提供。 于是，我们需要重点考虑下面的这么几个情况：</p><p>1）<strong>容灾</strong>：数据不丢、结点的Failover</p><p>2）<strong>数据的一致性</strong>：事务处理</p><p>3）<strong>性能：吞吐量 、 响应时间</strong></p><p>前面说过，要解决数据不丢，只能通过数据冗余的方法，就算是数据分区，每个区也需要进行数据冗余处理。这就是数据副本：当出现某个节点的数据丢失时可以从副本读到，数据副本是分布式系统解决数据丢失异常的唯一手段。所以，在这篇文章中，简单起见，我们只讨论在数据冗余情况下考虑数据的一致性和性能的问题。简单说来：</p><p><strong>1）要想让数据有高可用性，就得写多份数据。</strong></p><p><strong>2）写多份的问题会导致数据一致性的问题。</strong></p><p><strong>3）数据一致性的问题又会引发性能问题</strong></p><p>这就是软件开发，按下了葫芦起了瓢。</p><h4 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h4><p>说起数据一致性来说，简单说有三种类型（当然，如果细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：</p><p>1）<strong>Weak 弱一致性</strong>：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系，VOIP这样的系统，或是百度搜索引擎（呵呵）。</p><p>2）<strong>Eventually 最终一致性</strong>：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。</p><p>3）<strong>Strong 强一致性</strong>：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。</p><p>从这三种一致型的模型上来说，我们可以看到，Weak和Eventually一般来说是异步冗余的，而Strong一般来说是同步冗余的，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。 好，让我们由浅入深，一步一步地来看有哪些技术：</p><h4 id="Master-Slave"><a href="#Master-Slave" class="headerlink" title="Master-Slave"></a>Master-Slave</h4><p>首先是Master-Slave结构，对于这种加构，Slave一般是Master的备份。在这样的系统中，一般是如下设计的：</p><p>1）读写请求都由Master负责。</p><p>2）写请求写到Master上后，由Master同步到Slave上。</p><p>从Master同步到Slave上，你可以使用异步，也可以使用同步，可以使用Master来push，也可以使用Slave来pull。 通常来说是Slave来周期性的pull，所以，是最终一致性。这个设计的问题是，如果Master在pull周期内垮掉了，那么会导致这个时间片内的数据丢失。如果你不想让数据丢掉，Slave只能成为Read-Only的方式等Master恢复。</p><p>当然，如果你可以容忍数据丢掉的话，你可以马上让Slave代替Master工作（对于只负责计算的结点来说，没有数据一致性和数据丢失的问题，Master-Slave的方式就可以解决单点问题了） 当然，Master Slave也可以是强一致性的， 比如：当我们写Master的时候，Master负责先写自己，等成功后，再写Slave，两者都成功后返回成功，整个过程是同步的，如果写Slave失败了，那么两种方法，一种是标记Slave不可用报错并继续服务（等Slave恢复后同步Master的数据，可以有多个Slave，这样少一个，还有备份，就像前面说的写三份那样），另一种是回滚自己并返回写失败。（注：一般不先写Slave，因为如果写Master自己失败后，还要回滚Slave，此时如果回滚Slave失败，就得手工订正数据了）你可以看到，如果Master-Slave需要做成强一致性有多复杂。</p><h4 id="Master-Master"><a href="#Master-Master" class="headerlink" title="Master-Master"></a>Master-Master</h4><p>Master-Master，又叫<a href="http://en.wikipedia.org/wiki/Multi-master_replication" target="_blank" rel="noopener">Multi-master</a>，是指一个系统存在两个或多个Master，每个Master都提供read-write服务。这个模型是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。 Master-Master的好处是，一台Master挂了，别的Master可以正常做读写服务，他和Master-Slave一样，当数据没有被复制到别的Master上时，数据会丢失。很多数据库都支持Master-Master的Replication的机制。</p><p>另外，如果多个Master对同一个数据进行修改的时候，这个模型的恶梦就出现了——对数据间的冲突合并，这并不是一件容易的事情。看看Dynamo的Vector Clock的设计（记录数据的版本号和修改者）就知道这个事并不那么简单，而且Dynamo对数据冲突这个事是交给用户自己搞的。就像我们的SVN源码冲突一样，对于同一行代码的冲突，只能交给开发者自己来处理。（在本文后后面会讨论一下Dynamo的Vector Clock）</p><h4 id="Two-Three-Phase-Commit"><a href="#Two-Three-Phase-Commit" class="headerlink" title="Two/Three Phase Commit"></a>Two/Three Phase Commit</h4><p>这个协议的缩写又叫2PC，中文叫两阶段提交。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为<strong>协调者</strong>的组件来统一掌控所有节点(称作<strong>参与者</strong>)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。 两阶段提交的算法如下：</p><p><strong>第一阶段</strong>：</p><ol><li>协调者会问所有的参与者结点，是否可以执行提交操作。</li><li>各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……</li><li>参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。</li></ol><p><strong>第二阶段</strong>：</p><ul><li><p>如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。</p></li><li><p>如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。</p></li></ul><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/Two-phase_commit.png" alt="img"></p><p>我们可以看到，2PC说白了就是第一阶段做Vote，第二阶段做决定的一个算法，也可以看到2PC这个事是强一致性的算法。在前面我们讨论过Master-Slave的强一致性策略，和2PC有点相似，只不过2PC更为保守一些——先尝试再提交。 2PC用的是比较多的，在一些系统设计中，会串联一系列的调用，比如：A -&gt; B -&gt; C -&gt; D，每一步都会分配一些资源或改写一些数据。比如我们B2C网上购物的下单操作在后台会有一系列的流程需要做。如果我们一步一步地做，就会出现这样的问题，如果某一步做不下去了，那么前面每一次所分配的资源需要做反向操作把他们都回收掉，所以，操作起来比较复杂。现在很多处理流程（Workflow）都会借鉴2PC这个算法，使用 try -&gt; confirm的流程来确保整个流程的能够成功完成。 举个通俗的例子，西方教堂结婚的时候，都有这样的桥段：</p><p>1）牧师分别问新郎和新娘：你是否愿意……不管生老病死……（询问阶段）</p><p>2）当新郎和新娘都回答愿意后（锁定一生的资源），牧师就会说：我宣布你们……（事务提交）</p><p>这是多么经典的一个两阶段提交的事务处理。 另外，我们也可以看到其中的一些问题， A）其中一个是同步阻塞操作，这个事情必然会非常大地影响性能。 B）另一个主要的问题是在TimeOut上，比如，</p><p>1）如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。</p><p>2）如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。</p><p>3）糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。</p><p>两段提交最大的问题就是第3）项，<strong>如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务</strong>。也就是说，协调者Coordinator对于事务的完成非常重要，Coordinator的可用性是个关键。 因些，我们引入三段提交，三段提交在<a href="http://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank" rel="noopener">Wikipedia</a>上的描述如下，他把二段提交的第一个段break成了两段：询问，然后再锁资源。最后真正提交。三段提交的示意图如下：</p><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/Three-phase_commit_diagram.png" alt="img"></p><p>三段提交的核心理念是：<strong>在询问的时候并不锁定资源，除非所有人都同意了，才开始锁资源</strong>。</p><p>理论上来说，如果第一阶段所有的结点返回成功，那么有理由相信成功提交的概率很大。这样一来，可以降低参与者Cohorts的状态未知的概率。也就是说，一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了。这一点很重要。下面我们来看一下3PC的状态迁移图：（<strong>注意图中的虚线，那些F,T是Failuer或Timeout</strong>，其中的：状态含义是 q – Query，a – Abort，w – Wait，p – PreCommit，c – Commit）</p><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/Three-phase_commit_status.png" alt="img"></p><p>从上图的状态变化图我们可以从虚线（那些F,T是Failuer或Timeout）看到——<strong>如果结点处在P状态（PreCommit）的时候发生了F/T的问题，三段提交比两段提交的好处是，三段提交可以继续直接把状态变成C状态（Commit），而两段提交则不知所措</strong>。</p><p>其实，三段提交是一个很复杂的事情，实现起来相当难，而且也有一些问题。</p><p>看到这里，我相信你有很多很多的问题，你一定在思考2PC/3PC中各种各样的失败场景，<strong>你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设</strong>。</p><p><strong>一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候</strong>。</p><h4 id="Two-Generals-Problem（两将军问题）"><a href="#Two-Generals-Problem（两将军问题）" class="headerlink" title="Two Generals Problem（两将军问题）"></a>Two Generals Problem（两将军问题）</h4><p><a href="http://en.wikipedia.org/wiki/Two_Generals' target="_blank" rel="noopener"_Problem">Two Generals Problem</a> 两将军问题是这么一个思维性实验问题： 有两支军队，它们分别有一位将军领导，现在准备攻击一座修筑了防御工事的城市。这两支军队都驻扎在那座城市的附近，分占一座山头。一道山谷把两座山分隔开来，并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是，这个山谷已经被那座城市的保卫者占领，并且存在一种可能，那就是任何被派出的信使通过山谷是会被捕。 请注意，虽然两位将军已经就攻击那座城市达成共识，但在他们各自占领山头阵地之前，并没有就进攻时间达成共识。两位将军必须让自己的军队同时进攻城市才能取得成功。因此，他们必须互相沟通，以确定一个时间来攻击，并同意就在那时攻击。如果只有一个将军进行攻击，那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。下面是我们的思考：</p><p>1）第一位将军先发送一段消息“让我们在上午9点开始进攻”。然而，一旦信使被派遣，他是否通过了山谷，第一位将军就不得而知了。任何一点的不确定性都会使得第一位将军攻击犹豫，因为如果第二位将军不能在同一时刻发动攻击，那座城市的驻军就会击退他的军队的进攻，导致他的军对被摧毁。</p><p>2）知道了这一点，第二位将军就需要发送一个确认回条：“我收到您的邮件，并会在9点的攻击。”但是，如果带着确认消息的信使被抓怎么办？所以第二位将军会犹豫自己的确认消息是否能到达。</p><p>3）于是，似乎我们还要让第一位将军再发送一条确认消息——“我收到了你的确认”。然而，如果这位信使被抓怎么办呢？</p><p>4）这样一来，是不是我们还要第二位将军发送一个“确认收到你的确认”的信息。</p><p>靠，于是你会发现，这事情很快就发展成为不管发送多少个确认消息，都没有办法来保证两位将军有足够的自信自己的信使没有被敌军捕获。</p><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/two-generals-problems.jpg" alt="img"></p><p><strong>这个问题是无解的</strong>。两个将军问题和它的无解证明首先由E.A.Akkoyunlu,K.Ekanadham和R.V.Huber于1975年在《一些限制与折衷的网络通信设计》一文中发表，就在这篇文章的第73页中一段描述两个黑帮之间的通信中被阐明。 1978年，在Jim Gray的《数据库操作系统注意事项》一书中（从第465页开始）被命名为两个将军悖论。作为两个将军问题的定义和无解性的证明的来源，这一参考被广泛提及。</p><p>这个实验意在阐明：试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。</p><p>从工程上来说，一个解决两个将军问题的实际方法是使用一个能够承受通信信道不可靠性的方案，并不试图去消除这个不可靠性，但要将不可靠性削减到一个可以接受的程度。比如，第一位将军排出了100位信使并预计他们都被捕的可能性很小。在这种情况下，不管第二位将军是否会攻击或者受到任何消息，第一位将军都会进行攻击。另外，第一位将军可以发送一个消息流，而第二位将军可以对其中的每一条消息发送一个确认消息，这样如果每条消息都被接收到，两位将军会感觉更好。然而我们可以从证明中看出，他们俩都不能肯定这个攻击是可以协调的。他们没有算法可用（比如，收到4条以上的消息就攻击）能够确保防止仅有一方攻击。再者，第一位将军还可以为每条消息编号，说这是1号，2号……直到n号。这种方法能让第二位将军知道通信信道到底有多可靠，并且返回合适的数量的消息来确保最后一条消息被接收到。如果信道是可靠的话，只要一条消息就行了，其余的就帮不上什么忙了。最后一条和第一条消息丢失的概率是相等的。</p><p> 两将军问题可以扩展成更变态的<strong>拜占庭将军问题 (Byzantine Generals Problem)</strong>，其故事背景是这样的：拜占庭位于现在土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，军队可能有叛徒和敌军间谍，这些叛徒将军们会扰乱或左右决策的过程。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，这就是拜占庭将军问题。</p><h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h4><p><a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)" target="_blank" rel="noopener">Wikipedia上的各种Paxos算法</a>的描述非常详细，大家可以去围观一下。</p><p>Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个「一致性算法」以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。从20世纪80年代起对于一致性算法的研究就没有停止过。</p><p><strong>Notes</strong>：Paxos算法是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的”La”，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。由于算法难以理解起初并没有引起人们的重视，使Lamport在八年后1998年重新发表到ACM Transactions on Computer Systems上（<a href="http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="noopener">The Part-Time Parliament</a>）。即便如此paxos算法还是没有得到重视，2001年Lamport 觉得同行无法接受他的幽默感，于是用容易接受的方法重新表述了一遍（<a href="http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">Paxos Made Simple</a>）。可见Lamport对Paxos算法情有独钟。近几年Paxos算法的普遍使用也证明它在分布式一致性算法中的重要地位。2006年Google的三篇论文初现“云”的端倪，其中的Chubby Lock服务使用Paxos作为Chubby Cell中的一致性算法，Paxos的人气从此一路狂飙。（Lamport 本人在 <a href="http://research.microsoft.com/users/lamport/pubs/pubs.html#lamport-paxos" target="_blank" rel="noopener">他的blog 中</a>描写了他用9年时间发表这个算法的前前后后）</p><p>注：Amazon的AWS中，所有的云服务都基于一个ALF（Async Lock Framework）的框架实现的，这个ALF用的就是Paxos算法。我在Amazon的时候，看内部的分享视频时，设计者在内部的Principle Talk里说他参考了ZooKeeper的方法，但他用了另一种比ZooKeeper更易读的方式实现了这个算法。</p><p>简单说来，Paxos的目的是让整个集群的结点对某个值的变更达成一致。Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以Paxos算法需要集群中的结点是单数）。</p><p>这个算法有两个阶段（假设这个有三个结点：A，B，C）：</p><p><strong>第一阶段：Prepare阶段</strong></p><p>A把申请修改的请求Prepare Request发给所有的结点A，B，C。注意，Paxos算法会有一个Sequence Number（你可以认为是一个提案号，这个数不断递增，而且是唯一的，也就是说A和B不可能有相同的提案号），这个提案号会和修改请求一同发出，任何结点在“Prepare阶段”时都会拒绝其值小于当前提案号的请求。所以，结点A在向所有结点申请修改请求的时候，需要带一个提案号，越新的提案，这个提案号就越是是最大的。</p><p>如果接收结点收到的提案号n大于其它结点发过来的提案号，这个结点会回应Yes（本结点上最新的被批准提案号），并保证不接收其它&lt;n的提案。这样一来，结点上在Prepare阶段里总是会对最新的提案做承诺。</p><p>优化：在上述 prepare 过程中，如果任何一个结点发现存在一个更高编号的提案，则需要通知 提案人，提醒其中断这次提案。</p><p><strong>第二阶段：Accept阶段</strong></p><p>如果提案者A收到了超过半数的结点返回的Yes，然后他就会向所有的结点发布Accept Request（同样，需要带上提案号n），如果没有超过半数的话，那就返回失败。</p><p>当结点们收到了Accept Request后，如果对于接收的结点来说，n是最大的了，那么，它就会修改这个值，如果发现自己有一个更大的提案号，那么，结点就会拒绝修改。</p><p>我们可以看以，这似乎就是一个“两段提交”的优化。其实，<strong>2PC/3PC都是分布式一致性算法的残次版本，Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。</strong></p><p>我们还可以看到：对于同一个值的在不同结点的修改提案就算是在接收方被乱序收到也是没有问题的。</p><p>关于一些实例，你可以看一下Wikipedia中文中的“<a href="http://zh.wikipedia.org/zh/Paxos算法#.E5.AE.9E.E4.BE.8B" target="_blank" rel="noopener">Paxos样例</a>”一节，我在这里就不再多说了。对于Paxos算法中的一些异常示例，大家可以自己推导一下。你会发现基本上来说只要保证有半数以上的结点存活，就没有什么问题。</p><p>多说一下，自从Lamport在1998年发表Paxos算法后，对Paxos的各种改进工作就从未停止，其中动作最大的莫过于2005年发表的<a href="http://research.microsoft.com/apps/pubs/default.aspx?id=64624" target="_blank" rel="noopener">Fast Paxos</a>。无论何种改进，其重点依然是在消息延迟与性能、吞吐量之间作出各种权衡。为了容易地从概念上区分二者，称前者Classic Paxos，改进后的后者为Fast Paxos。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>下图来自：Google App Engine的co-founder Ryan Barrett在2009年的google i/o上的演讲《<a href="http://snarfed.org/transactions_across_datacenters_io.html" target="_blank" rel="noopener">Transaction Across DataCenter</a>》（视频： <a href="http://www.youtube.com/watch?v=srOgpXECblk）" target="_blank" rel="noopener">http://www.youtube.com/watch?v=srOgpXECblk）</a></p><p><img src="https://coolshell.cn/wp-content/uploads/2014/01/Transaction-Across-DataCenter.jpg" alt="img"></p><p>前面，我们说过，要想让数据有高可用性，就需要冗余数据写多份。写多份的问题会带来一致性的问题，而一致性的问题又会带来性能问题。从上图我们可以看到，我们基本上来说不可以让所有的项都绿起来，这就是著名的CAP理论：一致性，可用性，分区容忍性，你只可能要其中的两个。</p><h4 id="NWR模型"><a href="#NWR模型" class="headerlink" title="NWR模型"></a>NWR模型</h4><p><strong>最后我还想提一下Amazon Dynamo的NWR模型。这个NWR模型把CAP的选择权交给了用户，让用户自己的选择你的CAP中的哪两个</strong>。</p><p>所谓NWR模型。N代表N个备份，W代表要写入至少W份才认为成功，R表示至少读取R个备份。<strong>配置的时候要求W+R &gt; N</strong>。 因为W+R &gt; N， 所以 R &gt; N-W 这个是什么意思呢？就是读取的份数一定要比总备份数减去确保写成功的倍数的差值要大。</p><p>也就是说，每次读取，都至少读取到一个最新的版本。从而不会读到一份旧数据。当我们需要高可写的环境的时候，我们可以配置W = 1 如果N=3 那么R = 3。 这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。如果我们要求读的高效率，我们可以配置 W=N R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。</p><p>NWR模型的一些设置会造成脏数据的问题，因为这很明显不是像Paxos一样是一个强一致的东西，所以，可能每次的读写操作都不在同一个结点上，于是会出现一些结点上的数据并不是最新版本，但却进行了最新的操作。</p><p>所以，Amazon Dynamo引了数据版本的设计。也就是说，如果你读出来数据的版本是v1，当你计算完成后要回填数据后，却发现数据的版本号已经被人更新成了v2，那么服务器就会拒绝你。版本这个事就像“乐观锁”一样。</p><p>但是，对于分布式和NWR模型来说，版本也会有恶梦的时候——就是版本冲的问题，比如：我们设置了N=3 W=1，如果A结点上接受了一个值，版本由v1 -&gt; v2，但还没有来得及同步到结点B上（异步的，应该W=1，写一份就算成功），B结点上还是v1版本，此时，B结点接到写请求，按道理来说，他需要拒绝掉，但是他一方面并不知道别的结点已经被更新到v2，另一方面他也无法拒绝，因为W=1，所以写一分就成功了。于是，出现了严重的版本冲突。</p><p>Amazon的Dynamo把版本冲突这个问题巧妙地回避掉了——版本冲这个事交给用户自己来处理。</p><p>于是，Dynamo引入了Vector Clock（矢量钟？!）这个设计。这个设计让每个结点各自记录自己的版本信息，也就是说，对于同一个数据，需要记录两个事：1）谁更新的我，2）我的版本号是什么。</p><p>下面，我们来看一个操作序列：</p><p>1）一个写请求，第一次被节点A处理了。节点A会增加一个版本信息(A，1)。我们把这个时候的数据记做D1(A，1)。 然后另外一个对同样key的请求还是被A处理了于是有D2(A，2)。这个时候，D2是可以覆盖D1的，不会有冲突产生。</p><p>2）现在我们假设D2传播到了所有节点(B和C)，B和C收到的数据不是从客户产生的，而是别人复制给他们的，所以他们不产生新的版本信息，所以现在B和C所持有的数据还是D2(A，2)。于是A，B，C上的数据及其版本号都是一样的。</p><p>3）如果我们有一个新的写请求到了B结点上，于是B结点生成数据D3(A,2; B,1)，意思是：数据D全局版本号为3，A升了两新，B升了一次。这不就是所谓的代码版本的log么？</p><p>4）如果D3没有传播到C的时候又一个请求被C处理了，于是，以C结点上的数据是D4(A,2; C,1)。</p><p>5）好，最精彩的事情来了：如果这个时候来了一个读请求，我们要记得，我们的W=1 那么R=N=3，所以R会从所有三个节点上读，此时，他会读到三个版本：</p><ul><li><ul><li>A结点：D2(A,2)</li><li>B结点：D3(A,2;  B,1);</li><li>C结点：D4(A,2;  C,1)</li></ul></li></ul><p>6）这个时候可以判断出，D2已经是旧版本（已经包含在D3/D4中），可以舍弃。</p><p>7）但是D3和D4是明显的版本冲突。于是，交给调用方自己去做版本冲突处理。就像源代码版本管理一样。</p><p>很明显，上述的Dynamo的配置用的是CAP里的A和P。</p><p>我非常推大家都去看看这篇论文：《<a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf" target="_blank" rel="noopener">Dynamo：Amazon’s Highly Available Key-Value Store</a>》，如果英文痛苦，你可以<a href="http://vdisk.weibo.com/s/AKRQZMLLc1ol" target="_blank" rel="noopener">看看译文</a>（译者不详）。</p><p>（全文完）</p><p>转至 <a href="https://coolshell.cn/articles/10910.html" target="_blank" rel="noopener">https://coolshell.cn/articles/10910.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 事务 </tag>
            
            <tag> 一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相忘于江湖</title>
      <link href="/xiang-wang-yu-jiang-hu.html"/>
      <url>/xiang-wang-yu-jiang-hu.html</url>
      
        <content type="html"><![CDATA[<h1 id="相忘于江湖"><a href="#相忘于江湖" class="headerlink" title="相忘于江湖"></a>相忘于江湖</h1><p><img src="https://img.iamghf.top/v2-250781f866d4401cd039b578cc4867af_r.jpg" alt=""></p><blockquote><p>泉涸，鱼相与处于陆，相呴以湿，相濡以沫，不如相忘于江湖。与其誉尧而非桀也，不如两忘而化其道。  </p></blockquote><p>湖泊干涸了，原先在水中嬉戏的鱼都被搁浅在了陆地上。它们快要干死了，相互之间吹出湿气河护着，吐出唾沫湿润着，这是多有亲情！何等的友爱！可是谁都不愿意这样，在它们看来，与其在干涸的陆地上如此友爱亲情，还不如在江湖水中各自游走、相互忘去。与其称誉尧而谴责桀，不如把两者都忘掉而把他们的作为都归于事物的本来规律。</p><p>“相濡以沫、相忘于江湖”本意，“相濡以沫”长久以来当做了爱情美好的代名词，形容夫妻二人相扶相携、相依为命地共度患难，相知相敬地品赏平凡，相偎相依地享受温暖。没有奢华，但存质朴；没有距离，但闻呼吸；有的只是一同在困难的处境里，用微薄的力量互相帮助。</p><p>“相忘于江湖”是一种很好的境界，它代表了放弃、淡泊，有一种不计后果率性而为的坦荡心境。</p><p>“相濡以沫，不如相忘于江湖”，仿佛我们在不得已时相忘于江湖，可在不得已时真的是那么大度，那么开怀吗？能够做到彼此在一起的时候，尽量享受点滴幸福的时光；分开的时候，希望彼此抛开一切痛苦，在各自的生活轨迹上活得更好、人生更灿烂吗？我们只能活一次，在有限的生命里我们却会和太多的人相遇，然而却只有一次选择的机会，上帝没有赐于我们一双慧眼，不能轻易把情感看得清清楚楚明明白白真真切切。相遇不一定能够相爱，而相爱却又不一定能够在一起，于是我们的人生中就出现无数不断上演的“邂逅与错过”人生悲情剧。</p><p>我们总是不愿意放手。那是因为用心地爱过，舍不得放弃，如果放弃，也心有不甘。也许有人会说：爱还有另外一个名字，叫做“放弃”！却又有几人能做到？道理其实谁都明白，可依然是“每当午夜梦醒时，发现内心牵挂的依然是远方的你…”，为什么就是抓着疼痛不肯放手呢？因为人是有感情的，你会忘吗？你能忘吗？你忘得了吗？会毫无知觉吗？不能！也绝不会！</p><p>现实中的“相濡以沫”或许是为了生存的必要，或许有太多的无奈，却是令人感动的，但这种难能可贵的情感，与其说是爱情，不如说是一种心灵上的归依和情感上的依托，夫妻结婚之后，也把爱情转化为亲情了。</p><p>雪中送炭固然值得感激和回味，但是，为何一定要求对方置身于风雪之中？与其让相爱的人和自己一起受苦，不如放手让对方处在更符合天性的地方。相忘于江湖才是更高境界的大爱。成全对方，达到庄子所说的大自在境界。</p><p><img src="https://img.iamghf.top/v2-ad4a9ef1a62481f3d9b36e3124ac5eb7_r.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么南方不集中供暖？</title>
      <link href="/nan-fang-gong-nuan.html"/>
      <url>/nan-fang-gong-nuan.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么南方不集中供暖？"><a href="#为什么南方不集中供暖？" class="headerlink" title="为什么南方不集中供暖？"></a>为什么南方不集中供暖？</h1><p>作者：管亚锋</p><p>中国的集中供暖线以秦岭－淮河为界，北边的有，南边的就没有。体现到实际的建设中，一般有集中供暖的城市在城市规划中都会做供热专项规划，确定供热体制，热源，安排供热管网等。</p><p>南方的城市在规划中就没有这个专项，连规划都没有，建设的时候自然也不会考虑了。</p><p>这两年有人提出南方也需要集中供暖，我的个人观点是南方集中供暖是没必要的，也是不应该的。</p><p>首先，由于南方的城市在建设过程中一直以来都没有考虑过供热系统，供热的基础设施是几乎没有的，假如未来要集中供热，那在基础设施的建设投入上就是政府承担不了的，也是大家受不了的。</p><p>首先要重建或改建电厂，水力发电可不行，一定要火力发电烧煤的，烧出来的蒸汽才能作为热源供暖。一个热电厂还不行，在城市里还要建设若干个大型锅炉房，无数个小型锅炉房。</p><p>有了热源还不行，还要输热管网，有从地面走的，街道两边就要架设几十厘米粗的大管子，也有从地下走的，每条街道又要都开挖一遍。</p><p>街道上有了输热管了还不行，建筑里也要有，现在南方的建筑结构几乎都没考虑这个的，还要在墙体上重新架设，这一折腾就要好几十年，没人受得了的。</p><p>其次，南方集中供暖的使用效率不高。北方有的地方集中供暖的天数会达到半年之久，一般的也会有三、四个月，南方有些地区要是集中供暖，总天数会比北方少很多，花巨资做的供暖系统大部分时间是闲置的，再怎么算也是划不来的。</p><p>第三，集中供暖的浪费也是很大的，北方家庭每年采暖费一般都要三、四千，南方家庭哪有开空调花这么多钱的呢。</p><p>仇保兴曾经在公开接受采访时给出了一些触目惊心的数字：「由于供热系统设计不合理，用户室内无法自主调控，如果热了，只好开窗户调节室温，大约浪费了全部热量的 7%。</p><p>目前，办公楼、教室等公共建筑，在下班、放学以后，周末、元旦、春节以及寒假室内无人的情况下，照常供热，浪费很明显。</p><p>以华北地区为例，从 11 月 15 日到第二年的 3 月 15 日，供热期 121 天，其中节假日就有 40 天，占采暖期的 30%。也就是说，这 40 天的供热都浪费了。」</p><p>所以，南方集中供暖是没必要，也是不应该的。天冷就开开空调，不用了就关掉，既省钱又环保。不过以秦岭－淮河为界一刀切的分法是有些不妥，靠近分界线的城市也可以根据实际情况适当做一些集中供暖。</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 供暖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回忆是一壶酒，待你忆时品一口</title>
      <link href="/hui-yi-shi-yi-hu-jiu-dai-ni-yi-shi-pin-yi-kou.html"/>
      <url>/hui-yi-shi-yi-hu-jiu-dai-ni-yi-shi-pin-yi-kou.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.iamghf.top/blog/20200410160548.png" alt=""><br><img src="https://img.iamghf.top/blog/20200410160646.png" alt=""><br><img src="https://img.iamghf.top/blog/20200410160721.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金庸 </tag>
            
            <tag> 武侠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>江湖仍在，何时再见</title>
      <link href="/jiang-hu-reng-zai-he-shi-zai-jian.html"/>
      <url>/jiang-hu-reng-zai-he-shi-zai-jian.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.iamghf.top//Snip20181101_5.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有意思吧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金庸武侠年表</title>
      <link href="/jin-yong-wu-xia-nian-biao.html"/>
      <url>/jin-yong-wu-xia-nian-biao.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/69bbca83gy1fwrgj14xilj20go0be0t1.jpg" alt=""><br>公元前483年 西施送入吴国；范蠡遇到阿青，阿青传越国剑士剑法。</p><p>公元前476年 越国灭掉吴国；范蠡与西施隐居，阿青离去。</p><p>527年南北朝时期，印度高僧菩提达摩来到中国，在嵩山少林寺面壁九年，创立中国禅宗。</p><p>536年 达摩逝世</p><p>554年 西魏宇文泰攻破江陵城（今荆州），梁元帝萧绎留下宝藏在天宁寺，连城诀宝藏来源于此</p><p>隋朝末年，李靖将《易筋经》中的武学奥秘，尽数领悟。</p><p>640年 侯君集攻破高昌国</p><p>694年 明教传至中土。</p><p>唐朝末叶，嘉兴剑术名家改良越女剑法。</p><p>877年 丐帮建立。</p><p>907年 唐朝灭亡</p><p>907年 耶律阿保机建立契丹</p><p>937年 段思平建立大理</p><p>936年—946年 少林寺法慧禅师练成了一指禅。</p><p>960年赵匡胤陈桥兵变，建立宋朝</p><p>1030年 慕容博出生。</p><p>1038年 西夏建立</p><p>1047年 慕容博伤黄眉僧。</p><p>1051年 扫地僧到少林寺。</p><p>1060年 萧峰出生。</p><p>1061年 雁门关外乱石谷大战。</p><p>1062年 萧远山到少林偷研武功。</p><p>1063年 丁春秋暗算师门。</p><p>1064年 慕容复出生。</p><p>1065年 波斯“山中老人”霍山，制圣火令，将平生武功精要，镌刻于圣火令之上。</p><p>1069年 虚竹出生。</p><p>1071年 段誉出生。</p><p>1072年 慕容博伤崔百泉。</p><p>1074年 阿朱出生。</p><p>1077年 慕容博诈死。</p><p>1083年 萧峰接任丐帮帮主。</p><p>1090年 鸠摩智单挑天龙寺六僧。</p><p>1091年 萧峰离开丐帮。</p><p>1092年 聚贤庄大战。</p><p>1093年 萧峰助耶律洪基平定皇太叔之乱（历史上为1063年）；无崖子去世；虚竹接任逍遥派掌门，同年被西夏招为驸马；少林寺门外混战；扫地僧讲经说法。</p><p>1094年 大理段正明禅位侄子段誉；萧峰自尽。</p><p>1103年 岳飞出生。</p><p>1112年 王重阳出生。</p><p>1115年 完颜阿骨打建立金国，黄裳雕版印行万寿道藏。</p><p>1120年 黄裳向明教的高手挑战。</p><p>1125年 金国灭辽</p><p>1127年 金国灭北宋</p><p>1127年—1130年 少林寺灵兴禅师花了三十九年练成了一指禅。</p><p>1140年 独孤求败创独孤九剑第九式破气式。</p><p>1141年 岳飞于狱中撰写《武穆遗书》。</p><p>1158年 段智兴出生。</p><p>1162年 柯镇恶（江南七怪之首）出生。</p><p>1163年 周伯通出生。</p><p>1164年 黄裳完成九阴真经。洪七公出生。</p><p>1168年 欧阳锋出生。</p><p>1170年 独孤求败郁寂而终。</p><p>1171年 黄药师出生。</p><p>1173年 曲灵风出生。</p><p>1178年 裘千仞出生。</p><p>1183年 金轮法王出生</p><p>1184年 朱子柳出生。</p><p>1186年 陈玄风欧阳克出生。</p><p>1190年 火工头陀于少林寺中大开杀戒。</p><p>1196年 王重阳再入古墓，于棺上刻下部分九阴真经，并留“玉女心经，欲胜全真；重阳一生，不弱于人” 的文字，后某日无名僧与王重阳斗酒参阅九阴创九阳；南宋宦官在宫中创葵花宝典。</p><p>1200年 第一次华山论剑。</p><p>1203年 重阳真人拜访段皇爷，废了欧阳峰20年蛤蟆功；王重阳仙逝。</p><p>1205年 郭靖出生</p><p>1206年 成吉思汗建立蒙古汗国</p><p>1206年 裘千仞伤瑛姑幼子。</p><p>1208年 黄蓉出生。</p><p>1222年 小龙女出生。</p><p>1225年 穆念慈比武招亲。</p><p>1226年 杨过出生。</p><p>1227年 第二次华山论剑；蒙古灭西夏；成吉思汗去世。</p><p>1234年 金国灭于蒙古与南宋联合进攻</p><p>1235年 明教高手参考五代十国时期武林高手慕容龙城的“斗转星移”，创出威力更大的“乾坤大挪移”神功，遂为镇教之宝。</p><p>1243年 洪七公、欧阳峰去世。</p><p>1243年 杨过小龙女双剑合壁初试锋芒挫败金轮法王；杨过学弹指神通。</p><p>1243年 郭襄出生；杨过断臂，初入独孤求败剑冢。</p><p>1247年 张三丰出生。</p><p>1253年 蒙古灭大理国</p><p>1257年 明教石教主圣火令为丐帮所夺。</p><p>1259年 杨过飞石击毙蒙哥大汗；第三次华山论剑。</p><p>1262年 郭襄游少林。</p><p>1271年 忽必烈改蒙古国号为“大元”</p><p>1273年 一代大侠郭靖和黄蓉战死襄阳。</p><p>1276年 蒙古攻进南宋都城临安</p><p>1296年 金毛狮王谢逊出生。</p><p>1317年 谢逊离开师父成昆，加入明教。</p><p>1318年 武当六弟子殷梨亭出生。</p><p>1323年 成昆杀谢逊一家。</p><p>1336年 谢逊及张翠山夫妇至冰火岛。</p><p>1337年 张三丰九十大寿；张无忌出生。</p><p>1338年 元兵剿灭袁州明教义军，常遇春、彭莹玉侥幸逃脱。</p><p>1339年 周芷若出生。</p><p>1340年 汝阳王女儿敏敏特穆尔出生，元帝封其“绍敏郡主”。</p><p>1341年 小昭出生。</p><p>1346年 张三丰百岁大寿；张翠山殷素素夫妇自尽。</p><p>1351年 张无忌得九阳神功。</p><p>1357年 六大派围攻光明顶；张无忌任明教教主；张三丰首创太极神功。</p><p>1358年 小昭远走波斯。</p><p>1359年 少林屠狮英雄会；白眉鹰王殷天正去世。</p><p>1360年 张无忌隐退，光明左使杨逍继任为明教第三十五代教主。</p><p>1365年 明教光明右使范遥参考北宋年间的两大神功“北冥神功”及“化功大法”，创出威力极大更为歹毒的“吸星大法”。</p><p>1368年 明朝灭元朝。</p><p>1372年 杨逍去世，明教内部争权夺力，陷入内乱，加上外部朱元璋打压，明教日渐式微。教中高手改组明教，遂为“日月神教”。</p><p>1400年 莆田少林寺得葵花宝典。</p><p>1401年 岳肃蔡子峰偷录葵花宝典；渡元禅师习辟邪剑法。</p><p>1402年 华山派分气宗剑宗。</p><p>1406年 日月神教十长老破五岳剑派剑法。</p><p>1420年 日月教袭武当山，张三丰手抄一部《太极拳经》和青年时佩带的真武剑被抢。</p><p>1458年 武当派开山祖师张三丰仙逝，享年212岁。（据《古今太极拳谱及源流阐秘》李师融先生的考证）</p><p>1469年 令狐冲出生。</p><p>1479年 华山派气宗剑宗之争。</p><p>1486年 任盈盈出生。</p><p>1493年 东方不败篡日月神教教主之位；任我行被囚地牢。</p><p>1503年 余沧海灭福威镖局。</p><p>1504年 令狐冲学得独孤九剑。</p><p>1505年 任我行重夺日月神教教主。</p><p>1506年 任我行去世。</p><p>1509年 令狐冲任盈盈喜结良缘。</p><p>1610年 金蛇郎君夏雪宜惨遭灭门之祸。</p><p>1612年 金蛇郎君夏雪宜得到云南五仙教的镇教“三宝”。</p><p>1623年 袁承志出生。</p><p>1643年 袁承志被推举为七省江湖首领，同年率众人挫毁西洋红夷大炮。</p><p>1644年 袁承志助阿九挫败成王与曹化淳篡位阴谋；李自成攻入北京，明亡；吴三桂降清；李岩夫妇自杀身亡。同年，袁承志、夏青青率亲友、部属避居海外，即今南洋新加坡之地。</p><p>1645年 仲夏，在清兵追击下，李自成率主力部队，败退至湖北通城县。一日，李自成带少数亲兵，在县南查勘地形，在九宫山玄帝庙中，因打盹疏忽，被姜姓农民误杀，终年三十九岁。</p><p>1655年 韦小宝出生在扬州妓院。</p><p>1669年 康熙韦小宝擒鳌拜。</p><p>1670年 韦小宝出任天地会青木堂香主。</p><p>1698年 武当派掌门陆菲青出生。</p><p>1711年 雍正帝与海宁陈家掉包刚出生的儿女，爱新觉罗弘历原来是海宁陈家之子。</p><p>1733年 陈家洛出生。</p><p>1735年 爱新觉罗·弘历登基，年号乾隆。</p><p>1753年腊月，苗人凤和胡一刀决战；胡斐出生。</p><p>1758年 红花会在六和塔囚禁乾隆，回部霍青桐力排众议，大败清军主力。</p><p>1759年 香香公主在北京自杀。</p><p>1780年三月十五日，苗人凤和胡斐决战。</p><p>1924年二月六日，金庸出生</p><p>2018年十月三十号，金庸去世</p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金庸 </tag>
            
            <tag> 武侠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灌篮高手</title>
      <link href="/guan-lan-gao-shou.html"/>
      <url>/guan-lan-gao-shou.html</url>
      
        <content type="html"><![CDATA[<h1 id="灌篮高手"><a href="#灌篮高手" class="headerlink" title="灌篮高手"></a>灌篮高手</h1><p>这可能是这两天最热血的一条新闻了：</p><p>时隔 28 年，今年再版的《灌篮高手》，终于在前天（8 月 28 日）公开了所有新版封面。</p><p>一共 20 张，都是原作者井上雄彦亲笔画的。他说：</p><p>“我有点想见这些家伙了。”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090526.jpg" alt=""></p><p>有个网友疯狂转发了 20 多条，说自己已经变成拖家带口的老男人，有生之年还能看到这些画，直接泪崩了。</p><p>28 年了，这些热血、青春的面孔，又一次点燃了一大批 80 后、90 后。</p><p>90 年代初，国内没有引进 NBA 也没有姚明，很多男孩的篮球梦是从《灌篮高手》开始。</p><p>女孩们都为流川枫和仙道痴迷，觉得会打篮球的男生很帅。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090543.gif" alt=""></p><p>《灌篮高手》的贴吧有 2000 多万个帖子，每隔几分钟都会有新的留言讨论。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090551.jpg" alt=""></p><p>虎扑上到现在还有人在分析灌篮高手的战术。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090604.jpg" alt=""></p><p>快 30 年了，很多人至今还保留着那时候买的画册、海报和明信片。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090611.jpg" alt="image"></p><p>今年早些时候有篇文章刷了屏，只因为一句话：</p><p>“你喜欢的那个赤木晴子已经奔五了。”</p><p>人们好像被突然提醒：追《灌篮高手》的你们也快老了吧。</p><p>但，事实证明，热血这种东西是不会冷的。</p><p>新装版的漫画在日本上市一周，就卖到脱销。销量直接压过常年位居榜首的《海贼王》。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090618.jpg" alt=""><br><img src="https://img.iamghf.top/blog/2019-12-26-090647.jpg" alt=""></p><p>日本《朝日新闻》头版也是樱木花道的特写。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090657.jpg" alt=""></p><p>日本街头还出现了很多《灌篮高手》的巨幅广告牌，光看一眼就让人瞬间回到青春时代。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090706.jpg" alt=""></p><p>流川枫。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090714.jpg" alt=""></p><p>樱木花道。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090723.jpg" alt="image"></p><p>赤木刚宪。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090733.jpg" alt=""></p><p>三井寿。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090739.jpg" alt=""></p><p>宫城良田。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090744.jpg" alt=""></p><p>这些场面真热血，热血到几乎所有人都忽略了它是一个失败的故事。</p><p>这群被人贴在墙上、放在心里二三十年的人，其实真的很普通。</p><p>湘北是一直被瞧不起的篮球队，放到全国，队员们也根本算不上什么真正专业化的篮球天才。</p><p>他们拼尽全力想咸鱼翻身，却在全国大赛的第 3 轮就被淘汰了。</p><p>天天喊着的“全国制霸” 的梦想，到最后也没实现。</p><p>28 年了，多少人把这群“废柴”当成自己的精神偶像，用那么大的阵仗去纪念。</p><p>二</p><p>在你我的生活中，《灌篮高手》里的每个人都是热血励志的明星。</p><p>但事实上，在漫画里，湘北篮球队一开始就是个连名字都会被叫错的“废柴联盟”。</p><p>在县级选拔里几乎就没进过第二轮，被很多对手当做三流球队。</p><p>主角大半都是问题儿童。</p><p>顶着“篮球天才”光环的流川枫，是个不爱跟人说话的“自闭少年”，出场第一集就跟人打架打得满脸血。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090750.jpg" alt=""></p><p>樱木花道，头脑简单四肢发达的不良少年，脾气暴，也爱打架，动不动就拿头撞人。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090756.gif" alt=""></p><p>周围的所有人对他的态度都是不期待、不指望，别捣乱就好了。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090802.jpg" alt=""></p><p>三井寿也很可怕，初中时还带队拿过比赛冠军，但因为一次受伤就一蹶不振，留长发混社会，很像以前班上坐在最后一排那种自暴自弃的小混混。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090810.jpg" alt=""></p><p>队长赤木刚宪稍微好一点，有班干部的严厉和责任感，小学就有“称霸全国”的梦想，但直到高三还没实现。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090820.jpg" alt=""></p><p>知乎上有个回答说得很全面：</p><p>“我们认为湘北是全明星，只因为他们是主角，我们所看到的篇幅，他们的故事占据了绝大多数，所以我们势必会觉得他们比其他的球员要【优秀】。”</p><p>这样一个球队，训练不到两个月就放话要闯进全国联赛，制霸全国。</p><p>在别人看来，就像年级倒数的差生，在高考前两个月喊着要考清华一样。</p><p>别的队伍见到他们，笑都笑死了：</p><p>你们队里就算有优等生又怎么样？这种傻子制霸全国，怎么可能啊？</p><p>还好，他们都有一个共同目标：我要打篮球。</p><p>三</p><p>也正是因此，才让他们最终闯进全国大赛显得像个奇迹。</p><p>“如果我们拼命努力，却只能到达别人的起点，那我们为什么还要努力？”</p><p>《灌篮高手》里那些最热血的瞬间，给了所有人答案。</p><p>赤木，一个输过很多次的人，每天都在为赢的那一天做准备。</p><p>每天睡觉前我都会想象今天的情景，我们湘北跟神奈川县的王者海南附中，争夺全国大赛参赛权的一战。每个晚上，脑中都描绘着这个场景，从一年级开始，直到今天。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090859.jpg" alt=""></p><p>自暴自弃，没有勇气重新开始的三井，想起安西教练曾经告诉他的话：</p><p>“直到最后一刻也不能放弃希望，一但放弃的话，比赛就结束了。”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090907.jpg" alt=""></p><p>那一刻他再也忍不住自己的热泪，哭着说：</p><p>“教练，我……我想打篮球！”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090912.gif" alt=""></p><p>什么都不会，却老自称天才的樱木花道，在看到比自己强大得多的人，比自己更努力时，突然被一巴掌打醒。第二天一早就开始去训练。</p><p>“不要想着在场上出风头，必须每天脚踏实地去练习才行。”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090920.jpg" alt=""></p><p>一群咸鱼，为了一个目标拼了命往前冲，跑得乱七八糟摔得头破血流，最后居然跑赢了一次——打进了全国大赛。</p><p>这是他们最难的一场。比赛还没结束，湘北的士气已经摇摇欲坠，此时樱木用纸卷成大喇叭高喊：我要打倒山王！</p><p>比赛中樱木脊背受伤，教练告诉他，如果你继续上场，可能未来都无法打球了。</p><p>樱木说：“老头子，你最光辉的时刻是何时？是全日本时代吗？………而我，就是现在了！”</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090926.jpg" alt=""></p><p>这场比赛，他们赢了。</p><p>那一刻，一直是死对头的樱木花道和流川枫有了第一次击掌，所有人都忘不掉。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090932.jpg" alt=""></p><p>但谁也没想到接下来的结局是这样的：</p><p>漫画的前一页，是对手失败后失落的背影，和湘北队赢了比赛后的全家福。</p><p>而下一页，他们就失败了——</p><p>8月4日 全国大赛第四天：湘北因体力不支不敌爱和，未能晋级全国 8 强。</p><p>按照一般的励志“套路”，主角倒下再多次，都会重新赢回来。</p><p>可《灌篮高手》的故事就这样戛然而止，这就是结局了：</p><p>他们还是没拿到全国冠军，他们的梦想还是破灭了。</p><p>很多人给作者井上雄彦写信，说这不是真的，要他改结局。</p><p>但他的回应是：青春就是不完美的。</p><p>有些时候就算你拼尽全力，还是会输掉。</p><p>四</p><p>28 年后我们依然把灌篮高手奉为经典，其实就是因为这个不够完满的结局。</p><p>如果他们赢到最后，那是个童话。</p><p>只有他们失败了，才叫真正的励志。</p><p>前段时间刷屏的一个故事，几乎是湘北的现实版重现。</p><p>日本一所来自偏远学校、没事会养猪养鸡的棒球队，奇迹般打进了全国总决赛，距离上次闯进决赛，隔了 103 年。</p><p>决赛上，他们的对手是春季冠军，两队的差距就像猫对老虎一样。</p><p>如果奇迹继续，他们肯定是赢了。</p><p>但最后 13-2，压倒性地败了。被打败的球员们互相拥抱，痛痛快快落了泪。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090939.gif" alt=""></p><p>我想起《灌篮高手》的最后一页，球队的全家福上，写着：</p><p>使尽全力来对抗山王的湘北，在第三回对爱和学院时，输得一塌糊涂。</p><p>但他们每个人都依然笑得那么开心、满足。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090944.jpg" alt=""></p><p>如果我们拼命努力，却只能到达别人的起点，那我们为什么还要努力？</p><p>是为了结束后，你可以问心无愧地说：我尽力了，真的尽了全力了。</p><p>不管你多么热爱，多么渴望，不管你付出多少汗水和心血，有时候，梦想还是会破灭。</p><p>这才是《灌篮高手》最后想要告诉你的事。</p><p>五</p><p>这部动漫在现实里连载了 6 年，但在他们的人生里，其实只有短短四个月。</p><p>后来，井上雄彦在一个学校的黑板上画了一段续篇，讲的是全国大赛十日后。</p><p>队伍散掉了。</p><p>赤木高三，跟目暮一起退部备考。</p><p>樱木在疗养院修养，还没追到晴子，背伤也还没好起来。</p><p>流川枫入选了日本青年队，依然想去美国，在学英语。</p><p>宫城当上新队长，三井继续为冬季赛努力。</p><p>他们曾经的劲敌鱼柱，毕业后去当了厨师。</p><p>28 年后，你会发现，你的现在，就是《灌篮高手》的结局。</p><p>他们接下来的人生很可能跟你一样，年少的梦想过了就过了，会按部就班地考大学、上班、结婚生子，很少再上球场，在各种事情上被别人吊打，未来很可能会有更多失败。</p><p>但他们总会在某个时刻重新提醒你，点燃你——</p><p>明天很可能不会更好，最后很可能会失败，还是要不停不停地向前走。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090950.jpg" alt=""></p><p>有个网友说，在东京买东西银座播放这首歌，一群叔叔辈的霓虹人全都跟着唱了起来。</p><p>还有个年纪很小的男生，有次偷偷发现他爸在电脑面前看哭了。</p><p>一个读者转行做广告，每天改二十几次广告方案。一丧气就幻想自己是第一控球后卫宫城良田，总有一天会“让甲方跪着叫爸爸”。</p><p>更年轻的时候，我们喜欢讨论谁输谁嬴。</p><p>但现在，我们已经接受了梦想很可能会破灭。</p><p>想认输的时候，我会打开《灌篮高手》。</p><p>22 年前那场比赛结束了，但人生的比赛还没完呢。</p><p><img src="https://img.iamghf.top/blog/2019-12-26-090956.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漫画 </tag>
            
            <tag> 灌篮高手 </tag>
            
            <tag> 樱木花道 </tag>
            
            <tag> 流川枫 </tag>
            
            <tag> 篮球 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>find Permission denied</title>
      <link href="/findpermissiondenied.html"/>
      <url>/findpermissiondenied.html</url>
      
        <content type="html"><![CDATA[<h1 id="find-Permission-denied"><a href="#find-Permission-denied" class="headerlink" title="find Permission denied"></a>find Permission denied</h1><p>mac下执行find命令去查找时会出现满屏的Permission denied  </p><pre><code>find / -name &quot;keywords&quot;</code></pre><p>哪怎样阻止这些Permission denied信息呢？解决方法如下：</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li><p>管理员权限执</p><pre><code>sudo find / -name &quot;keyword&quot; -print</code></pre></li></ul><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ul><li><p>丢弃错误输出</p><pre><code>find / -name &quot;keyword&quot; -print 2&gt;/dev/null</code></pre></li></ul><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><ul><li><p>过滤 Permission denied 信</p><pre><code>find / -name &quot;keyword&quot; -print 2&gt;&amp;1 | fgrep -v &quot;Permission denied&quot;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> linux </tag>
            
            <tag> find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酒店网络折腾</title>
      <link href="/jiu-dian-wang-luo-zhe-teng.html"/>
      <url>/jiu-dian-wang-luo-zhe-teng.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络折腾"><a href="#网络折腾" class="headerlink" title="网络折腾"></a>网络折腾</h1><p>出差在外，在酒店休息，无聊准备看下视频，没带电脑电源，只能选择电视。然而酒店电视又不能连网。这点小问题怎么能难倒机智的我。(^_^)</p><ul><li>先登录酒店Wi-Fi ，发现还要输手机验证码验证。bingo 这应该就是电视不能连网的原因了，电视能连Wi-Fi，但不能进行验证。</li><li>简单的设置电视连Wi-Fi已经行不通，换个思路先尝试去登陆下管理界面。</li><li>酒店使用了一个网关，一个机顶盒。网关上有账号与密码，登陆提示密码错误。怀疑是被管理人员修改了密码，尝试去网上搜索超级账号，都用不了。</li><li>难道已经没折了吗？（加一个网线应该就可以了，可身边没有多余网线）再仔细检查了网关和机顶盒，发现机顶盒上也有账号密码，大胆猜测Wi-Fi是由机顶盒提供的。</li><li>输入机顶盒账号密码，成功登进管理界面。</li><li>查看相关网络选项，发现有机顶盒创建了两个Wi-Fi，一个是隐藏的，一个是现在正连的。</li><li>正连的Wi-Fi 没有修改的选项，估计是有更高级的账号来开启。难倒这道门也关闭了吗？</li><li>不死心，又仔细检查 发现了个Wi-Fi认证里有个白名单，自己刚刚连接的设备已经在白名单里了。</li><li>大胆猜测在输入验证码后，会触发相关机制加入白名单，so 将电视的mac手工加入白名单</li><li>重启完设备，发现电视还是不能联网。问题出在哪呢？</li><li>再次登入管理界面，发现没有给电视分配ip地址，问题可能出现在这。</li><li>手工给电视分配ip</li><li>重启设备，电视终于连上网了，可以愉快的看视频了。</li></ul><p><strong>后记：</strong></p><ul><li>发现有人在蹭网，这显然不能忍。启用mac白名单过滤，把自己的设备加入白名单，将其他人都拦到门外。出门在外，网络安全还是要已最坏的恶意猜测他人，先小人后君子。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dokuwiki中文乱码</title>
      <link href="/dokuwiki-zhong-wen-luan-ma.html"/>
      <url>/dokuwiki-zhong-wen-luan-ma.html</url>
      
        <content type="html"><![CDATA[<h1 id="Dokuwiki-中文乱码"><a href="#Dokuwiki-中文乱码" class="headerlink" title="Dokuwiki 中文乱码"></a>Dokuwiki 中文乱码</h1><blockquote><p>在创建页面的时候，发现在网页端使用中文文字创建成功后，在本地服务器本机的文件夹<br>Dokuwiki\data\pages 可以看到该文件名是使用%数字%字母%等的形式显示出来，这对于文件的本地存档是很不方便的。 </p></blockquote><p><strong>解决方法</strong><br>主要修改2个地方:  </p><ol><li>在服务器机子上 dokuwiki\conf\local.php<br>在最后一行加上： <pre><code>$conf[‘fnencode’]==’GB2312’; #注意分号不能少。 </code></pre></li><li>在服务器机子上 dokuwiki\inc\pageutils.php<br>修改两个函数：utf8_encodeFN 和utf8_decodeFN  </li></ol><pre><code>function utf8_encodeFN($file,$safe=true){    global $conf;    if($conf[&#39;fnencode&#39;] == &#39;utf-8&#39;) return $file;    if($safe &amp;&amp; preg_match(&#39;#^[a-zA-Z0-9/_\-\.%]+$#&#39;,$file)){        return $file;    }    if($conf[&#39;fnencode&#39;] == &#39;safe&#39;){        return SafeFN::encode($file);    }     /*    #添加if判断开始    if ($conf[&#39;fnencode&#39;]==&#39;gb2312&#39;){        return iconv(&#39;UTF-8&#39;,&#39;GB2312&#39;,$file);    }    # if判断结束    $file = urlencode($file);    $file = str_replace(&#39;%2F&#39;,&#39;/&#39;,$file);    */    return $file;}</code></pre><pre><code>function utf8_decodeFN($file){    global $conf;    if($conf[&#39;fnencode&#39;] == &#39;utf-8&#39;) return $file;    if($conf[&#39;fnencode&#39;] == &#39;safe&#39;){        return SafeFN::decode($file);    }    /*    #添加该 if判断开始    if ($conf[&#39;fnencode&#39;]==&#39;gb2312&#39;){        return iconv(&#39;GB2312&#39;,&#39;UTF-8&#39;,$file);    }    #if判断结束    return urldecode($file);    */    return $file;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DokuWiki </tag>
            
            <tag> Wiki </tag>
            
            <tag> 中文乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贵州工程快速搭建</title>
      <link href="/gui-zhou-gong-cheng-kuai-su-da-jian.html"/>
      <url>/gui-zhou-gong-cheng-kuai-su-da-jian.html</url>
      
        <content type="html"><![CDATA[<p>#贵州工程快速搭建</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>eclipse</strong>  Version: Oxygen Release (4.7.0)<br><strong>代码下载</strong><br>svn ：<br><strong>jetty插件安装</strong><br>安装eclipse jetty插件<br><img src="https://img.iamghf.top/eclipse-jetty-plugsSnip20180822_29.png" alt="jetty"></p><h2 id="创建java-工程"><a href="#创建java-工程" class="headerlink" title="创建java 工程"></a>创建java 工程</h2><p>new-&gt;java project </p><h2 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h2><p>导入src,config,csfwvm,html,lib文件夹<br><img src="https://img.iamghf.top/Snip20180822_30.png" alt="import file"></p><h2 id="设置build-path"><a href="#设置build-path" class="headerlink" title="设置build path"></a>设置build path</h2><p>添加lib文件夹里的jar包<br><img src="https://img.iamghf.top/build-pathSnip20180822_31.png" alt="build path"></p><h2 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h2><p>打开debug Configurations<br><img src="https://img.iamghf.top/debug-configSnip20180822_32.png" alt="debug configurations"></p><p>新增jetty app<br><img src="https://img.iamghf.top/debug-jettySnip20180822_33.png" alt="debug-jetty"></p><p>大功告成！</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>问题一：</strong>  </p><blockquote><p>java.lang.NoClassDefFoundError: org/apache/juli/logging/LogFactory  </p></blockquote><p>引入tomcat根目录bin中的tomcat-juli.jar</p><p><strong>问题二：</strong></p><blockquote><p>java.lang.ClassCastException: org.apache.tomcat.SimpleInstanceManager cannot be cast to org.apache.tomcat.InstanceManager </p></blockquote><p>检查tomcat的jar包是否冲突</p><p><strong>问题三：</strong></p><blockquote><p>java.lang.NoSuchMethodError: org.apache.tomcat.JarScanner.scan(Ljavax/servlet/ServletContext;Ljava/lang/ClassLoader;Lorg/apache/tomcat/JarScannerCallback;Ljava/util/Set;)V</p></blockquote><p>jar包冲突，删除重复jar包 </p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贵州工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 程序性能排查</title>
      <link href="/cheng-xu-xing-neng-pai-cha.html"/>
      <url>/cheng-xu-xing-neng-pai-cha.html</url>
      
        <content type="html"><![CDATA[<p>#java 程序性能排查<br>最近服务器频繁告警，找个时间排查了下问题。</p><h2 id="使用top命令"><a href="#使用top命令" class="headerlink" title="使用top命令"></a>使用top命令</h2><p><img src="https://img.iamghf.top/Snip20180821_23.png" alt="linux top"></p><h2 id="查看线程情况"><a href="#查看线程情况" class="headerlink" title="查看线程情况"></a>查看线程情况</h2><p>命令： <strong>ps p pid -L -o pcpu,pmem,pid,tid,time,tname,cmd</strong><br><img src="https://img.iamghf.top/Snip20180821_24.png" alt="java 线程"></p><h2 id="jstack-查看堆栈"><a href="#jstack-查看堆栈" class="headerlink" title="jstack 查看堆栈"></a>jstack 查看堆栈</h2><p>首先要将tid转换成16进程<br>命令 <strong>printf “%x\n” pid</strong><br><img src="https://img.iamghf.top/Snip20180821_25.png" alt="printf"></p><p>命令 <strong>jstack -l pid &gt; tmp.log</strong><br>再在临时文件中搜索tid对应线程的相关信息</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python格言</title>
      <link href="/python-ge-yan.html"/>
      <url>/python-ge-yan.html</url>
      
        <content type="html"><![CDATA[<p>#python</p><blockquote><p><strong>The Zen of Python</strong>  - Tim Peters </p><p>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one– and preferably only one –obvious way to do it.<br>Although that way may not be obvious at first unless you’re Dutch.<br>Now is better than never.<br>Although never is often better than <strong>right</strong> now.<br>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea — let’s do more of those!  </p></blockquote><h2 id="翻译："><a href="#翻译：" class="headerlink" title="翻译："></a>翻译：</h2><p>美丽优于丑陋。<br>清楚优于含糊。<br>简单优于复杂。<br>复杂优于繁琐。<br>平坦优于曲折。<br>宽松优于密集。<br>重要的是可读性。<br>特殊的案例不足以特殊到破坏规则。<br>尽管实践可以打破真理。<br>错误却不可置之不理。<br>除非另有明确要求。<br>面对模棱两可，拒绝猜测。<br>总会有一个 —— 最好是只有一个 —— 显而易见的方式来明辨。<br>哪怕这种方式在开始的时候可能并不明显 —— 除非你是荷兰人。<br>现在有比没有好。<br>尽管没有经常好于现在。<br>如果如何实现很难被解释清楚，那么这个想法就是一个坏想法。<br>如果如何实现可以被很好的解释，那么这是一个好想法。<br>命名空间就是一个非常好的想法 —— 让我们在这方面多做些工作吧!  </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/git-chang-yong-ming-ling.html"/>
      <url>/git-chang-yong-ming-ling.html</url>
      
        <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><p><strong>mkdir</strong>  创建目录<br><strong>pwd</strong>    显示当前目录的路径。<br><strong>git init</strong> 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。<br><strong>git add</strong> 把xx文件添加到暂存区去。<br><strong>git commit -m “XX”</strong> 提交文件 –m 后面的是注释。<br><strong>git status</strong> 查看仓库状态<br><strong>git diff XX</strong>     查看XX文件修改了那些内容<br><strong>git log</strong>     查看历史记录<br><strong>git reset –hardHEAD^</strong>  或者gitreset–hardHEAD<del>回退到上一个版本(如果想回退到100个版本，使用gitreset–hardHEAD</del>100)<br><strong>cat XX</strong>     查看XX文件内容<br><strong>git reflog</strong>     查看历史记录的版本号id<br><strong>git checkout–XX</strong>     把XX文件在工作区的修改全部撤销。<br><strong>git rm XX</strong>     删除XX文件<br><strong>git remote add origin XXX</strong>     关联一个远程库xxx<br><strong>git push -u origin master</strong>     把当前master分支推送到远程库(-u第一次要用以后不需要)<br><strong>git clone XXX</strong>     从远程库中克隆<br><strong>git check out -b dev</strong>     创建dev分支并切换到dev分支上<br><strong>git branch</strong>     查看当前所有的分支<br><strong>git checkout master</strong>     切换回master分支<br><strong>git merge dev</strong>     在当前的分支上合并dev分支<br><strong>git branch -d dev</strong>     删除dev分支<br><strong>git branch name</strong>     创建分支<br><strong>git stash</strong>     把当前的工作隐藏起来等以后恢复现场后继续工作<br><strong>git stash list</strong>     查看所有被隐藏的文件列表<br><strong>git stash apply</strong>     恢复被隐藏的文件，但是内容不删除<br><strong>git stash drop</strong>     删除文件<br><strong>git stash pop</strong>     恢复文件的同时也删除文件<br><strong>git remote</strong>     查看远程库的信息<br><strong>git remote -v</strong>     查看远程库的详细信息<br><strong>git push origin master</strong>     Git会把master分支推送到远程库对应的远程分支上  </p>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透方法</title>
      <link href="/nei-wang-chuan-tou-fang-fa.html"/>
      <url>/nei-wang-chuan-tou-fang-fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="内网穿透方法"><a href="#内网穿透方法" class="headerlink" title="内网穿透方法"></a>内网穿透方法</h1><h2 id="nat123"><a href="#nat123" class="headerlink" title="nat123"></a>nat123</h2><p>描述：非网站映射或者全端口映射都可以实现，非网站映射可以单独在虚拟机安装服务就行，但是速度不理想。免费版的全端口映射（P2P）可以实现点到点的访问，但是两端都要安装客户端，免费版在手机不可使用。属于商业软件，完全闭源。</p><h2 id="teamviewer"><a href="#teamviewer" class="headerlink" title="teamviewer"></a>teamviewer</h2><p>描述：是一种国外的远程控制软件，免费版已经功能很强大，支持win、Linux、iOS、安卓客户端。服务端就使用国外的服务器，速度中等。属于商业软件，完全闭源。</p><h2 id="向日葵"><a href="#向日葵" class="headerlink" title="向日葵"></a>向日葵</h2><p>描述：跟teamviewer原理差不多，但创始人是中国人，服务器也在中国，客户端包涵PC和手机端。实际使用体验上，感觉速度并不稳定，时好时坏。属于商业软件，完全闭源。</p><h2 id="ZeroTier"><a href="#ZeroTier" class="headerlink" title="ZeroTier"></a>ZeroTier</h2><p>描述：虚拟局域网。就是通过一个公共的服务器，建立一个虚拟局域网，让家里电脑和公司电脑同处于一个虚拟局域网，然后通过分配到的虚拟局域网ip进行连接。两端都需要安装客户端。服务器在国外，响应不理想。项目的服务端没有开源，客户端是开源的。</p><h2 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h2><p>描述：主要用途是给网站或者安装开发提供部署环境，但是也同样可以用来进行端口转发。除了官方提供的服务之外，作者也放出了源代码，国内有好心的小伙伴也有自行搭建服务端供大家使用的。建议可以找服务器是在自己地区附近的，响应速度会相对快很多。</p><h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>描述：原理与ngrok是相同的，但服务端需要自己搭建，由于该项目是完全开源的，所以代码安全性较高，目前自用感觉不错，前提是服务端速度足够。</p><h2 id="n2n"><a href="#n2n" class="headerlink" title="n2n"></a>n2n</h2><p>项目官网：<a href="https://github.com/ntop/n2n" target="_blank" rel="noopener">https://github.com/ntop/n2n</a></p><p>描述：n2n的原理与ZeroTier相似，但是n2n的中央节点服务端是需要自己搭建的，而ZeroTier的服务端是官网提供的。如果中央节点的服务端速度足够，那么速度相当快！</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>这个ssh就是Linux中的SSH，其实SSH也具有端口映射的功能，可以实现与nat123相似的功能，前提需要一台自己的服务器。</p><h2 id="NPS"><a href="#NPS" class="headerlink" title="NPS"></a>NPS</h2><p>项目官网：<a href="https://github.com/cnlh/nps/" target="_blank" rel="noopener">https://github.com/cnlh/nps/</a></p><p>类似frp，但文档质量高于frp，代码成熟度高于frp，如果想长期使用内网穿透建议使用这个。</p><blockquote><p>一款轻量级、功能强大的内网穿透代理服务器。支持tcp、udp流量转发，支持内网http代理、内网socks5代理，同时支持snappy压缩、站点保护、加密传输、多路复用、header修改等。支持web图形化管理，集成多用户模式。</p></blockquote><h2 id="Tinc"><a href="#Tinc" class="headerlink" title="Tinc"></a>Tinc</h2><p>项目官网：<a href="https://www.tinc-vpn.org/" target="_blank" rel="noopener">https://www.tinc-vpn.org/</a></p><p>与N2N、PeerVPN以及ZeroTier等属于一类，服务端可以自己搭建，官网介绍是一旦连接成功后，就可以不需要走服务器流量，而是走P2P。搭建起来难度虽不大，但自己尝试时总是配置失败，可能是英文文档没有看明白吧。</p>]]></content>
      
      
      <categories>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> NAT </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用</title>
      <link href="/git-shi-yong.html"/>
      <url>/git-shi-yong.html</url>
      
        <content type="html"><![CDATA[<h1 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h1><h2 id="创建github账户"><a href="#创建github账户" class="headerlink" title="创建github账户"></a>创建github账户</h2><p>略</p><h2 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><pre><code>1. git init //初始化仓库2. git add .(文件name) //添加文件到本地仓库3. git commit -m &quot;first commit&quot; //添加文件描述信息4. git remote add origin + 远程仓库地址 //链接远程仓库，创建主分支5. git pull origin master // 把本地仓库的变化连接到远程仓库主分支6. git push -u origin master //把本地仓库的文件推送到远程仓库</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
